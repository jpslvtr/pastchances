================================================================
Repopack Output File
================================================================

This file was generated by Repopack on: 2025-06-11T04:11:04.042Z

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Repository structure
3. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
  distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.



For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
app/
  appengine_utilities/
    sessions.py
    settings_default.py
  pages/
    about.html
  static/
    main.css
  templates/
    entry.html
    index.html
    match.html
  app.yaml
  cas.py
  cron.yaml
  dndremote.py
  hothandler.py
  index.yaml
  lastchances.py
  queue.yaml
  settings.py
remote/
  dnd.py
  lookup.php
.gitignore
README.md

================================================================
Repository Files
================================================================

================
File: app/appengine_utilities/sessions.py
================
# -*- coding: utf-8 -*-
"""
Copyright (c) 2008, appengine-utilities project
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
- Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.
- Neither the name of the appengine-utilities project nor the names of its
  contributors may be used to endorse or promote products derived from this
  software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
"""

# main python imports
import os
import time
import datetime
import random
import hashlib
import Cookie
import pickle
import sys
import logging
from time import strftime

# google appengine imports
from google.appengine.ext import db
from google.appengine.api import memcache

from django.utils import simplejson

# settings
try:
    import settings_default
    import settings

    if settings.__name__.rsplit('.', 1)[0] != settings_default.__name__.rsplit('.', 1)[0]:
        settings = settings_default
except:
    settings = settings_default




class _AppEngineUtilities_Session(db.Model):
    """
    Model for the sessions in the datastore. This contains the identifier and
    validation information for the session.
    """

    sid = db.StringListProperty()
    ip = db.StringProperty()
    ua = db.StringProperty()
    last_activity = db.DateTimeProperty()
    dirty = db.BooleanProperty(default=False)
    working = db.BooleanProperty(default=False)
    deleted = db.BooleanProperty(default=False) 

    def put(self):
        """
        Extends put so that it writes vaules to memcache as well as the
        datastore, and keeps them in sync, even when datastore writes fails.

        Returns the session object.
        """
        try:
            memcache.set(u"_AppEngineUtilities_Session_%s" % \
                (str(self.key())), self)
        except:
            # new session, generate a new key, which will handle the
            # put and set the memcache
            db.put(self)

        self.last_activity = datetime.datetime.now()

        try:
            self.dirty = False
            db.put(self)
            memcache.set(u"_AppEngineUtilities_Session_%s" % \
                (str(self.key())), self)
        except:
            self.dirty = True
            memcache.set(u"_AppEngineUtilities_Session_%s" % \
                (str(self.key())), self)

        return self

    @classmethod
    def get_session(cls, session_obj=None):
        """
        Uses the passed objects sid to get a session object from memcache,
        or datastore if a valid one exists.

        Args:
            session_obj: a session object

        Returns a validated session object.
        """
        if session_obj.sid == None:
            return None
        session_key = session_obj.sid.rsplit(u'_', 1)[0]
        session = memcache.get(u"_AppEngineUtilities_Session_%s" % \
            (str(session_key)))
        if session:
            if session.deleted == True:
                session.delete()
                return None
            if session.dirty == True and session.working != False:
                # the working bit is used to make sure multiple requests,
                # which can happen with ajax oriented sites, don't try to put
                # at the same time
                session.working = True
                memcache.set(u"_AppEngineUtilities_Session_%s" % \
                    (str(session_key)), session)
                session.put()
            if session_obj.sid in session.sid:
                sessionAge = datetime.datetime.now() - session.last_activity
                if sessionAge.seconds > session_obj.session_expire_time:
                    session.delete()
                    return None
                return session
            else:
                return None
 
        # Not in memcache, check datastore
        
        try:
            ds_session = db.get(str(session_key))
        except:
            ds_session = None
        if ds_session:
          sessionAge = datetime.datetime.now() - ds_session.last_activity
          if sessionAge.seconds > session_obj.session_expire_time:
              ds_session.delete()
              return None
          memcache.set(u"_AppEngineUtilities_Session_%s" % \
              (str(session_key)), ds_session)
          memcache.set(u"_AppEngineUtilities_SessionData_%s" % \
              (str(session_key)), ds_session.get_items_ds())
        return ds_session


    def get_items(self):
        """
        Returns all the items stored in a session. Queries memcache first
        and will try the datastore next.
        """
        items = memcache.get(u"_AppEngineUtilities_SessionData_%s" % \
            (str(self.key())))
        if items:
            for item in items:
                if item.deleted == True:
                    item.delete()
                    items.remove(item)
            return items

        query = _AppEngineUtilities_SessionData.all()
        query.filter(u"session", self)
        results = query.fetch(1000)
        return results

    def get_item(self, keyname = None):
        """
        Returns a single session data item from the memcache or datastore

        Args:
            keyname: keyname of the session data object

        Returns the session data object if it exists, otherwise returns None
        """
        mc = memcache.get(u"_AppEngineUtilities_SessionData_%s" % \
            (str(self.key())))
        if mc:
            for item in mc:
                if item.keyname == keyname:
                    if item.deleted == True:
                        item.delete()
                        return None
                    return item
        query = _AppEngineUtilities_SessionData.all()
        query.filter(u"session = ", self)
        query.filter(u"keyname = ", keyname)
        results = query.fetch(1)
        if len(results) > 0:
            memcache.set(u"_AppEngineUtilities_SessionData_%s" % \
                (str(self.key())), self.get_items_ds())
            return results[0]
        return None

    def get_items_ds(self):
        """
        This gets all session data objects from the datastore, bypassing
        memcache.

        Returns a list of session data entities.
        """
        query = _AppEngineUtilities_SessionData.all()
        query.filter(u"session", self)
        results = query.fetch(1000)
        return results

    def delete(self):
        """
        Deletes a session and all it's associated data from the datastore and
        memcache.

        Returns True
        """
        try:
            query = _AppEngineUtilities_SessionData.all()
            query.filter(u"session = ", self)
            results = query.fetch(1000)
            db.delete(results)
            db.delete(self)
            memcache.delete_multi([u"_AppEngineUtilities_Session_%s" % \
                (str(self.key())), \
                u"_AppEngineUtilities_SessionData_%s" % \
                (str(self.key()))])
        except:
            mc = memcache.get(u"_AppEngineUtilities_Session_%s" % \
                (str(self.key())))
            if mc:
                mc.deleted = True
            else:
                # not in the memcache, check to see if it should be
                query = _AppEngineUtilities_Session.all()
                query.filter(u"sid = ", self.sid)
                results = query.fetch(1)
                if len(results) > 0:
                    results[0].deleted = True
                    memcache.set(u"_AppEngineUtilities_Session_%s" % \
                        (unicode(self.key())), results[0])
        return True
            
class _AppEngineUtilities_SessionData(db.Model):
    """
    Model for the session data in the datastore.
    """

    # session_key = db.FloatProperty()
    keyname = db.StringProperty()
    content = db.BlobProperty()
    model = db.ReferenceProperty()
    session = db.ReferenceProperty(_AppEngineUtilities_Session)
    dirty = db.BooleanProperty(default=False)
    deleted = db.BooleanProperty(default=False)

    def put(self):
        """
        Adds a keyname/value for session to the datastore and memcache

        Returns the key from the datastore put or u"dirty"
        """
        # update or insert in datastore
        try:
            return_val = db.put(self)
            self.dirty = False
        except:
            return_val = u"dirty"
            self.dirty = True

        # update or insert in memcache
        mc_items = memcache.get(u"_AppEngineUtilities_SessionData_%s" % \
            (str(self.session.key())))
        if mc_items:
            value_updated = False
            for item in mc_items:
                if value_updated == True:
                    break
                if item.keyname == self.keyname:
                    item.content = self.content
                    item.model = self.model
                    memcache.set(u"_AppEngineUtilities_SessionData_%s" % \
                        (str(self.session.key())), mc_items)
                    value_updated = True
                    break
            if value_updated == False:
                mc_items.append(self)
                memcache.set(u"_AppEngineUtilities_SessionData_%s" % \
                    (str(self.session.key())), mc_items)
        return return_val

    def delete(self):
        """
        Deletes an entity from the session in memcache and the datastore

        Returns True
        """
        try:
            db.delete(self)
        except:
            self.deleted = True
        mc_items = memcache.get(u"_AppEngineUtilities_SessionData_%s" % \
            (str(self.session.key())))
        value_handled = False
        for item in mc_items:
            if value_handled == True:
                break
            if item.keyname == self.keyname:
                if self.deleted == True:
                    item.deleted = True
                else:
                    mc_items.remove(item)
                memcache.set(u"_AppEngineUtilities_SessionData_%s" % \
                    (str(self.session.key())), mc_items)
        return True
        

class _DatastoreWriter(object):

    def put(self, keyname, value, session):
        """
        Insert a keyname/value pair into the datastore for the session.

        Args:
            keyname: The keyname of the mapping.
            value: The value of the mapping.

        Returns the model entity key
        """
        keyname = session._validate_key(keyname)
        if value is None:
            raise ValueError(u"You must pass a value to put.")

        # datestore write trumps cookie. If there is a cookie value
        # with this keyname, delete it so we don't have conflicting
        # entries.
        if session.cookie_vals.has_key(keyname):
            del(session.cookie_vals[keyname])
            session.output_cookie["%s_data" % (session.cookie_name)] = \
                simplejson.dumps(session.cookie_vals)
            session.output_cookie["%s_data" % (session.cookie_name)]["path"] = \
                session.cookie_path
            if session.cookie_domain:
                session.output_cookie["%s_data" % \
                    (session.cookie_name)]["domain"] = session.cookie_domain
            print session.output_cookie.output()

        sessdata = session._get(keyname=keyname)
        if sessdata is None:
            sessdata = _AppEngineUtilities_SessionData()
            # sessdata.session_key = session.session.key()
            sessdata.keyname = keyname
        try:
            db.model_to_protobuf(value)
            if not value.is_saved():
                value.put()
            sessdata.model = value
        except:
            sessdata.content = pickle.dumps(value)
            sessdata.model = None
        sessdata.session = session.session
            
        session.cache[keyname] = value
        return sessdata.put()


class _CookieWriter(object):
    def put(self, keyname, value, session):
        """
        Insert a keyname/value pair into the datastore for the session.

        Args:
            keyname: The keyname of the mapping.
            value: The value of the mapping.

        Returns True
        """
        keyname = session._validate_key(keyname)
        if value is None:
            raise ValueError(u"You must pass a value to put.")

        # Use simplejson for cookies instead of pickle.
        session.cookie_vals[keyname] = value
        # update the requests session cache as well.
        session.cache[keyname] = value
        # simplejson will raise any error I'd raise about an invalid value
        # so let it raise exceptions
        session.output_cookie["%s_data" % (session.cookie_name)] = \
            simplejson.dumps(session.cookie_vals)
        session.output_cookie["%s_data" % (session.cookie_name)]["path"] = \
            session.cookie_path
        if session.cookie_domain:
            session.output_cookie["%s_data" % \
                (session.cookie_name)]["domain"] = session.cookie_domain
        print session.output_cookie.output()
        return True

class Session(object):
    """
    Sessions are used to maintain user presence between requests.

    Sessions can either be stored server side in the datastore/memcache, or
    be kept entirely as cookies. This is set either with the settings file
    or on initialization, using the writer argument/setting field. Valid
    values are "datastore" or "cookie".

    Session can be used as a standard dictionary object.
        session = appengine_utilities.sessions.Session()
        session["keyname"] = "value" # sets keyname to value
        print session["keyname"] # will print value

    Datastore Writer:
        The datastore writer was written with the focus being on security,
        reliability, and performance. In that order.

        It is based off of a session token system. All data is stored
        server side in the datastore and memcache. A token is given to
        the browser, and stored server side. Optionally (and on by default),
        user agent and ip checking is enabled. Tokens have a configurable
        time to live (TTL), which defaults to 5 seconds. The current token,
        plus the previous 2, are valid for any request. This is done in order
        to manage ajax enabled sites which may have more than on request
        happening at a time. This means any token is valid for 15 seconds.
        A request with a token who's TTL has passed will have a new token
        generated.

        In order to take advantage of the token system for an authentication
        system, you will want to tie sessions to accounts, and make sure
        only one session is valid for an account. You can do this by setting
        a db.ReferenceProperty(_AppEngineUtilities_Session) attribute on
        your user Model, and use the get_ds_entity() method on a valid
        session to populate it on login.

        Note that even with this complex system, sessions can still be hijacked
        and it will take the user logging in to retrieve the account. In the
        future an ssl only cookie option may be implemented for the datastore
        writer, which would further protect the session token from being
        sniffed, however it would be restricted to using cookies on the
        .appspot.com domain, and ssl requests are a finite resource. This is
        why such a thing is not currently implemented.

        Session data objects are stored in the datastore pickled, so any
        python object is valid for storage.

    Cookie Writer:
        Sessions using the cookie writer are stored entirely in the browser
        and no interaction with the datastore is required. This creates
        a drastic improvement in performance, but provides no security for
        session hijack. This is useful for requests where identity is not
        important, but you wish to keep state between requests.

        Information is stored in a json format, as pickled data from the
        server is unreliable.

        Note: There is no checksum validation of session data on this method,
        it's streamlined for pure performance. If you need to make sure data
        is not tampered with, use the datastore writer which stores the data
        server side.

    django-middleware:
        Included with the GAEUtilties project is a
        django-middleware.middleware.SessionMiddleware which can be included in
        your settings file. This uses the cookie writer for anonymous requests,
        and you can switch to the datastore writer on user login. This will
        require an extra set in your login process of calling
        request.session.save() once you validated the user information. This
        will convert the cookie writer based session to a datastore writer.
    """

    # cookie name declaration for class methods
    COOKIE_NAME = settings.session["COOKIE_NAME"]

    def __init__(self, cookie_path=settings.session["DEFAULT_COOKIE_PATH"],
            cookie_domain=settings.session["DEFAULT_COOKIE_DOMAIN"],
            cookie_name=settings.session["COOKIE_NAME"],
            session_expire_time=settings.session["SESSION_EXPIRE_TIME"],
            clean_check_percent=settings.session["CLEAN_CHECK_PERCENT"],
            integrate_flash=settings.session["INTEGRATE_FLASH"],
            check_ip=settings.session["CHECK_IP"],
            check_user_agent=settings.session["CHECK_USER_AGENT"],
            set_cookie_expires=settings.session["SET_COOKIE_EXPIRES"],
            session_token_ttl=settings.session["SESSION_TOKEN_TTL"],
            last_activity_update=settings.session["UPDATE_LAST_ACTIVITY"],
            writer=settings.session["WRITER"]):
        """
        Initializer

        Args:
          cookie_path: The path setting for the cookie.
          cookie_domain: The domain setting for the cookie. (Set to False
                        to not use)
          cookie_name: The name for the session cookie stored in the browser.
          session_expire_time: The amount of time between requests before the
              session expires.
          clean_check_percent: The percentage of requests the will fire off a
              cleaning routine that deletes stale session data.
          integrate_flash: If appengine-utilities flash utility should be
              integrated into the session object.
          check_ip: If browser IP should be used for session validation
          check_user_agent: If the browser user agent should be used for
              sessoin validation.
          set_cookie_expires: True adds an expires field to the cookie so
              it saves even if the browser is closed.
          session_token_ttl: Number of sessions a session token is valid
              for before it should be regenerated.
        """

        self.cookie_path = cookie_path
        self.cookie_domain = cookie_domain
        self.cookie_name = cookie_name
        self.session_expire_time = session_expire_time
        self.integrate_flash = integrate_flash
        self.check_user_agent = check_user_agent
        self.check_ip = check_ip
        self.set_cookie_expires = set_cookie_expires
        self.session_token_ttl = session_token_ttl
        self.last_activity_update = last_activity_update
        self.writer = writer

        # make sure the page is not cached in the browser
        print self.no_cache_headers()
        # Check the cookie and, if necessary, create a new one.
        self.cache = {}
        string_cookie = os.environ.get(u"HTTP_COOKIE", u"")
        self.cookie = Cookie.SimpleCookie()
        self.output_cookie = Cookie.SimpleCookie()
        if string_cookie == "":
          self.cookie_vals = {}
        else:
            self.cookie.load(string_cookie)
            try:
                self.cookie_vals = \
                    simplejson.loads(self.cookie["%s_data" % (self.cookie_name)].value)
                    # sync self.cache and self.cookie_vals which will make those
                    # values available for all gets immediately.
                for k in self.cookie_vals:
                    self.cache[k] = self.cookie_vals[k]
                    # sync the input cookie with the output cookie
                    self.output_cookie["%s_data" % (self.cookie_name)] = \
                        simplejson.dumps(self.cookie_vals) #self.cookie["%s_data" % (self.cookie_name)]
            except Exception, e:
                self.cookie_vals = {}


        if writer == "cookie":
            pass
        else:
            self.sid = None
            new_session = True

            # do_put is used to determine if a datastore write should
            # happen on this request.
            do_put = False

            # check for existing cookie
            if self.cookie.get(cookie_name):
                self.sid = self.cookie[cookie_name].value
                # The following will return None if the sid has expired.
                self.session = _AppEngineUtilities_Session.get_session(self)
                if self.session:
                    new_session = False

            if new_session:
                # start a new session
                self.session = _AppEngineUtilities_Session()
                self.session.put()
                self.sid = self.new_sid()
                if u"HTTP_USER_AGENT" in os.environ:
                    self.session.ua = os.environ[u"HTTP_USER_AGENT"]
                else:
                    self.session.ua = None
                if u"REMOTE_ADDR" in os.environ:
                    self.session.ip = os.environ["REMOTE_ADDR"]
                else:
                    self.session.ip = None
                self.session.sid = [self.sid]
                # do put() here to get the session key
                self.session.put()
            else:
                # check the age of the token to determine if a new one
                # is required
                duration = datetime.timedelta(seconds=self.session_token_ttl)
                session_age_limit = datetime.datetime.now() - duration
                if self.session.last_activity < session_age_limit:
                    self.sid = self.new_sid()
                    if len(self.session.sid) > 2:
                        self.session.sid.remove(self.session.sid[0])
                    self.session.sid.append(self.sid)
                    do_put = True
                else:
                    self.sid = self.session.sid[-1]
                    # check if last_activity needs updated
                    ula = datetime.timedelta(seconds=self.last_activity_update)
                    if datetime.datetime.now() > self.session.last_activity + \
                        ula:
                        do_put = True

            self.output_cookie[cookie_name] = self.sid
            self.output_cookie[cookie_name]["path"] = self.cookie_path
            if self.cookie_domain:
                self.output_cookie[cookie_name]["domain"] = self.cookie_domain
            if self.set_cookie_expires:
                self.output_cookie[cookie_name]["expires"] = \
                    self.session_expire_time

            self.cache[u"sid"] = self.sid

            if do_put:
                if self.sid != None or self.sid != u"":
                    self.session.put()

        # Only set the "_data" cookie if there is actual data
        if self.output_cookie.has_key("%s_data" % (cookie_name)):
            # Set the path of the "_data" cookie
            self.output_cookie["%s_data" % (cookie_name)]["path"] = cookie_path
            if self.set_cookie_expires:
                self.output_cookie["%s_data" % (cookie_name)]["expires"] = \
                    self.session_expire_time
        print self.output_cookie.output()

        # fire up a Flash object if integration is enabled
        """
        if self.integrate_flash:
            import flash
            self.flash = flash.Flash(cookie=self.cookie)
        """

        # randomly delete old stale sessions in the datastore (see
        # CLEAN_CHECK_PERCENT variable)
        if random.randint(1, 100) < clean_check_percent:
            self._clean_old_sessions() 

    def new_sid(self):
        """
        Create a new session id.

        Returns session id as a unicode string.
        """
        sid = u"%s_%s" % (str(self.session.key()),
            hashlib.md5(repr(time.time()) + \
            unicode(random.random())).hexdigest()
        )
        #sid = unicode(self.session.session_key) + "_" + \
        #        hashlib.md5(repr(time.time()) + \
        #        unicode(random.random())).hexdigest()
        return sid

    def _get(self, keyname=None):
        """
        private method
        
        Return all of the SessionData object data from the datastore only,
        unless keyname is specified, in which case only that instance of 
        SessionData is returned.

        Important: This does not interact with memcache and pulls directly
        from the datastore. This also does not get items from the cookie
        store.

        Args:
            keyname: The keyname of the value you are trying to retrieve.

        Returns a list of datastore entities.
        """
        if hasattr(self, 'session'):
            if keyname != None:
                return self.session.get_item(keyname)
            return self.session.get_items()
        return None
    
    def _validate_key(self, keyname):
        """
        private method
        
        Validate the keyname, making sure it is set and not a reserved name.

        Returns the validated keyname.
        """
        if keyname is None:
            raise ValueError(
                u"You must pass a keyname for the session data content."
            )
        elif keyname in (u"sid", u"flash"):
            raise ValueError(u"%s is a reserved keyname." % keyname)

        if type(keyname) != type([str, unicode]):
            return unicode(keyname)
        return keyname

    def _put(self, keyname, value):
        """
        Insert a keyname/value pair into the datastore for the session.

        Args:
            keyname: The keyname of the mapping.
            value: The value of the mapping.

        Returns the value from the writer put operation, varies based on writer.
        """
        if self.writer == "datastore":
            writer = _DatastoreWriter()
        else:
            writer = _CookieWriter()

        return writer.put(keyname, value, self)

    def _delete_session(self):
        """
        private method
        
        Delete the session and all session data.

        Returns True.
        """
        # if the event class has been loaded, fire off the preSessionDelete event
        if u"AEU_Events" in sys.modules['__main__'].__dict__:
            sys.modules['__main__'].AEU_Events.fire_event(u"preSessionDelete")
        if hasattr(self, u"session"):
            self.session.delete()
        self.cookie_vals = {}
        self.cache = {}
        self.output_cookie["%s_data" % (self.cookie_name)] = \
            simplejson.dumps(self.cookie_vals)
        self.output_cookie["%s_data" % (self.cookie_name)]["path"] = \
            self.cookie_path
        if self.cookie_domain:
            self.output_cookie["%s_data" % \
                (self.cookie_name)]["domain"] = self.cookie_domain
        # Delete the cookies (session & data) in the browser
        self.output_cookie[self.cookie_name]["expires"] = 0
        self.output_cookie["%s_data" % (self.cookie_name)]["expires"] = 0

        print self.output_cookie.output()
        # if the event class has been loaded, fire off the sessionDelete event
        if u"AEU_Events" in sys.modules['__main__'].__dict__:
            sys.modules['__main__'].AEU_Events.fire_event(u"sessionDelete")
        return True

    def delete(self):
        """
        Delete the current session and start a new one.

        This is useful for when you need to get rid of all data tied to a
        current session, such as when you are logging out a user.

        Returns True
        """
        self._delete_session()

    @classmethod
    def delete_all_sessions(cls):
        """
        Deletes all sessions and session data from the data store. This
        does not delete the entities from memcache (yet). Depending on the
        amount of sessions active in your datastore, this request could
        timeout before completion and may have to be called multiple times.

        NOTE: This can not delete cookie only sessions as it has no way to
        access them. It will only delete datastore writer sessions.

        Returns True on completion.
        """
        all_sessions_deleted = False

        while not all_sessions_deleted:
            query = _AppEngineUtilities_Session.all()
            results = query.fetch(75)
            if len(results) is 0:
                all_sessions_deleted = True
            else:
                for result in results:
                    result.delete()
        return True


    def _clean_old_sessions(self):
        """
        Delete 50 expired sessions from the datastore.

        This is only called for CLEAN_CHECK_PERCENT percent of requests because
        it could be rather intensive.

        Returns True on completion
        """
        self.clean_old_sessions(self.session_expire_time, 50)


    @classmethod
    def clean_old_sessions(cls, session_expire_time, count=50):
        """
        Delete expired sessions from the datastore.

        This is a class method which can be used by applications for
        maintenance if they don't want to use the built in session
        cleaning.

        Args:
          count: The amount of session to clean.
          session_expire_time: The age in seconds to determine outdated
                               sessions.

        Returns True on completion
        """
        duration = datetime.timedelta(seconds=session_expire_time)
        session_age = datetime.datetime.now() - duration
        query = _AppEngineUtilities_Session.all()
        query.filter(u"last_activity <", session_age)
        results = query.fetch(50)
        for result in results:
            result.delete()
        return True

    def cycle_key(self):
        """
        Changes the session id/token.

        Returns new token.
        """
        self.sid = self.new_sid()
        if len(self.session.sid) > 2:
            self.session.sid.remove(self.session.sid[0])
        self.session.sid.append(self.sid)
        
        return self.sid

    def flush(self):
        """
        Delete's the current session, creating a new one.

        Returns True
        """
        self._delete_session()
        self.__init__()
        return True

    def no_cache_headers(self):
        """
        Generates headers to avoid any page caching in the browser.
        Useful for highly dynamic sites.

        Returns a unicode string of headers.
        """
        return u"".join([u"Expires: Tue, 03 Jul 2001 06:00:00 GMT",
            strftime("Last-Modified: %a, %d %b %y %H:%M:%S %Z").decode("utf-8"),
            u"Cache-Control: no-store, no-cache, must-revalidate, max-age=0",
            u"Cache-Control: post-check=0, pre-check=0",
            u"Pragma: no-cache",
        ])

    def clear(self):
        """
        Removes session data items, doesn't delete the session. It does work
        with cookie sessions, and must be called before any output is sent
        to the browser, as it set cookies.

        Returns True
        """
        sessiondata = self._get()
        # delete from datastore
        if sessiondata is not None:
            for sd in sessiondata:
                sd.delete()
        # delete from memcache
        self.cache = {}
        self.cookie_vals = {}
        self.output_cookie["%s_data" % (self.cookie_name)] = \
            simplejson.dumps(self.cookie_vals)
        self.output_cookie["%s_data" % (self.cookie_name)]["path"] = \
            self.cookie_path
        if self.cookie_domain:
            self.output_cookie["%s_data" % \
                (self.cookie_name)]["domain"] = self.cookie_domain
        # Delete the "_data" cookie in the browser
        self.output_cookie["%s_data" % (self.cookie_name)]["expires"] = 0

        print self.output_cookie.output()
        return True

    def has_key(self, keyname):
        """
        Equivalent to k in a, use that form in new code

        Args:
            keyname: keyname to check

        Returns True/False
        """
        return self.__contains__(keyname)

    def items(self):
        """
        Creates a copy of just the data items.

        Returns dictionary of session data objects.
        """
        op = {}
        for k in self:
            op[k] = self[k]
        return op

    def keys(self):
        """
        Returns a list of keys.
        """
        l = []
        for k in self:
            l.append(k)
        return l

    def update(self, *dicts):
        """
        Updates with key/value pairs from b, overwriting existing keys

        Returns None
        """
        for dict in dicts:
            for k in dict:
                self._put(k, dict[k])
        return None

    def values(self):
        """
        Returns a list object of just values in the session.
        """
        v = []
        for k in self:
            v.append(self[k])
        return v

    def get(self, keyname, default = None):
        """
        Returns either the value for the keyname or a default value
        passed.

        Args:
            keyname: keyname to look up
            default: (optional) value to return on keyname miss

        Returns value of keyname, or default, or None
        """
        try:
            return self.__getitem__(keyname)
        except KeyError:
            if default is not None:
                return default
            return None

    def setdefault(self, keyname, default = None):
        """
        Returns either the value for the keyname or a default value
        passed. If keyname lookup is a miss, the keyname is set with
        a value of default.

        Args:
            keyname: keyname to look up
            default: (optional) value to return on keyname miss

        Returns value of keyname, or default, or None
        """
        try:
            return self.__getitem__(keyname)
        except KeyError:
            if default is not None:
                self.__setitem__(keyname, default)
                return default
            return None

    @classmethod
    def check_token(cls, cookie_name=COOKIE_NAME, delete_invalid=True):
        """
        Retrieves the token from a cookie and validates that it is
        a valid token for an existing cookie. Cookie validation is based
        on the token existing on a session that has not expired.

        This is useful for determining if datastore or cookie writer
        should be used in hybrid implementations.

        Args:
            cookie_name: Name of the cookie to check for a token.
            delete_invalid: If the token is not valid, delete the session
                            cookie, to avoid datastore queries on future
                            requests.

        Returns True/False
        """

        string_cookie = os.environ.get(u"HTTP_COOKIE", u"")
        cookie = Cookie.SimpleCookie()
        cookie.load(string_cookie)
        if cookie.has_key(cookie_name):
            query = _AppEngineUtilities_Session.all()
            query.filter(u"sid", cookie[cookie_name].value)
            results = query.fetch(1)
            if len(results) > 0:
                return True
            else:
                if delete_invalid:
                    output_cookie = Cookie.SimpleCookie()
                    output_cookie[cookie_name] = cookie[cookie_name]
                    output_cookie[cookie_name][u"expires"] = 0
                    print output_cookie.output()
        return False

    def get_ds_entity(self):
        """
        Will return the session entity from the datastore if one
        exists, otherwise will return None (as in the case of cookie writer
        session.
        """
        if hasattr(self, u"session"):
            return self.session
        return None

    # Implement Python container methods

    def __getitem__(self, keyname):
        """
        Get item from session data.

        keyname: The keyname of the mapping.
        """
        # flash messages don't go in the datastore

        if self.integrate_flash and (keyname == u"flash"):
            return self.flash.msg
        if keyname in self.cache:
            return self.cache[keyname]
        if keyname in self.cookie_vals:
            return self.cookie_vals[keyname]
        if hasattr(self, u"session"):
            data = self._get(keyname)
            if data:
                # TODO: It's broke here, but I'm not sure why, it's
                # returning a model object, but I can't seem to modify
                # it.
                try:
                    if data.model != None:
                        self.cache[keyname] = data.model
                        return self.cache[keyname]
                    else:
                        self.cache[keyname] = pickle.loads(data.content)
                        return self.cache[keyname]
                except:
                    self.delete_item(keyname)

            else:
                raise KeyError(unicode(keyname))
        raise KeyError(unicode(keyname))

    def __setitem__(self, keyname, value):
        """
        Set item in session data.

        Args:
            keyname: They keyname of the mapping.
            value: The value of mapping.
        """

        if self.integrate_flash and (keyname == u"flash"):
            self.flash.msg = value
        else:
            keyname = self._validate_key(keyname)
            self.cache[keyname] = value
            return self._put(keyname, value)

    def delete_item(self, keyname, throw_exception=False):
        """
        Delete item from session data, ignoring exceptions if
        necessary.

        Args:
            keyname: The keyname of the object to delete.
            throw_exception: false if exceptions are to be ignored.
        Returns:
            Nothing.
        """
        if throw_exception:
            self.__delitem__(keyname)
            return None
        else:
            try:
                self.__delitem__(keyname)
            except KeyError:
                return None

    def __delitem__(self, keyname):
        """
        Delete item from session data.

        Args:
            keyname: The keyname of the object to delete.
        """
        bad_key = False
        sessdata = self._get(keyname = keyname)
        if sessdata is None:
            bad_key = True
        else:
            sessdata.delete()
        if keyname in self.cookie_vals:
            del self.cookie_vals[keyname]
            bad_key = False
            self.output_cookie["%s_data" % (self.cookie_name)] = \
                simplejson.dumps(self.cookie_vals)
            self.output_cookie["%s_data" % (self.cookie_name)]["path"] = \
                self.cookie_path
            if self.cookie_domain:
                self.output_cookie["%s_data" % \
                    (self.cookie_name)]["domain"] = self.cookie_domain

            print self.output_cookie.output()
        if bad_key:
            raise KeyError(unicode(keyname))
        if keyname in self.cache:
            del self.cache[keyname]

    def __len__(self):
        """
        Return size of session.
        """
        # check memcache first
        if hasattr(self, u"session"):
            results = self._get()
            if results is not None:
                return len(results) + len(self.cookie_vals)
            else:
                return 0
        return len(self.cookie_vals)

    def __contains__(self, keyname):
        """
        Check if an item is in the session data.

        Args:
            keyname: The keyname being searched.
        """
        try:
            self.__getitem__(keyname)
        except KeyError:
            return False
        return True

    def __iter__(self):
        """
        Iterate over the keys in the session data.
        """
        # try memcache first
        if hasattr(self, u"session"):
            vals = self._get()
            if vals is not None:
                for k in vals:
                    yield k.keyname
        for k in self.cookie_vals:
            yield k

    def __str__(self):
        """
        Return string representation.
        """
        return u"{%s}" % ', '.join(['"%s" = "%s"' % (k, self[k]) for k in self])

================
File: app/appengine_utilities/settings_default.py
================
"""
Copyright (c) 2008, appengine-utilities project
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
- Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.
- Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.
- Neither the name of the appengine-utilities project nor the names of its
  contributors may be used to endorse or promote products derived from this
  software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
"""

__author__="jbowman"
__date__ ="$Sep 11, 2009 4:20:11 PM$"


# Configuration settings for the session class.
session = {    
    "COOKIE_NAME": "gaeutilities_session",
    "DEFAULT_COOKIE_PATH": "/",
    "DEFAULT_COOKIE_DOMAIN": False, # Set to False if you do not want this value
                                    # set on the cookie, otherwise put the
                                    # domain value you wish used.
    "SESSION_EXPIRE_TIME": 7200,    # sessions are valid for 7200 seconds
                                    # (2 hours)
    "INTEGRATE_FLASH": True,        # integrate functionality from flash module?
    "SET_COOKIE_EXPIRES": True,     # Set to True to add expiration field to
                                    # cookie
    "WRITER":"datastore",           # Use the datastore writer by default. 
                                    # cookie is the other option.
    "CLEAN_CHECK_PERCENT": 50,      # By default, 50% of all requests will clean
                                    # the datastore of expired sessions
    "CHECK_IP": True,               # validate sessions by IP
    "CHECK_USER_AGENT": True,       # validate sessions by user agent
    "SESSION_TOKEN_TTL": 5,         # Number of seconds a session token is valid
                                    # for.
    "UPDATE_LAST_ACTIVITY": 60,     # Number of seconds that may pass before
                                    # last_activity is updated
}

================
File: app/pages/about.html
================
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
        <title>Dartmouth Class of 2011 Last Chances</title>
        <link type="text/css" rel="stylesheet" href="/static/main.css" />
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-23367713-2']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
    </head>
    <body>
        <div class="mainoutline">
        <h1>Dartmouth '11 Last Chances</h1>
        
        <p><span class="loud"><strong>About</strong><br>
            </span>
            </p>
        <p>
        This app is by <a href="http://www.ianww.com">Ian Webster</a> '11 for Dartmouth 2011 Class Council and maintained by <a href="http://hacktown.cs.dartmouth.edu/">Hacker Club</a>.  For help with technical issues please blitz "ianw."
        </p>
        <p>
        You'll get results on June 1st...11 days til graduation!
        </p>

        </div>
        <div class="footer"><a href="/">Home</a> | About</div>
    </body>
</html>

================
File: app/static/main.css
================
a:link {
    color: green;
}

a.speciallink:link {
    color: #08a600;
}

a.speciallink:visited {
    color: #08a600;
}

a.speciallink:hover {
    color: #220022;
}

a:visited {
    color: green;
}

a:hover {
    color: #220022;
}

.body {
    background-color: #eee;
}

.loud {
    font-size: 24px;
}

.blurb {
    font-size: 12px;
}

.h1 {
    font-size: 23px;
    font-weight: bold;
}

.footer {
    text-align: center;
    font-size: 17px;
}

.mainoutline {
    font-family: "Trebuchet MS", sans-serif;
    border-width: 1px;
    border-style: solid;
    border-color: #ddd;
    width: 80%;
    padding: 10px;
    margin-left: auto;
    margin-right: auto;
}

.imagewrap {
    padding: 5px 5px 5px 5px;
}

================
File: app/templates/entry.html
================
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
        <title>Dartmouth Class of 2011 Last Chances</title>
        <link type="text/css" rel="stylesheet" href="/static/main.css" />
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-23367713-2']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
    </head>
    <body>
        <div class="mainoutline">
        <h1>Dartmouth '11 Last Chances</h1>
        
        <p><span class="loud"><strong>Find hookups, etc.</strong><br>
            Logged in as {{id}}. (<a href="{{logout_url}}">Log out</a>)
            </span>
            </p>

        <p>
        Enter up to 11 names - DND entries work ('11s only).<br>
        Your picks are kept private unless you are matched. Matches are done by a computer.<br>
        Also - use normal characters, no crazy accents and stuff, DND doesn't like them:<br>
        <form id="mainform" action="/entry" method="post">
            <input id="c0" name="c" type="text" value="{{v.0}}"/>{{comments.0}}<br>
            <input id="c1" name="c" type="text" value="{{v.1}}"/>{{comments.1}}<br>
            <input id="c2" name="c" type="text" value="{{v.2}}"/>{{comments.2}}<br>
            <input id="c3" name="c" type="text" value="{{v.3}}"/>{{comments.3}}<br>
            <input id="c4" name="c" type="text" value="{{v.4}}"/>{{comments.4}}<br>
            <input id="c5" name="c" type="text" value="{{v.5}}"/>{{comments.5}}<br>
            <input id="c6" name="c" type="text" value="{{v.6}}"/>{{comments.6}}<br>
            <input id="c7" name="c" type="text" value="{{v.7}}"/>{{comments.7}}<br>
            <input id="c8" name="c" type="text" value="{{v.8}}"/>{{comments.8}}<br>
            <input id="c9" name="c" type="text" value="{{v.9}}"/>{{comments.9}}<br>
            <input id="c10" name="c" type="text" value="{{v.10}}"/>{{comments.10}}<br>
            <!--<input type="submit" value="Save"/>-->Sorry, too late for changes.
        </form>
        </p>
        <hr/>
        <p>
        You'll receive an email with matches at:
        <form action="/email" method="post">
            <input id="email" name="email" type="text" value="{{email}}" size="40"/><br>
            <input type="submit" value="Save"/>
        </form>
        </p>
        </div>
        <div class="footer">
            Home | <a href="/pages/about.html">About</a><br>
            660 people, 3743 entries and counting. What are your chances?
        </div>
    </body>
</html>

================
File: app/templates/index.html
================
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
        <title>Dartmouth Class of 2011 Last Chances</title>
        <link type="text/css" rel="stylesheet" href="/static/main.css" />
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-23367713-2']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
    </head>
    <body>
        <div class="mainoutline">
        <h1>Dartmouth '11 Last Chances</h1>
        
        <!--
        <p><span class="loud"><strong>Find hookups, etc.</strong><br>
            You'll get an email with matches in time for Senior Week.</span>
            </p>
            -->
            <h2>Results are out</h2>

            <p>
            {% if user %}
            Hi, {{user.id}}.  <a href="/entry">Go to entry/results page</a>
            <br>
            (<a href="{{logout_url}}">Log out</a>)
            {% else %}
            <h1><a href="/login">Login</a></h1>
            {% endif %}
            </p>
        
        </div>
        <div class="footer">Home | <a href="/pages/about.html">About</a><br>
            660 people, 3743 entries and counting. What are your chances?
        </div>
    </body>
</html>

================
File: app/templates/match.html
================
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
        <title>Dartmouth Class of 2011 Last Chances</title>
        <link type="text/css" rel="stylesheet" href="/static/main.css" />
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-23367713-2']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
    </head>
    <body>
        <div class="mainoutline">
        <h1>Dartmouth '11 Last Chances</h1>
        
        <p><span class="loud"><strong>Find hookups, etc.</strong><br>
            Logged in as {{id}}. (<a href="{{logout_url}}">Log out</a>)
            </span>
            </p>

        <p>
        <h1>{{match}}</h1>
        </p>
        </div>
        <div class="footer">
            Home | <a href="/pages/about.html">About</a><br>
            660 people, 3743 entries and counting. What are your chances?
        </div>
    </body>
</html>

================
File: app/app.yaml
================
application: dartmouthlastchances
version: 1
runtime: python
api_version: 1

handlers:
- url: /static
  static_dir: static

- url: /pages
  static_dir: pages

- url: /match
  script: lastchances.py
  login: admin

- url: /mail
  script: lastchances.py
  login: admin

- url: /mailuser
  script: lastchances.py
  login: admin

- url: /addtestcrush
  script: lastchances.py
  login: admin

- url: /clearmemcache
  script: lastchances.py
  login: admin

- url: /clearall
  script: lastchances.py
  login: admin

- url: /crushedon
  script: lastchances.py
  login: admin

- url: /stats
  script: lastchances.py
  login: admin

- url: /_ah/queue/hothandler/.*
  script: hothandler.py
  login: admin

- url: /.*
  script: lastchances.py

builtins:
- datastore_admin: on

================
File: app/cas.py
================
##
# Python CAS client
# Based on https://sp.princeton.edu/oit/sdp/CAS/Wiki%20Pages/Python.aspx
# Modified by Ian Webster 4/2/11
##

import urllib
import re


class CASClient:
    
    def __init__(self, cas_url, service_url):
        self.cas_url = cas_url
        self.service_url = service_url


    def Authenticate(self, ticket=None):
        # If the request contains a login ticket, try to validate it
        if ticket:
            id = self.Validate(ticket)
            if id:
                return id

        # No valid ticket; redirect the browser to the login page to get one
        login_url = self.cas_url + 'login' \
            + '?service=' + urllib.quote(self.service_url)
        print 'Location: ' + login_url
        print 'Status-line: HTTP/1.1 307 Temporary Redirect'
        print ""


    def Validate(self, ticket):
        # TODO handle downloaderror
        val_url = self.cas_url + "validate" + \
            '?service=' + urllib.quote(self.service_url) + \
            '&ticket=' + urllib.quote(ticket)
        r = urllib.urlopen(val_url).readlines()    # returns 2 lines
        if len(r) == 2 and re.match("yes", r[0]) != None:
            return r[1].strip()
        return None

================
File: app/cron.yaml
================
cron:
- description: ensure hot handler
  url: /_ah/queue/hothandler/start
  schedule: every 4 hours

================
File: app/dndremote.py
================
import logging
import urllib
from google.appengine.api.urlfetch import fetch
from google.appengine.api import memcache as mc

# This lookup was too slow - took 15+ sec and often timed out.
# Probably better now after the apache wscgi fix:
#REMOTE_LOOKUP = 'http://hacktown.cs.dartmouth.edu/lastchances/lookup.php?names='

# So I set up lookup on my own server...
REMOTE_LOOKUP = 'http://ianww.com/dnd/lookup.php?names=%s&year=%s'

class DNDRemoteLookup:

    def lookup(self, names, year):
        ret = {}


        # Only query the names we don't have memcached
        # TODO could be made even better by caching all blitz nicks, but it's not really a big deal
        less = []
        for x in names:
            if x == '':
                continue
            cached = mc.get(x, namespace='dnd')
            if cached:
                logging.info('DND got %s from cache' % (x))
                ret[x] = cached
            else:
                logging.info('DND need to look up %s' % (x))
                less.append(x)

        #less = [x for x in names if x != '']
        if len(less) > 0:
            l = fetch(REMOTE_LOOKUP % (urllib.quote(','.join(less)), year), deadline=15).content
            results = l.split('#')
            i = 0
            for result in results:
                lines = result.splitlines()
                ret[less[i]] = lines
                # set cache
                # TODO maybe set_multi
                mc.set(less[i], lines, namespace='dnd')
                i += 1
        return ret

================
File: app/hothandler.py
================
"""
Copyright (C)  2009  twitter.com/rcb

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
"""
import random
from wsgiref.handlers import CGIHandler
from google.appengine.api.labs import taskqueue
from google.appengine.api import memcache
from google.appengine.api.capabilities import CapabilitySet
memcache_service = CapabilitySet('memcache', methods=['set','get'])
hot_handler_queue = taskqueue.Queue(name='hothandler')
HOT_HANDLER_PREFIX = '/_ah/queue/hothandler/'
def wsgi_app(env, res):
    """ visit '/_ah/queue/hothandler/start' as admin to start a task """
    token = env['PATH_INFO'].replace(HOT_HANDLER_PREFIX,'')
    cur_token = memcache.get(HOT_HANDLER_PREFIX)
    if cur_token is None:
        if not memcache_service.is_enabled():
            cur_token = token
    if token in [cur_token, 'start']:
        next_token = str(random.random())
        url = '%s%s'%(HOT_HANDLER_PREFIX, next_token)
        next_task = taskqueue.Task(countdown=10, url=url)
        hot_handler_queue.add(next_task)
        memcache.set(HOT_HANDLER_PREFIX, next_token)
    res('200 OK',[('Content-Type','text/plain')])
    return ['ok']
def main():
    CGIHandler().run(wsgi_app)
    
if __name__ == '__main__':
    main()

================
File: app/index.yaml
================
indexes:

# AUTOGENERATED

# This index.yaml is automatically updated whenever the dev_appserver
# detects that a new type of query is run.  If you want to manage the
# index.yaml file manually, remove the above marker line (the line
# saying "# AUTOGENERATED").  If you want to manage some indexes
# manually, move them above the marker line.  The index.yaml file is
# automatically uploaded to the admin console when you next deploy
# your application using appcfg.py.

- kind: Crush
  properties:
  - name: id
  - name: created

================
File: app/lastchances.py
================
#!/usr/bin/env python
#
# Google App Engine app for Dartmouth last chances
#


import logging
import wsgiref.handlers
import os
import cgi

from cas import CASClient
from appengine_utilities import sessions
from dndremote import DNDRemoteLookup

from django.utils import simplejson as json
from google.appengine.ext import db
from google.appengine.ext import webapp
from google.appengine.ext.webapp import util
from google.appengine.ext.webapp import template
from google.appengine.api import mail
from google.appengine.api import memcache as mc
from google.appengine.api import taskqueue
from google.appengine.runtime import DeadlineExceededError

from settings import DEBUG, CLASS_YEAR, RELEASE_MATCHES

CAS_URL = 'https://login.dartmouth.edu/cas/'
if DEBUG:
    SERVICE_URL = 'http://localhost:8080/login'
else:
    #SERVICE_URL = 'http://dartmouthlastchances.appspot.com/login'
    SERVICE_URL = 'http://www.dartmouthlastchances.com/login'

LOGOUT_URL = '/logout'
CAS_LOGOUT_URL = 'https://login.dartmouth.edu/cas/logout?service='+SERVICE_URL


class User(db.Model):
    id = db.StringProperty(required=True)
    email = db.StringProperty(required=True)
    created = db.DateTimeProperty(auto_now_add=True)
    updated = db.DateTimeProperty(auto_now=True)


class Crush(db.Model):
    id = db.StringProperty(required=True)
    crush = db.StringProperty(required=True)
    created = db.DateTimeProperty(auto_now_add=True)


class Match(db.Model):
    id = db.StringProperty(required=True)
    name1 = db.StringProperty(required=True)
    name2 = db.StringProperty(required=True)
    email = db.StringProperty(required=False)


class Stats(db.Model):
    num_matches = db.IntegerProperty(required=True)
    num_participants = db.IntegerProperty(required=True)
    num_entries = db.IntegerProperty(required=True)


# Handles sessions
class BaseHandler(webapp.RequestHandler):
    @property
    def current_user(self):
        if not hasattr(self, '_current_user'):
            sess = sessions.Session()
            if 'id' in sess:
                id = sess['id']

                # Try to find user info in memcache
                cache = mc.get(id, namespace='users')
                if cache:
                    logging.info('Found user %s in cache' % (id))
                    u = User(id=id,email=cache['email'])
                else:
                    logging.info('Looking for user %s in store' % (id))
                    u = User.get_by_key_name(id)

                    if u:
                        # Memcache already existing user
                        logging.info('Setting user %s in cache' % (id))
                        mc.set(id, dict(id=u.id, email=u.email), namespace='users')
                    else:
                        # We have a new user
                        logging.info('Creating new user %s' % (id))

                        # Make sure it's the correct class year
                        d = DNDRemoteLookup()
                        dndnames = d.lookup([id], CLASS_YEAR)
                        if id not in dndnames or len(dndnames[id])==0:
                            logging.info('Reject new user %s' % (id))
                            self.response.out.write("Sorry, only the senior class can enter last chances.  If you think there's been a mistake, please contact people running this.")
                            self._current_user = None
                            sess.delete()
                            return None

                        # Add new user
                        email = id.replace(' ','.').replace('..', '.') + '@dartmouth.edu'
                        u = User(key_name=id, id=id, email=email)
                        u.save()

                        # memcache the user
                        mc.set(id, dict(id=id, email=email), namespace='users')

                self._current_user = u
            else:
                self._current_user = None
        return self._current_user


    def render_main(self, crushes=None, comments=['']*11):
        # Display entry page, with errors, etc.

        if not crushes:
            # Get default entries
            query = db.Query(Crush)
            query.filter('id =', self.current_user.id)
            query.order('created')

            results = query.fetch(11)
            crushes = [x.crush for x in results]

        # Pad lists
        crushes += ['']*(11-len(crushes))
        comments += ['']*(11-len(comments))

        args = dict(id=self.current_user.id, v=crushes, comments=comments, logout_url=LOGOUT_URL, email=self.current_user.email)
        self.response.out.write(template.render('templates/entry.html', args))


class HomeHandler(BaseHandler):
    def get(self):
        # TODO show matches so far or other interesting statistics
        args = dict(user=self.current_user, logout_url=LOGOUT_URL)
        self.response.out.write(template.render('templates/index.html', args))


class LoginHandler(BaseHandler):
    def get(self):
        # Login if necessary
        c = CASClient(CAS_URL, SERVICE_URL)
        id = c.Authenticate(self.request.get('ticket', None))

        if id:
            sess = sessions.Session()
            try:
                sess['id'] = id[:id.find('@')]
                self.redirect('/entry')
                return
            except:
                pass
        self.response.out.write('Login failed')
        

class EntryHandler(BaseHandler):
    def get(self): 
        if not self.current_user:
            self.response.out.write('You are not logged in.  <a href="/">Home</a>')
            return

        if RELEASE_MATCHES:
            q = db.Query(Match)
            q.filter('name1 =', self.current_user.id)

            matches = []
            for match in q:
                matches.append(match.name2)

            if len(matches) > 0:
                match = 'Your match(es): %s' % (', '.join(matches))
            else:
                match = 'Sorry, no matches :('

            args = dict(id=self.current_user.id, logout_url=LOGOUT_URL, email=self.current_user.email, match=match)
            self.response.out.write(template.render('templates/match.html', args))
        else:
            # Generate entry response
            self.render_main()


    def post(self):
        if not self.current_user:
            args = dict(user=self.current_user, logout_url=LOGOUT_URL)
            self.response.out.write(template.render('templates/index.html', args))
            return

        try:
            query = db.Query(Crush)
            query.filter('id =', self.current_user.id)
            query.order('created')

            results = query.fetch(11)
            orig_crushes = [x.crush for x in results]

            names = self.request.POST.getall('c')
            orig = self.request.POST.getall('o')

            # First handle deletion
            for crush in orig_crushes:
                if crush not in names:
                    crushkey = self.current_user.id+':'+crush
                    c = Crush.get_by_key_name(crushkey)
                    if c:
                        logging.info('deleting crush %s from cache and store' % (crushkey))
                        c.delete()
                        mc.delete(crushkey, namespace='crushes')

            # Now add anything new
            d = DNDRemoteLookup()
            # TODO not necessary to lookup names that were already in there (even though we memcache lookups)
            dndnames = d.lookup(names, CLASS_YEAR)
            new_crushes = []
            comments = []
            i = 0
            for name in names:
                if name == '':
                    i+=1
                    continue

                # Check if it's already there
                crushkeyname = self.current_user.id+':'+name
                c = mc.get(crushkeyname, namespace='crushes')

                if c != None or Crush.get_by_key_name(crushkeyname):
                    # We also checked that it's in db in case it got evicted from cache
                    if c:
                        logging.info('Found preexisting crush in cache')
                    else:
                        logging.info('Found preexisting crush in store')

                    # Was already validated, so no need to check in dndnames
                    comments.append('')
                    new_crushes.append(name)
                else:
                    # Crush doesn't already exist
                    if len(dndnames[name]) == 0:
                        # No good
                        comments.append('DND couldn\'t find anyone named "%s" in your year' % (cgi.escape(name)))
                        new_crushes.append('')
                    elif len(dndnames[name]) == 1:
                        # New crush
                        resolved_name = dndnames[name][0]
                        crushkeyname = self.current_user.id+':'+resolved_name
                        c = Crush(key_name=crushkeyname, id=self.current_user.id, crush=resolved_name)
                        c.put()
                        mc.set(crushkeyname, True, namespace='crushes')
                        comments.append('Saved')
                        new_crushes.append(resolved_name)
                    else:
                        # Unspecific - let them choose
                        links = ['<a href="#" onClick="document.getElementById(\'c%d\').value=\'%s\';return false;">%s</a>' \
                                 % (i,x,x) for x in dndnames[name]]
                        comments.append('Did you mean: ' + ', '.join(links))
                        new_crushes.append('')
                i += 1

            self.render_main(crushes=new_crushes, comments=comments)

        except DeadlineExceededError:
            self.response.clear()
            self.response.set_status(500)
            self.response.out.write('The operation could not be completed in time.  Try again or contact technical assistance.')


class EmailHandler(BaseHandler):
    def post(self): 
        if self.current_user:
            # Update in actual store
            # (remember self.current_user isn't real datastore user for performance issues)
            logging.info('email change lookup for user %s' % (self.current_user.id))
            u = User.get_by_key_name(self.current_user.id)
            if u:
                newemail = self.request.get('email')     # empty string by default
                u.email = newemail
                u.put()

                # Keep cache up to date
                mc.set(self.current_user.id, dict(id=u.id, email=u.email), namespace='users')

                # Update return
                self.current_user.email = newemail

            self.render_main()


class LogoutHandler(BaseHandler):
    def get(self):
        sessions.Session().delete()
        self.redirect(CAS_LOGOUT_URL)


class MatchHandler(webapp.RequestHandler):
    def get(self):
        crushes = Crush.all()

        # Create dict, keyed by crusher, value crushee
        d = {}
        for entry in crushes:
            key = entry.id + ':' + entry.crush
            d[key] = entry

        for key in d:
            if d[key].crush == d[key].id:
                # self-crush
                continue

            matchkey = d[key].crush + ':' + d[key].id
            # If there's a match, we expect to see this key
            if matchkey in d:
                logging.warning('%s matches %s!\n' % (d[key].id, d[key].crush))
                # look up crusher's preferred email
                user = User.get_by_key_name(d[key].id)
                if not user:
                    logging.critical("Couldn't find user for matching %s" % (d[key].id))
                    continue
                m = Match(key_name=key, id=key, name1=d[key].id, name2=d[key].crush, email=user.email)
                m.put()

        self.response.out.write('Done')


class MatchMailHandler(webapp.RequestHandler):
    def get(self):
        us = User.all()
        for u in us:
            q = db.Query(Match)
            q.filter('name1 =', u.id)

            matches = []
            for match in q:
                matches.append(match.name2)

            if len(matches) > 0:
                # send email
                try:
                    taskqueue.add(url='/mailuser', params=dict(key=u.id, to=u.id, about=', '.join(matches), email=u.email))
                except taskqueue.TransientError:
                    logging.critical("Couldn't add task to mail %s for %s" % (u.id))

                self.response.out.write('%s matched %s<br>' % (u.id, ','.join(matches)))
        self.response.out.write('Done')

class MailUserWorker(webapp.RequestHandler):
    def post(self):
        key  = self.request.get('key')
        to = self.request.get('to')
        about = self.request.get('about')
        email = self.request.get('email')

        try:
            #email = to.replace(' ','.').replace('..','.') + '@dartmouth.edu'

            logging.info('ACTUALLY Mailing %s for %s' % (email, about))

            mail.send_mail(
                sender='Last Chances <no-reply@dartmouthlastchances.appspotmail.com>',
                to=email,
                subject='Last Chances Results',
                body='Your last chances match(es) are: %s.' % (about))

            #Match.get_by_key_name(key).delete()
        except:
            logging.critical('Email failed for %s' % (to))



class TestHandler(webapp.RequestHandler):
    def get(self):
        name = self.request.get('name')
        crush = self.request.get('crush')
        key = name+':'+crush
        c = Crush(key_name=key, id=name, crush=crush)
        mc.set(key, True, namespace='crushes')
        c.put()


class ClearMemcacheHandler(webapp.RequestHandler):
    def get(self):
        if mc.flush_all():
            self.response.out.write('ok')
        else:
            self.response.out.write('error')


class ClearAllHandler(webapp.RequestHandler):
    def get(self):
        try:
            if mc.flush_all():
                self.response.out.write('cleared memcache...<br>')
            else:
                self.response.out.write('error clearing memcache')
                return


            us = User.all()
            for u in us:
                u.delete()
            self.response.out.write('cleared users...<br>')

            cs = Crush.all()
            for c in cs:
                c.delete()
            self.response.out.write('cleared crushes...<br>')

            ms = Match.all()
            for m in ms:
                m.delete()
            self.response.out.write('cleared matches...<br>')

            self.response.out.write('Done.  Clear all sessions in app engine admin to be safe')
        except:
            self.response.out.write('error')

class CrushedOnHandler(webapp.RequestHandler):
    def get(self):
        cs = Crush.all()
        d = {}
        for c in cs:
            if c.crush in d:
                d[c.crush] += 1
            else:
                d[c.crush] = 1

        for key, value in sorted(d.iteritems(), key=lambda (k,v): (v,k), reverse=True):
            self.response.out.write('%s: %s<br>' % (key, value))
        self.response.out.write('Done')


class StatsHandler(webapp.RequestHandler):
    def get(self):
        us = User.all()
        c = 0
        for x in us:
            c +=1

        self.response.out.write(str(c) + ' users<br>')

        cs = Crush.all()
        c = 0
        for x in cs:
            c += 1
        self.response.out.write(str(c) + ' crushes<br>')

        ms = Match.all()
        c = 0
        for x in ms:
            c += 1

        self.response.out.write(str(c) + ' matches<br>')
        

            
def main():
    util.run_wsgi_app(webapp.WSGIApplication([
        (r"/", HomeHandler),
        (r"/login", LoginHandler),
        (r"/logout", LogoutHandler),
        (r"/entry", EntryHandler),
        (r"/match", MatchHandler),
        #(r"/mail", MatchMailHandler),
        #(r"/mailuser", MailUserWorker),
        (r"/email", EmailHandler),
        #(r"/clearmemcache", ClearMemcacheHandler),
        #(r"/clearall", ClearAllHandler),
        (r"/crushedon", CrushedOnHandler),
        (r"/stats", StatsHandler),
        #(r"/addtestcrush", TestHandler),
    ]))


if __name__ == "__main__":
    main()

================
File: app/queue.yaml
================
queue:
- name: hothandler
  rate: 20/m
  bucket_size: 1

================
File: app/settings.py
================
DEBUG = False

# Show user matches
RELEASE_MATCHES = True

# Must match class/dept DND entry
CLASS_YEAR = "'11"

================
File: remote/dnd.py
================
#!/usr/bin/env python
#
# DND lookup script restricted to class year
#

import socket
import urllib
import sys

DND_SERVER = 'dnd.dartmouth.edu'
DND_PORT = 902

class DNDLookup:
    
    def __init__(self, server=DND_SERVER, port=DND_PORT):
        self.server = server
        self.port = port

    def connect(self):
        if hasattr(self, 's'):
            return True

        self.s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.s.connect((self.server, self.port))

        chunk = self.s.recv(512)
        if chunk == '':
            print 'DND: Connect to server failed'
            return False

        return True


    def lookup(self, name, year=''):
        if not self.connect():
            print 'DND: Not connected to server'
            return False

        name = name.decode('string-escape')
        year = year.decode('string-escape')
        if self.s.send("LOOKUP %s %s, name deptclass\r\n" % (name, year)) == 0:
            print 'DND: Lookup failed'
            return False

        resp = ''
        while True:
            chunk = self.s.recv(512)
            resp += chunk
            if chunk == '' or chunk.endswith('200 Ok.\r\n') \
               or chunk.endswith('201 Additional matching records not returned.\r\n') \
               or chunk.endswith('520 No match for that name.\r\n'):
                break

        lines  = resp.splitlines()

        # skip every other because it's a deptclass entry
        lines = [lines[i] for i in range(1, len(lines), 2)]

        return [l[4:] for l in lines if l.startswith('110 ')]

    def close(self):
        self.s.close()


def main():
    d = DNDLookup()
    if len(sys.argv) == 2:
        print '\n'.join(d.lookup(sys.argv[1]))
    else:
        print '\n'.join(d.lookup(sys.argv[1], sys.argv[2]))
    d.close()


if __name__ == '__main__':
    if len(sys.argv) == 2 or len(sys.argv) == 3:
        main()

================
File: remote/lookup.php
================
<?php
$names = explode(',', $_GET['names']);
$year= $_GET['year'];
$ret = array();
foreach ($names as $name) {
    if ($name == "") {
        continue;
    }   
    $name = escapeshellcmd(stripcslashes($name));
    $year = escapeshellcmd(stripcslashes($year));
    if ($name !== "") {
        $results = array();
        // exec("dndlookup -f name \"$name\" -f deptclass \"$year\"", $results);            // if dndlookup is installed
        exec("python dnd.py \"$name\" \"$year\"", $results);                                // if it isn't
        $ret[] = implode("\n", $results);
    }   
}
echo implode('#', $ret);
?>

================
File: .gitignore
================
*.pyc
*.swp
*~

================
File: README.md
================
Dartmouth Last Chances
====================

A great tradition for seniors...?

Written by Ian Webster '11, [Hacker Club] project, for '11 Class Council.

Setup
-----

Everything in `/app` is written for Google App Engine.  The scripts in the `remote/` directory should be hosted off Google App Engine, probably on some machine that can be universally used for DND lookup because it is such a common need.

To perform matching as admin, go to the following URLs:

  - `/match`
  - `/mail`

Alternatively, just run `/match`, toggle the `RELEASE_MATCHES` flag, and tell everyone to go to the site.  Ideally, do both.


Resetting
---------

To reset everything, go to `/clearall` as admin.


TODO
----

  - remove/translate unicode chars in DND lookups
  - better way to add superseniors


  [Hacker Club]: http://hacktown.cs.dartmouth.edu/

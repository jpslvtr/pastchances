This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: **/*
- Files matching these patterns are excluded: node_modules/, dist/, .vercel/, .firebase/, public/, functions/package-lock.json, functions/src/serviceAccountKey.json, src/data/, scripts/.vercel/, public/files/names.txt, functions/lib/index.js.map, functions/lib/matchingEngine.js.map, functions/lib/scheduledAnalytics.js.map, functions/lib/types.js.map, functions/lib/utils.js.map, src/assets/react.svg, *.cache, *.log, *.map, .env*
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)


================================================================
Directory Structure
================================================================
functions/
  lib/
    index.js
    matchingEngine.js
    scheduledAnalytics.js
    types.js
    utils.js
  src/
    index.ts
    matchingEngine.ts
    scheduledAnalytics.ts
    types.ts
    utils.ts
  .eslintrc.js
  .gitignore
  package.json
  tsconfig.dev.json
  tsconfig.json
scripts/
  tools/
    create-favicons.sh
    fix-james-park-timestamps.js
    generate-favicons.js
    matches.js
    specific-stats.js
    stats.js
  deploy.sh
  repomix.sh
src/
  components/
    admin/
      AdminAnalytics.tsx
      AdminUsers.tsx
    dashboard/
      CrushCountSection.tsx
      InstructionsSection.tsx
      MatchesSection.tsx
      SelectedNamesSection.tsx
    shared/
      LoadingSpinner.tsx
      MatchItem.tsx
      SearchInput.tsx
    AdminView.tsx
    Home.tsx
    Login.tsx
    NameSelection.tsx
    UserDashboard.tsx
  config/
    firebase.ts
  contexts/
    AuthContext.tsx
  hooks/
    useAdminData.ts
    useAdminUtils.ts
    useAuthHelpers.ts
    useUserDocumentManager.ts
  styles/
    admin/
      admin-base.css
      admin-layout.css
      admin-responsive.css
    dashboard/
      dashboard-components.css
      dashboard-layout.css
      dashboard-responsive.css
    admin.css
    auth.css
    base.css
    dashboard.css
  types/
    index.ts
    userTypes.ts
  utils/
    adminUtils.ts
    index.ts
  App.css
  App.tsx
  index.css
  main.tsx
  vite-env.d.ts
.firebaserc
.gitignore
eslint.config.js
firebase.json
firestore.indexes.json
firestore.rules
index.html
package.json
repomix.config.json
tsconfig.app.json
tsconfig.json
tsconfig.node.json
vercel.json
vite.config.ts

================================================================
Files
================================================================

================
File: functions/lib/index.js
================
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.removeTakenNamesCollection = exports.cleanupOrphanedCrushes = exports.migrateToSingleNameField = exports.addTimestampsToMatches = exports.fixMatchTimestamps = exports.fixMatchTimestampsToNow = exports.fixCrushCountDiscrepancies = exports.recalculateAllMatches = exports.findMatches = exports.runAnalyticsNow = exports.scheduledAnalytics = void 0;
const functions = __importStar(require("firebase-functions"));
const admin = __importStar(require("firebase-admin"));
const utils_1 = require("./utils");
const matchingEngine_1 = require("./matchingEngine");
var scheduledAnalytics_1 = require("./scheduledAnalytics");
Object.defineProperty(exports, "scheduledAnalytics", { enumerable: true, get: function () { return scheduledAnalytics_1.scheduledAnalytics; } });
Object.defineProperty(exports, "runAnalyticsNow", { enumerable: true, get: function () { return scheduledAnalytics_1.runAnalyticsNow; } });
// Initialize Firebase Admin if not already initialized
if (!admin.apps.length) {
    admin.initializeApp();
}
const db = admin.firestore();
// Enhanced function to find matches and update crush counts
exports.findMatches = functions.firestore
    .document('users/{userId}')
    .onUpdate(async (change, context) => {
    const userId = context.params.userId;
    const beforeData = change.before.data();
    const afterData = change.after.data();
    // Check if crushes were updated OR if name was updated
    const beforeCrushes = (beforeData === null || beforeData === void 0 ? void 0 : beforeData.crushes) || [];
    const afterCrushes = (afterData === null || afterData === void 0 ? void 0 : afterData.crushes) || [];
    const beforeName = (0, utils_1.getUserIdentityName)(beforeData);
    const afterName = (0, utils_1.getUserIdentityName)(afterData);
    // Normalize arrays for comparison
    const normalizedBefore = beforeCrushes.map(crush => crush.trim().toLowerCase()).sort();
    const normalizedAfter = afterCrushes.map(crush => crush.trim().toLowerCase()).sort();
    const crushesChanged = JSON.stringify(normalizedBefore) !== JSON.stringify(normalizedAfter);
    const nameChanged = beforeName !== afterName;
    console.log(`Checking update for user ${userId} (${afterName})`);
    console.log(`Crushes changed: ${crushesChanged}, Name changed: ${nameChanged}`);
    // Process if crushes changed OR if name changed (which affects how others' crushes map to this user)
    if (crushesChanged || nameChanged) {
        console.log(`âœ… Processing update for user ${userId} (${afterName})`);
        // Validate that locked crushes are still present (only for crush changes)
        if (crushesChanged) {
            const lockedCrushes = (beforeData === null || beforeData === void 0 ? void 0 : beforeData.lockedCrushes) || [];
            const missingLockedCrushes = lockedCrushes.filter(locked => !afterCrushes.includes(locked));
            if (missingLockedCrushes.length > 0) {
                console.log(`âŒ User ${userId} tried to remove locked crushes: ${missingLockedCrushes.join(', ')}`);
                // Restore the locked crushes
                const restoredCrushes = [...new Set([...afterCrushes, ...lockedCrushes])];
                const userRef = db.collection('users').doc(userId);
                await userRef.update({
                    crushes: restoredCrushes,
                    updatedAt: admin.firestore.FieldValue.serverTimestamp()
                });
                console.log(`âœ… Restored locked crushes for user ${userId}`);
                return null;
            }
        }
        // Add a small delay to prevent race conditions
        await new Promise(resolve => setTimeout(resolve, 1000));
        await (0, matchingEngine_1.processUpdatedCrushes)();
    }
    else {
        console.log(`âŒ No relevant changes detected for user ${userId} (${afterName}), skipping`);
    }
    return null;
});
// Manual function to trigger complete recalculation
exports.recalculateAllMatches = functions.https.onRequest(async (req, res) => {
    try {
        await (0, matchingEngine_1.processUpdatedCrushes)();
        res.json({
            success: true,
            message: 'Successfully recalculated all matches and crush counts with enhanced name matching'
        });
    }
    catch (error) {
        console.error('Error in recalculateAllMatches:', error);
        res.status(500).json({ error: 'Failed to recalculate matches and crush counts' });
    }
});
// NEW: Manual function to fix crush count discrepancies
exports.fixCrushCountDiscrepancies = functions.https.onRequest(async (req, res) => {
    try {
        console.log('ðŸ”§ Starting manual fix of crush count discrepancies...');
        await (0, matchingEngine_1.fixAllCrushCounts)();
        res.json({
            success: true,
            message: 'Successfully fixed all crush count discrepancies'
        });
    }
    catch (error) {
        console.error('âŒ Error fixing crush count discrepancies:', error);
        res.status(500).json({ error: 'Failed to fix crush count discrepancies' });
    }
});
// NEW: Function to fix all match timestamps to now (one-time)
exports.fixMatchTimestampsToNow = functions.https.onRequest(async (req, res) => {
    try {
        console.log('ðŸ”§ Setting all existing match timestamps to now...');
        await (0, matchingEngine_1.fixAllMatchTimestampsToNow)();
        res.json({
            success: true,
            message: 'Successfully set all existing match timestamps to now (except James Park matches)'
        });
    }
    catch (error) {
        console.error('âŒ Error fixing match timestamps:', error);
        res.status(500).json({ error: 'Failed to fix match timestamps' });
    }
});
// Legacy timestamp function
exports.fixMatchTimestamps = functions.https.onRequest(async (req, res) => {
    try {
        console.log('ðŸ”§ Starting one-time fix for missing match timestamps...');
        await (0, matchingEngine_1.fixAllMatchTimestampsToNow)();
        res.json({
            success: true,
            message: 'Successfully fixed missing match timestamps'
        });
    }
    catch (error) {
        console.error('âŒ Error fixing match timestamps:', error);
        res.status(500).json({ error: 'Failed to fix match timestamps' });
    }
});
// New function to add timestamps to existing matches
exports.addTimestampsToMatches = functions.https.onRequest(async (req, res) => {
    try {
        console.log('ðŸ”„ Adding timestamps to existing matches...');
        // Use current timestamp for all existing matches
        const currentTimestamp = admin.firestore.Timestamp.now();
        let updatedUsers = 0;
        let totalMatchesUpdated = 0;
        await db.runTransaction(async (transaction) => {
            // Get all users
            const usersSnapshot = await transaction.get(db.collection('users'));
            usersSnapshot.forEach(doc => {
                const userData = doc.data();
                const matches = userData.matches || [];
                if (matches.length > 0) {
                    // Check if any matches are missing timestamps
                    let needsUpdate = false;
                    const updatedMatches = matches.map((match) => {
                        if (!match.matchedAt) {
                            needsUpdate = true;
                            totalMatchesUpdated++;
                            return Object.assign(Object.assign({}, match), { matchedAt: currentTimestamp });
                        }
                        return match;
                    });
                    if (needsUpdate) {
                        const userRef = db.collection('users').doc(doc.id);
                        transaction.update(userRef, {
                            matches: updatedMatches,
                            updatedAt: admin.firestore.FieldValue.serverTimestamp()
                        });
                        updatedUsers++;
                        console.log(`âœ… Updated ${updatedMatches.filter((m) => m.matchedAt === currentTimestamp).length} matches for user: ${userData.name || userData.email}`);
                    }
                }
            });
            console.log(`\nðŸŽ‰ Migration completed!`);
            console.log(`ðŸ“Š Updated ${updatedUsers} users`);
            console.log(`ðŸ’• Added timestamps to ${totalMatchesUpdated} existing matches`);
        });
        res.json({
            success: true,
            message: `Successfully added timestamps to ${totalMatchesUpdated} existing matches across ${updatedUsers} users`
        });
    }
    catch (error) {
        console.error('âŒ Error adding timestamps to matches:', error);
        res.status(500).json({ error: 'Failed to add timestamps to matches' });
    }
});
// Migration function to clean up and standardize the database
exports.migrateToSingleNameField = functions.https.onRequest(async (req, res) => {
    try {
        console.log('ðŸ”„ Starting migration to single name field...');
        await db.runTransaction(async (transaction) => {
            // Get all users
            const allUsersSnapshot = await transaction.get(db.collection('users'));
            const allUsers = allUsersSnapshot.docs.map(doc => (Object.assign({ id: doc.id }, doc.data())));
            console.log(`ðŸ“Š Processing ${allUsers.length} users for migration`);
            let migratedUsers = 0;
            let errorUsers = 0;
            for (const user of allUsers) {
                const userRef = db.collection('users').doc(user.id);
                try {
                    // Determine the best name to use
                    let finalName = user.name;
                    if (!finalName || finalName.trim() === '') {
                        // Try verifiedName first, then displayName
                        finalName = user.verifiedName || user.displayName || '';
                    }
                    if (!finalName || finalName.trim() === '') {
                        console.log(`âš ï¸ User ${user.id} (${user.email}) has no name - skipping`);
                        errorUsers++;
                        continue;
                    }
                    // Prepare update data
                    const updateData = {
                        name: finalName,
                        updatedAt: admin.firestore.FieldValue.serverTimestamp()
                    };
                    // Remove legacy fields if they exist
                    if (user.displayName !== undefined) {
                        updateData.displayName = admin.firestore.FieldValue.delete();
                    }
                    if (user.verifiedName !== undefined) {
                        updateData.verifiedName = admin.firestore.FieldValue.delete();
                    }
                    transaction.update(userRef, updateData);
                    migratedUsers++;
                    console.log(`âœ… Migrated user ${user.email}: "${finalName}"`);
                }
                catch (error) {
                    console.error(`âŒ Error migrating user ${user.id}:`, error);
                    errorUsers++;
                }
            }
            console.log(`ðŸŽ‰ Migration completed! Migrated: ${migratedUsers}, Errors: ${errorUsers}`);
            // Now trigger a recalculation to fix any crush references
            setTimeout(async () => {
                await (0, matchingEngine_1.processUpdatedCrushes)();
            }, 2000);
        });
        res.json({
            success: true,
            message: 'Successfully migrated users to single name field'
        });
    }
    catch (error) {
        console.error('âŒ Error in migration:', error);
        res.status(500).json({ error: 'Failed to migrate users' });
    }
});
// Clean up orphaned crushes function
exports.cleanupOrphanedCrushes = functions.https.onRequest(async (req, res) => {
    try {
        console.log('ðŸ”§ Starting cleanup of orphaned crushes...');
        await db.runTransaction(async (transaction) => {
            // Get all users
            const allUsersSnapshot = await transaction.get(db.collection('users'));
            const allUsers = allUsersSnapshot.docs.map(doc => (Object.assign({ id: doc.id }, doc.data())));
            console.log(`ðŸ“Š Processing ${allUsers.length} users for cleanup`);
            // Find all unique crush names and map them to actual users
            const allCrushNames = new Set();
            const crushToUserMap = new Map();
            allUsers.forEach(user => {
                const userCrushes = user.crushes || [];
                userCrushes.forEach(crushName => {
                    allCrushNames.add(crushName);
                });
                // Map user's identity name to the user
                const identityName = (0, utils_1.getUserIdentityName)(user);
                if (identityName) {
                    crushToUserMap.set(identityName, user);
                }
            });
            console.log(`ðŸ” Found ${allCrushNames.size} unique crush names`);
            // Update crushes to use consistent names
            let updatedUsers = 0;
            for (const user of allUsers) {
                const userCrushes = user.crushes || [];
                let needsUpdate = false;
                const updatedCrushes = [];
                const userClass = user.userClass || 'gsb';
                for (const crushName of userCrushes) {
                    const targetUser = (0, utils_1.findUserByName)(crushName, allUsers, userClass);
                    if (targetUser) {
                        const correctName = (0, utils_1.getUserIdentityName)(targetUser);
                        if (correctName && correctName !== crushName) {
                            console.log(`ðŸ”§ Updating crush "${crushName}" -> "${correctName}" for user ${user.email}`);
                            needsUpdate = true;
                        }
                        updatedCrushes.push(correctName || crushName);
                    }
                    else {
                        // Keep orphaned crushes as-is (they might sign up later)
                        updatedCrushes.push(crushName);
                    }
                }
                if (needsUpdate) {
                    const userRef = db.collection('users').doc(user.id);
                    transaction.update(userRef, {
                        crushes: updatedCrushes,
                        updatedAt: admin.firestore.FieldValue.serverTimestamp()
                    });
                    updatedUsers++;
                }
            }
            console.log(`âœ… Updated ${updatedUsers} users with cleaned crush references`);
            // Trigger recalculation
            setTimeout(async () => {
                await (0, matchingEngine_1.processUpdatedCrushes)();
            }, 2000);
        });
        res.json({
            success: true,
            message: 'Successfully cleaned up orphaned crushes'
        });
    }
    catch (error) {
        console.error('âŒ Error in cleanup:', error);
        res.status(500).json({ error: 'Failed to cleanup orphaned crushes' });
    }
});
// Clean up takenNames collection since we're not using it anymore
exports.removeTakenNamesCollection = functions.https.onRequest(async (req, res) => {
    try {
        console.log('ðŸ—‘ï¸ Removing takenNames collection...');
        const takenNamesSnapshot = await db.collection('takenNames').get();
        if (takenNamesSnapshot.empty) {
            res.json({
                success: true,
                message: 'takenNames collection is already empty'
            });
            return;
        }
        const batch = db.batch();
        takenNamesSnapshot.docs.forEach(doc => {
            batch.delete(doc.ref);
        });
        await batch.commit();
        res.json({
            success: true,
            message: `Deleted ${takenNamesSnapshot.size} documents from takenNames collection`
        });
    }
    catch (error) {
        console.error('âŒ Error removing takenNames collection:', error);
        res.status(500).json({ error: 'Failed to remove takenNames collection' });
    }
});
//# sourceMappingURL=index.js.map

================
File: functions/lib/matchingEngine.js
================
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.fixMissingMatchTimestamps = exports.fixAllMatchTimestampsOnce = exports.fixAllCrushCounts = exports.fixAllMatchTimestampsToNow = exports.processUpdatedCrushes = void 0;
const admin = __importStar(require("firebase-admin"));
const utils_1 = require("./utils");
// Initialize Firebase Admin if not already initialized
if (!admin.apps.length) {
    admin.initializeApp();
}
const db = admin.firestore();
// Helper function to determine if a match should have a timestamp
function shouldMatchHaveTimestamp(user1Id, user2Id, user1Name, user2Name) {
    // Check if either user is James Park (by document ID containing jpark22@stanford.edu OR by name)
    const isUser1JamesPark = user1Id.includes('jpark22@stanford.edu') ||
        user1Name === 'James Park' ||
        user1Id.includes('_gsb') && user1Id.includes('jpark22@stanford.edu') ||
        user1Id.includes('_undergrad') && user1Id.includes('jpark22@stanford.edu');
    const isUser2JamesPark = user2Id.includes('jpark22@stanford.edu') ||
        user2Name === 'James Park' ||
        user2Id.includes('_gsb') && user2Id.includes('jpark22@stanford.edu') ||
        user2Id.includes('_undergrad') && user2Id.includes('jpark22@stanford.edu');
    // Skip timestamp for ANY James Park matches (GSB or undergrad)
    if (isUser1JamesPark || isUser2JamesPark) {
        console.log(`ðŸš« Skipping timestamp for James Park match: ${user1Name} â†” ${user2Name}`);
        return false;
    }
    // All other matches should have timestamps
    return true;
}
// Enhanced function to recalculate all matches and crush counts with better name matching
// Now respects class boundaries - GSB students can only match with GSB, undergrads with undergrads
async function processUpdatedCrushes() {
    console.log('ðŸ”„ Starting enhanced recalculation of all matches and crush counts with class separation...');
    try {
        await db.runTransaction(async (transaction) => {
            // Get all users
            const allUsersSnapshot = await transaction.get(db.collection('users'));
            const allUsers = allUsersSnapshot.docs.map(doc => (Object.assign({ id: doc.id }, doc.data())));
            console.log(`ðŸ“Š Processing ${allUsers.length} users`);
            // Separate users by class
            const gsbUsers = allUsers.filter(user => user.userClass === 'gsb' || !user.userClass); // Default to GSB for backwards compatibility
            const undergradUsers = allUsers.filter(user => user.userClass === 'undergrad');
            console.log(`ðŸ“Š GSB users: ${gsbUsers.length}, Undergrad users: ${undergradUsers.length}`);
            // Enhanced crush count calculation with better name matching and class separation
            const crushCounts = new Map();
            const crushersMap = new Map(); // Track who is crushing on whom
            // Process GSB users
            for (const user of gsbUsers) {
                const userCrushes = user.crushes || [];
                for (const crushName of userCrushes) {
                    // Find the actual user that matches this crush name within GSB class
                    const targetUser = (0, utils_1.findUserByName)(crushName, gsbUsers, 'gsb');
                    if (targetUser) {
                        // Use the user's identity name
                        const actualName = (0, utils_1.getUserIdentityName)(targetUser);
                        if (actualName) {
                            const key = `gsb:${actualName}`;
                            crushCounts.set(key, (crushCounts.get(key) || 0) + 1);
                            // Track the crusher
                            if (!crushersMap.has(key)) {
                                crushersMap.set(key, []);
                            }
                            crushersMap.get(key).push((0, utils_1.getUserIdentityName)(user) || user.email);
                        }
                    }
                    else {
                        // If no user found, still count it but use the crush name directly
                        console.log(`âš ï¸ No GSB user found for crush name: "${crushName}" - counting anyway`);
                        const key = `gsb:${crushName}`;
                        crushCounts.set(key, (crushCounts.get(key) || 0) + 1);
                        // Track the crusher for orphaned crushes too
                        if (!crushersMap.has(key)) {
                            crushersMap.set(key, []);
                        }
                        crushersMap.get(key).push((0, utils_1.getUserIdentityName)(user) || user.email);
                    }
                }
            }
            // Process Undergrad users
            for (const user of undergradUsers) {
                const userCrushes = user.crushes || [];
                for (const crushName of userCrushes) {
                    // Find the actual user that matches this crush name within undergrad class
                    const targetUser = (0, utils_1.findUserByName)(crushName, undergradUsers, 'undergrad');
                    if (targetUser) {
                        // Use the user's identity name
                        const actualName = (0, utils_1.getUserIdentityName)(targetUser);
                        if (actualName) {
                            const key = `undergrad:${actualName}`;
                            crushCounts.set(key, (crushCounts.get(key) || 0) + 1);
                            // Track the crusher
                            if (!crushersMap.has(key)) {
                                crushersMap.set(key, []);
                            }
                            crushersMap.get(key).push((0, utils_1.getUserIdentityName)(user) || user.email);
                        }
                    }
                    else {
                        // If no user found, still count it but use the crush name directly
                        console.log(`âš ï¸ No undergrad user found for crush name: "${crushName}" - counting anyway`);
                        const key = `undergrad:${crushName}`;
                        crushCounts.set(key, (crushCounts.get(key) || 0) + 1);
                        // Track the crusher for orphaned crushes too
                        if (!crushersMap.has(key)) {
                            crushersMap.set(key, []);
                        }
                        crushersMap.get(key).push((0, utils_1.getUserIdentityName)(user) || user.email);
                    }
                }
            }
            console.log('ðŸ’• Enhanced crush counts calculated:', Object.fromEntries(crushCounts));
            // Calculate matches and locked crushes with enhanced matching and class separation
            const allMatches = new Map();
            const allLockedCrushes = new Map();
            // Process both classes together but only allow matches within same class
            for (const user of allUsers) {
                const userMatches = [];
                const userLockedCrushes = [];
                const userCrushes = user.crushes || [];
                const userIdentityName = (0, utils_1.getUserIdentityName)(user);
                const userClass = user.userClass || 'gsb'; // Default to GSB for backwards compatibility
                if (!userIdentityName || !userIdentityName.trim()) {
                    console.log(`â­ï¸ Skipping user ${user.id} - no identity name`);
                    allMatches.set(user.id, userMatches);
                    allLockedCrushes.set(user.id, userLockedCrushes);
                    continue;
                }
                // Get users from the same class only
                const sameClassUsers = allUsers.filter(u => (u.userClass || 'gsb') === userClass);
                // Get existing matches to preserve timestamps (CRITICAL: preserve exact timestamp objects)
                const existingMatches = user.matches || [];
                const existingMatchMap = new Map();
                existingMatches.forEach(match => {
                    if (match.name) {
                        existingMatchMap.set(match.name, match);
                    }
                });
                // Find mutual matches with enhanced name matching within same class
                for (const crushName of userCrushes) {
                    const crushedUser = (0, utils_1.findUserByName)(crushName, sameClassUsers, userClass);
                    if (!crushedUser) {
                        console.log(`âš ï¸ No ${userClass} user found for crush name: "${crushName}"`);
                        continue;
                    }
                    const crushedUserCrushes = crushedUser.crushes || [];
                    // Check if it's a mutual match using enhanced matching within same class
                    const hasMutualCrush = crushedUserCrushes.some(crush => {
                        const matchedUser = (0, utils_1.findUserByName)(crush, sameClassUsers, userClass);
                        return matchedUser && matchedUser.id === user.id;
                    });
                    if (hasMutualCrush) {
                        const crushedUserIdentityName = (0, utils_1.getUserIdentityName)(crushedUser);
                        // Check if this is an existing match to preserve timestamp
                        const existingMatch = existingMatchMap.get(crushedUserIdentityName);
                        // Determine if this match should have a timestamp
                        const shouldHaveTimestamp = shouldMatchHaveTimestamp(user.id, crushedUser.id, userIdentityName, crushedUserIdentityName);
                        let matchInfo;
                        if (shouldHaveTimestamp) {
                            if (existingMatch && existingMatch.matchedAt) {
                                // PRESERVE the exact existing timestamp object - don't convert it
                                matchInfo = {
                                    name: crushedUserIdentityName,
                                    email: crushedUser.email,
                                    matchedAt: existingMatch.matchedAt
                                };
                                console.log(`ðŸ”’ Preserving existing timestamp for ${userIdentityName} â†” ${crushedUserIdentityName}`);
                            }
                            else {
                                // NEW MATCH - Create timestamp at the exact moment this match is discovered
                                matchInfo = {
                                    name: crushedUserIdentityName,
                                    email: crushedUser.email,
                                    matchedAt: admin.firestore.Timestamp.now() // Real-time timestamp for new matches
                                };
                                console.log(`ðŸ†• Creating new timestamp for ${userIdentityName} â†” ${crushedUserIdentityName}`);
                            }
                        }
                        else {
                            // No timestamp for James Park matches
                            matchInfo = {
                                name: crushedUserIdentityName,
                                email: crushedUser.email
                                // No matchedAt field
                            };
                            console.log(`ðŸš« No timestamp for James Park match: ${userIdentityName} â†” ${crushedUserIdentityName}`);
                        }
                        userMatches.push(matchInfo);
                        // Lock this crush ONLY if there's a mutual match
                        if (!userLockedCrushes.includes(crushName)) {
                            userLockedCrushes.push(crushName);
                        }
                        const isNewMatch = !existingMatchMap.has(crushedUserIdentityName);
                        const timestampStatus = shouldHaveTimestamp ? (isNewMatch ? 'NEW_TIMESTAMP' : 'PRESERVED_EXISTING') : 'NO_TIMESTAMP';
                        console.log(`ðŸ’• ${userClass.toUpperCase()} Match ${isNewMatch ? 'NEW' : 'EXISTING'} (${timestampStatus}): ${userIdentityName} â†” ${crushedUserIdentityName}`);
                    }
                }
                allMatches.set(user.id, userMatches);
                allLockedCrushes.set(user.id, userLockedCrushes);
            }
            // Update all users with their matches, crush counts, and locked crushes
            for (const user of allUsers) {
                const userRef = db.collection('users').doc(user.id);
                const userIdentityName = (0, utils_1.getUserIdentityName)(user);
                const userClass = user.userClass || 'gsb'; // Default to GSB for backwards compatibility
                // For crush count, we need to check the user's identity name with class prefix
                let userCrushCount = 0;
                if (userIdentityName) {
                    const key = `${userClass}:${userIdentityName}`;
                    userCrushCount = crushCounts.get(key) || 0;
                    // Log discrepancies for debugging
                    const currentCrushCount = user.crushCount || 0;
                    if (currentCrushCount !== userCrushCount) {
                        const crushers = crushersMap.get(key) || [];
                        console.log(`ðŸ”§ Fixing crush count for ${userIdentityName}: ${currentCrushCount} -> ${userCrushCount} (crushers: ${crushers.join(', ')})`);
                    }
                }
                const updateData = {
                    matches: allMatches.get(user.id) || [],
                    lockedCrushes: allLockedCrushes.get(user.id) || [],
                    crushCount: userCrushCount,
                    userClass: userClass,
                    updatedAt: admin.firestore.FieldValue.serverTimestamp()
                };
                transaction.update(userRef, updateData);
            }
            console.log(`âœ… Updated all ${allUsers.length} users with enhanced matches and crush counts (class-separated)`);
        });
    }
    catch (error) {
        console.error('âŒ Error in enhanced processUpdatedCrushes:', error);
        throw error;
    }
}
exports.processUpdatedCrushes = processUpdatedCrushes;
// One-time function to set current timestamp for all existing matches (except James Park)
async function fixAllMatchTimestampsToNow() {
    console.log('ðŸ”§ Setting all existing match timestamps to now (except James Park matches)...');
    try {
        await db.runTransaction(async (transaction) => {
            // Get all users
            const allUsersSnapshot = await transaction.get(db.collection('users'));
            const currentTimestamp = admin.firestore.Timestamp.now();
            let updatedUsers = 0;
            let fixedMatches = 0;
            allUsersSnapshot.forEach(doc => {
                const userData = doc.data();
                const matches = userData.matches || [];
                const userId = doc.id;
                const userName = userData.name || userData.verifiedName || userData.displayName || userData.email;
                if (matches.length > 0) {
                    let needsUpdate = false;
                    const updatedMatches = matches.map((match) => {
                        // Check both the document owner AND the match partner for James Park
                        const shouldHaveTimestamp = shouldMatchHaveTimestamp(userId, '', userName, match.name || '');
                        if (shouldHaveTimestamp) {
                            // Set timestamp to now for all non-James Park matches
                            needsUpdate = true;
                            fixedMatches++;
                            console.log(`ðŸ”§ Setting timestamp to now for match: ${match.name} â†” ${userName}`);
                            return {
                                name: match.name || 'Unknown',
                                email: match.email || 'unknown@stanford.edu',
                                matchedAt: currentTimestamp
                            };
                        }
                        else {
                            // Remove timestamp for James Park matches
                            if (match.matchedAt) {
                                needsUpdate = true;
                                console.log(`ðŸ”§ Removing timestamp for James Park match: ${match.name} â†” ${userName}`);
                            }
                            return {
                                name: match.name || 'Unknown',
                                email: match.email || 'unknown@stanford.edu'
                                // No matchedAt field
                            };
                        }
                    });
                    if (needsUpdate) {
                        const userRef = db.collection('users').doc(userId);
                        transaction.update(userRef, {
                            matches: updatedMatches,
                            updatedAt: admin.firestore.FieldValue.serverTimestamp()
                        });
                        updatedUsers++;
                    }
                }
            });
            console.log(`âœ… Fixed timestamps for ${fixedMatches} matches across ${updatedUsers} users`);
        });
    }
    catch (error) {
        console.error('âŒ Error fixing all match timestamps:', error);
        throw error;
    }
}
exports.fixAllMatchTimestampsToNow = fixAllMatchTimestampsToNow;
// New function to manually fix all crush count discrepancies
async function fixAllCrushCounts() {
    console.log('ðŸ”§ Starting manual fix of all crush count discrepancies...');
    try {
        await processUpdatedCrushes();
        console.log('âœ… All crush counts have been synchronized');
    }
    catch (error) {
        console.error('âŒ Error fixing crush counts:', error);
        throw error;
    }
}
exports.fixAllCrushCounts = fixAllCrushCounts;
// Legacy function - keeping for backward compatibility
async function fixAllMatchTimestampsOnce() {
    await fixAllMatchTimestampsToNow();
}
exports.fixAllMatchTimestampsOnce = fixAllMatchTimestampsOnce;
// Legacy function - keeping for backward compatibility
async function fixMissingMatchTimestamps() {
    await fixAllMatchTimestampsToNow();
}
exports.fixMissingMatchTimestamps = fixMissingMatchTimestamps;
//# sourceMappingURL=matchingEngine.js.map

================
File: functions/lib/scheduledAnalytics.js
================
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.runAnalyticsNow = exports.scheduledAnalytics = void 0;
const functions = __importStar(require("firebase-functions"));
const admin = __importStar(require("firebase-admin"));
exports.scheduledAnalytics = functions.pubsub
    .schedule('every 6 hours')
    // .schedule('every 1 minutes')
    .timeZone('America/Los_Angeles')
    .onRun(async (context) => {
    console.log('ðŸ” Running scheduled analytics...');
    try {
        const db = admin.firestore();
        // Get all data
        const usersSnapshot = await db.collection('users').get();
        const takenNamesSnapshot = await db.collection('takenNames').get();
        // Generate analytics data
        const analyticsData = await generateAnalyticsData(usersSnapshot, takenNamesSnapshot);
        // Store in analytics collection
        const analyticsRef = db.collection('analytics').doc();
        await analyticsRef.set(Object.assign(Object.assign({}, analyticsData), { createdAt: admin.firestore.FieldValue.serverTimestamp() }));
        console.log('âœ… Analytics data saved to Firestore');
        return { success: true, documentId: analyticsRef.id };
    }
    catch (error) {
        console.error('âŒ Error in scheduled analytics:', error);
        throw error;
    }
});
async function generateAnalyticsData(usersSnapshot, takenNamesSnapshot) {
    // 1. Basic stats
    const totalUsers = usersSnapshot.size;
    const totalTakenNames = takenNamesSnapshot.size;
    // 2. Process users data
    const allUsers = [];
    const seenPairs = new Set();
    let totalCrushesSent = 0;
    let activeUsersCount = 0;
    // Calculate 24 hours ago timestamp
    const twentyFourHoursAgo = new Date(Date.now() - (24 * 60 * 60 * 1000));
    usersSnapshot.forEach((doc) => {
        const userData = doc.data();
        const userName = userData.verifiedName || userData.displayName || userData.email || '(Unnamed User)';
        const userInfo = {
            name: userName,
            crushCount: userData.crushCount || 0,
            matches: userData.matches || [],
            crushes: userData.crushes || []
        };
        allUsers.push(userInfo);
        // Count crushes sent (actual crushes array length, not crushCount which is crushes received)
        const userCrushes = userData.crushes || [];
        totalCrushesSent += userCrushes.length;
        // Check if user was active in last 24 hours
        if (userData.lastLogin) {
            let lastLoginDate;
            // Handle both Firestore Timestamp and regular Date
            if (userData.lastLogin.toDate) {
                lastLoginDate = userData.lastLogin.toDate();
            }
            else if (userData.lastLogin.seconds) {
                lastLoginDate = new Date(userData.lastLogin.seconds * 1000);
            }
            else {
                lastLoginDate = new Date(userData.lastLogin);
            }
            if (lastLoginDate > twentyFourHoursAgo) {
                activeUsersCount++;
            }
        }
        // Count unique matches
        const matches = userData.matches || [];
        if (Array.isArray(matches) && matches.length > 0) {
            matches.forEach((match) => {
                const matchName = match.name || match;
                const pair = [userName, matchName].sort().join(' - ');
                seenPairs.add(pair);
            });
        }
    });
    // 3. Calculate statistics
    const totalMatches = seenPairs.size;
    const matchedPairs = Array.from(seenPairs).sort();
    const peopleWithCrushes = allUsers.filter(user => user.crushCount > 0).length;
    const avgCrushes = totalUsers > 0 ? totalCrushesSent / totalUsers : 0;
    // Calculate active user percentage
    const activeUsersLast24h = totalUsers > 0 ? Number((activeUsersCount / totalUsers * 100).toFixed(2)) : 0;
    return {
        // Basic stats
        totalUsers,
        totalTakenNames,
        // Match stats
        totalMatches,
        matchedPairs,
        // Crush stats
        totalCrushes: totalCrushesSent,
        peopleWithCrushes,
        avgCrushes: Number(avgCrushes.toFixed(2)),
        // Activity stats
        activeUsersLast24h // Now a percentage (0-100)
    };
}
// Manual trigger function for testing
exports.runAnalyticsNow = functions.https.onRequest(async (req, res) => {
    try {
        const db = admin.firestore();
        const usersSnapshot = await db.collection('users').get();
        const takenNamesSnapshot = await db.collection('takenNames').get();
        const analyticsData = await generateAnalyticsData(usersSnapshot, takenNamesSnapshot);
        const analyticsRef = db.collection('analytics').doc();
        await analyticsRef.set(Object.assign(Object.assign({}, analyticsData), { createdAt: admin.firestore.FieldValue.serverTimestamp(), manual: true }));
        res.json({
            success: true,
            documentId: analyticsRef.id,
            data: analyticsData
        });
    }
    catch (error) {
        console.error('Error running manual analytics:', error);
        res.status(500).json({ error: 'Failed to generate analytics' });
    }
});
//# sourceMappingURL=scheduledAnalytics.js.map

================
File: functions/lib/types.js
================
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=types.js.map

================
File: functions/lib/utils.js
================
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getUserIdentityName = exports.findUserByName = exports.normalizeName = void 0;
// Helper function to normalize names for case-insensitive comparison
function normalizeName(name) {
    if (!name || typeof name !== 'string')
        return '';
    return name
        .normalize('NFD') // Decompose accented characters
        .replace(/[\u0300-\u036f]/g, '') // Remove accent marks
        .toLowerCase()
        .trim()
        .replace(/[^\w\s]/g, ' ') // Replace non-alphanumeric with spaces
        .replace(/\s+/g, ' ') // Normalize spaces
        .trim();
}
exports.normalizeName = normalizeName;
// Enhanced function to find the best matching user for a crush name
// Only matches users within the same class
function findUserByName(crushName, allUsers, userClass) {
    if (!crushName || !crushName.trim())
        return null;
    const normalizedCrush = normalizeName(crushName);
    // Filter users by class if specified
    const filteredUsers = userClass
        ? allUsers.filter(user => (user.userClass || 'gsb') === userClass)
        : allUsers;
    // First try exact match on name field
    let match = filteredUsers.find(user => user.name &&
        normalizeName(user.name) === normalizedCrush);
    if (match)
        return match;
    // Try exact match on legacy verifiedName field (for migration)
    match = filteredUsers.find(user => user.verifiedName &&
        normalizeName(user.verifiedName) === normalizedCrush);
    if (match)
        return match;
    // Try exact match on legacy displayName field (for migration)
    match = filteredUsers.find(user => user.displayName &&
        normalizeName(user.displayName) === normalizedCrush);
    if (match)
        return match;
    // Try partial match (first and last name only) for cases with middle names
    const crushParts = normalizedCrush.split(' ');
    if (crushParts.length >= 2) {
        const crushFirstLast = `${crushParts[0]} ${crushParts[crushParts.length - 1]}`;
        // Try partial match with name field
        match = filteredUsers.find(user => {
            const userIdentityName = user.name || user.verifiedName || user.displayName;
            if (userIdentityName) {
                const nameParts = normalizeName(userIdentityName).split(' ');
                if (nameParts.length >= 2) {
                    const nameFirstLast = `${nameParts[0]} ${nameParts[nameParts.length - 1]}`;
                    return nameFirstLast === crushFirstLast;
                }
            }
            return false;
        });
    }
    return match || null;
}
exports.findUserByName = findUserByName;
// Helper function to get user's identity name (with migration support)
function getUserIdentityName(user) {
    return user.name || user.verifiedName || user.displayName || '';
}
exports.getUserIdentityName = getUserIdentityName;
//# sourceMappingURL=utils.js.map

================
File: functions/.eslintrc.js
================
module.exports = {
  root: true,
  env: {
    es6: true,
    node: true,
  },
  extends: [
    "eslint:recommended",
    "plugin:import/errors",
    "plugin:import/warnings",
    "plugin:import/typescript",
    "google",
    "plugin:@typescript-eslint/recommended",
  ],
  parser: "@typescript-eslint/parser",
  parserOptions: {
    project: ["tsconfig.json", "tsconfig.dev.json"],
    sourceType: "module",
  },
  ignorePatterns: [
    "/lib/**/*", // Ignore built files.
    "/generated/**/*", // Ignore generated files.
  ],
  plugins: [
    "@typescript-eslint",
    "import",
  ],
  rules: {
    "quotes": ["error", "double"],
    "import/no-unresolved": 0,
    "indent": ["error", 2],
  },
};

================
File: functions/.gitignore
================
# Compiled JavaScript files
lib/**/*.js
lib/**/*.js.map

# TypeScript v1 declaration files
typings/

# Node.js dependency directory
node_modules/
*.local

================
File: functions/tsconfig.dev.json
================
{
  "include": [
    ".eslintrc.js"
  ]
}

================
File: functions/tsconfig.json
================
{
  "compilerOptions": {
    "module": "commonjs",
    "noImplicitReturns": true,
    "noUnusedLocals": false,
    "outDir": "lib",
    "sourceMap": true,
    "strict": true,
    "target": "es2017",
    "skipLibCheck": true,
    "moduleResolution": "node",
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true
  },
  "compileOnSave": true,
  "include": [
    "src"
  ],
  "exclude": [
    "node_modules",
    "lib"
  ]
}

================
File: src/index.css
================
:root {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  line-height: 1.5;
  font-weight: 400;
  color-scheme: light;
  background-color: #ffffff;
  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

body {
  margin: 0;
  min-width: 320px;
  min-height: 100vh;
}

button {
  border-radius: 8px;
  border: 1px solid transparent;
  padding: 0.6em 1.2em;
  font-size: 1em;
  font-weight: 500;
  font-family: inherit;
  cursor: pointer;
  transition: border-color 0.25s;
}

================
File: src/main.tsx
================
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App.tsx'

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>,
)

================
File: src/vite-env.d.ts
================
/// <reference types="vite/client" />

================
File: eslint.config.js
================
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'

export default tseslint.config(
  { ignores: ['dist'] },
  {
    extends: [js.configs.recommended, ...tseslint.configs.recommended],
    files: ['**/*.{ts,tsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
)

================
File: firebase.json
================
{
    "functions": [
        {
            "source": "functions",
            "codebase": "default",
            "ignore": [
                "node_modules",
                ".git",
                "firebase-debug.log",
                "firebase-debug.*.log"
            ],
            "predeploy": [
                "npm --prefix \"$RESOURCE_DIR\" run build"
            ]
        }
    ],
    "firestore": {
        "rules": "firestore.rules",
        "indexes": "firestore.indexes.json"
    },
    "hosting": {
        "public": "dist",
        "ignore": [
            "firebase.json",
            "**/.*",
            "**/node_modules/**"
        ],
        "headers": [
            {
                "source": "/stanford.png",
                "headers": [
                    {
                        "key": "Content-Type",
                        "value": "image/png"
                    },
                    {
                        "key": "Access-Control-Allow-Origin",
                        "value": "*"
                    },
                    {
                        "key": "Cache-Control",
                        "value": "public, max-age=3600"
                    }
                ]
            },
            {
                "source": "/stanford.svg",
                "headers": [
                    {
                        "key": "Content-Type",
                        "value": "image/svg+xml"
                    },
                    {
                        "key": "Access-Control-Allow-Origin",
                        "value": "*"
                    },
                    {
                        "key": "Cache-Control",
                        "value": "public, max-age=3600"
                    }
                ]
            },
            {
                "source": "/share.png",
                "headers": [
                    {
                        "key": "Content-Type",
                        "value": "image/png"
                    },
                    {
                        "key": "Access-Control-Allow-Origin",
                        "value": "*"
                    },
                    {
                        "key": "Cache-Control",
                        "value": "public, max-age=3600"
                    }
                ]
            },
            {
                "source": "**/*.png",
                "headers": [
                    {
                        "key": "Content-Type",
                        "value": "image/png"
                    },
                    {
                        "key": "Access-Control-Allow-Origin",
                        "value": "*"
                    }
                ]
            },
            {
                "source": "**/*.svg",
                "headers": [
                    {
                        "key": "Content-Type",
                        "value": "image/svg+xml"
                    },
                    {
                        "key": "Access-Control-Allow-Origin",
                        "value": "*"
                    }
                ]
            }
        ],
        "redirects": [
            {
                "source": "/login",
                "destination": "/",
                "type": 301
            }
        ],
        "cleanUrls": true,
        "trailingSlash": false
    }
}

================
File: repomix.config.json
================
{
    "output": {
        "filePath": "repomix-output.txt",
        "style": "plain"
    },
    "include": [
        "**/*"
    ],
    "ignore": {
        "useGitignore": false,
        "customPatterns": [
            "node_modules/",
            "dist/",
            ".vercel/",
            ".firebase/",
            "public/",
            "functions/package-lock.json",
            "functions/src/serviceAccountKey.json",
            "src/data/",
            "scripts/.vercel/",
            "public/files/names.txt",
            "functions/lib/index.js.map",
            "functions/lib/matchingEngine.js.map",
            "functions/lib/scheduledAnalytics.js.map",
            "functions/lib/types.js.map",
            "functions/lib/utils.js.map",
            "src/assets/react.svg",
            "*.cache",
            "*.log",
            "*.map",
            ".env*"
        ]
    }
}

================
File: tsconfig.app.json
================
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"]
}

================
File: tsconfig.json
================
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}

================
File: tsconfig.node.json
================
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2022",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}

================
File: scripts/tools/create-favicons.sh
================
#!/bin/bash

echo "ðŸŽ¨ Creating properly sized favicons from 894x1348 Stanford logo..."

cd ../public

# Check if ImageMagick is installed
if ! command -v convert &> /dev/null; then
    echo "âŒ ImageMagick not found."
    echo "ðŸ”§ Install with: brew install imagemagick (on macOS)"
    echo "ðŸŒ Or use online tool: https://realfavicongenerator.net/"
    exit 1
fi

echo "ðŸ“ Original Stanford logo: 894x1348 pixels"

# Create a square version with white padding (1348x1348 to fit the height)
echo "ðŸ”² Creating square version with white padding..."
convert stanford.png -background white -gravity center -extent 1348x1348 stanford-square.png

# Generate different favicon sizes from the square version
echo "ðŸ“ Generating favicon sizes..."

convert stanford-square.png -resize 16x16 favicon-16x16.png
convert stanford-square.png -resize 32x32 favicon-32x32.png  
convert stanford-square.png -resize 48x48 favicon-48x48.png
convert stanford-square.png -resize 180x180 apple-touch-icon.png
convert stanford-square.png -resize 192x192 android-chrome-192x192.png
convert stanford-square.png -resize 512x512 android-chrome-512x512.png

# Create ICO file (supports multiple sizes)
convert stanford-square.png \( +clone -resize 16x16 \) \( +clone -resize 32x32 \) \( +clone -resize 48x48 \) -delete 0 favicon.ico

echo "âœ… Created favicon files:"
ls -la favicon-*.png apple-touch-icon.png android-chrome-*.png favicon.ico stanford-square.png

echo ""
echo "ðŸ”§ Generated files:"
echo "â€¢ favicon-16x16.png - Small browser tab"
echo "â€¢ favicon-32x32.png - Standard browser tab" 
echo "â€¢ favicon-48x48.png - Large browser tab"
echo "â€¢ apple-touch-icon.png - iOS home screen"
echo "â€¢ android-chrome-192x192.png - Android chrome"
echo "â€¢ android-chrome-512x512.png - High-res displays"
echo "â€¢ favicon.ico - Legacy favicon"
echo "â€¢ stanford-square.png - Square source (for reference)"

================
File: scripts/tools/fix-james-park-timestamps.js
================
import admin from 'firebase-admin';
import { readFileSync } from 'fs';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';

// Get current directory for ES modules
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Load service account key
const serviceAccount = JSON.parse(
    readFileSync(join(__dirname, '../../functions/src/serviceAccountKey.json'), 'utf8')
);

admin.initializeApp({
    credential: admin.credential.cert(serviceAccount),
    projectId: 'stanford-lastchances',
});

const db = admin.firestore();

// Helper function to determine if a match should have a timestamp
function shouldMatchHaveTimestamp(user1Id, user2Id, user1Name, user2Name) {
    // Check if either user is James Park (by document ID containing jpark22@stanford.edu OR by name)
    const isUser1JamesPark = user1Id.includes('jpark22@stanford.edu') ||
        user1Name === 'James Park' ||
        (user1Id.includes('_gsb') && user1Id.includes('jpark22@stanford.edu')) ||
        (user1Id.includes('_undergrad') && user1Id.includes('jpark22@stanford.edu'));

    const isUser2JamesPark = user2Id.includes('jpark22@stanford.edu') ||
        user2Name === 'James Park' ||
        (user2Id.includes('_gsb') && user2Id.includes('jpark22@stanford.edu')) ||
        (user2Id.includes('_undergrad') && user2Id.includes('jpark22@stanford.edu'));

    // Skip timestamp for ANY James Park matches (GSB or undergrad)
    if (isUser1JamesPark || isUser2JamesPark) {
        console.log(`ðŸš« Skipping timestamp for James Park match: ${user1Name} â†” ${user2Name}`);
        return false;
    }

    // All other matches should have timestamps
    return true;
}

async function fixJamesParkTimestamps() {
    try {
        console.log('ðŸ”§ FIXING JAMES PARK TIMESTAMP LOGIC...');

        const currentTimestamp = admin.firestore.Timestamp.now();
        let totalUpdatedUsers = 0;
        let totalFixedMatches = 0;
        let jamesParkMatchesFixed = 0;

        await db.runTransaction(async (transaction) => {
            // Get all users
            const usersSnapshot = await transaction.get(db.collection('users'));

            usersSnapshot.forEach(doc => {
                const userData = doc.data();
                const matches = userData.matches || [];
                const userId = doc.id;
                const userName = userData.name || userData.verifiedName || userData.displayName || userData.email;

                if (matches.length > 0) {
                    let needsUpdate = false;
                    const updatedMatches = matches.map(match => {
                        const shouldHaveTimestamp = shouldMatchHaveTimestamp(userId, '', userName, match.name || '');

                        if (shouldHaveTimestamp) {
                            // Non-James Park match should have timestamp
                            if (!match.matchedAt) {
                                needsUpdate = true;
                                totalFixedMatches++;
                                console.log(`ðŸ”§ Adding timestamp to match: ${match.name} â†” ${userName}`);
                                return {
                                    name: match.name || 'Unknown',
                                    email: match.email || 'unknown@stanford.edu',
                                    matchedAt: currentTimestamp
                                };
                            } else {
                                // Already has timestamp, keep it
                                return match;
                            }
                        } else {
                            // James Park match should NOT have timestamp
                            if (match.matchedAt) {
                                needsUpdate = true;
                                jamesParkMatchesFixed++;
                                console.log(`ðŸ”§ Removing timestamp from James Park match: ${match.name} â†” ${userName}`);
                            }
                            return {
                                name: match.name || 'Unknown',
                                email: match.email || 'unknown@stanford.edu'
                                // No matchedAt field
                            };
                        }
                    });

                    if (needsUpdate) {
                        const userRef = db.collection('users').doc(userId);
                        transaction.update(userRef, {
                            matches: updatedMatches,
                            updatedAt: admin.firestore.FieldValue.serverTimestamp()
                        });
                        totalUpdatedUsers++;
                    }
                }
            });

            console.log(`âœ… Will update ${totalUpdatedUsers} users`);
            console.log(`âœ… Will fix ${totalFixedMatches} regular matches (add timestamps)`);
            console.log(`âœ… Will fix ${jamesParkMatchesFixed} James Park matches (remove timestamps)`);
        });

        console.log(`ðŸŽ‰ SUCCESS: Fixed James Park timestamp logic`);
        console.log(`ðŸ“Š Updated ${totalUpdatedUsers} users`);
        console.log(`ðŸ“Š Fixed ${totalFixedMatches} regular matches`);
        console.log(`ðŸ“Š Fixed ${jamesParkMatchesFixed} James Park matches`);

    } catch (error) {
        console.error('âŒ Error fixing James Park timestamps:', error);
    } finally {
        process.exit(0);
    }
}

fixJamesParkTimestamps();

================
File: scripts/tools/generate-favicons.js
================
// This script will help you understand what sizes you need
console.log('ðŸ“ Favicon Size Requirements:');
console.log('');
console.log('Standard favicon sizes:');
console.log('â€¢ 16x16 - Browser tab (smallest)');
console.log('â€¢ 32x32 - Browser tab (standard)');
console.log('â€¢ 48x48 - Browser tab (large)');
console.log('â€¢ 180x180 - Apple touch icon');
console.log('â€¢ 192x192 - Android chrome');
console.log('â€¢ 512x512 - High resolution displays');
console.log('');
console.log('ðŸ’¡ For best results:');
console.log('1. Create a square version of your Stanford logo');
console.log('2. Or add padding around the logo to make it square');
console.log('3. Generate multiple sizes from the square version');
console.log('');
console.log('ðŸ”§ Tools you can use:');
console.log('â€¢ Online: https://realfavicongenerator.net/');
console.log('â€¢ Online: https://favicon.io/');
console.log('â€¢ Local: ImageMagick or Photoshop');

================
File: scripts/tools/specific-stats.js
================
import admin from 'firebase-admin';
import { readFileSync } from 'fs';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';

// Get current directory for ES modules
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Load service account key
const serviceAccount = JSON.parse(
    readFileSync(join(__dirname, '../../functions/src/serviceAccountKey.json'), 'utf8')
);

admin.initializeApp({
    credential: admin.credential.cert(serviceAccount),
    projectId: 'stanford-lastchances',
});

const db = admin.firestore();

async function analyzeInactiveReceivers() {
    try {
        console.log('='.repeat(80));
        console.log('USERS WITH CRUSHES WHO HAVEN\'T SUBMITTED CRUSHES');
        console.log('='.repeat(80));

        // Get all users
        const usersSnapshot = await db.collection('users').get();

        // Build user map and track crushers
        const allUsers = new Map();
        const crushersMap = new Map(); // Maps target name to array of crushers

        usersSnapshot.forEach(doc => {
            const userData = doc.data();
            const userName = userData.verifiedName || userData.displayName || userData.email || '(Unnamed User)';

            allUsers.set(userName, {
                uid: doc.id,
                email: userData.email,
                verifiedName: userData.verifiedName,
                displayName: userData.displayName,
                crushes: userData.crushes || [],
                crushCount: userData.crushCount || 0,
                hasVerifiedName: !!(userData.verifiedName && userData.verifiedName.trim() !== ''),
                hasSubmittedCrushes: !!(userData.crushes && userData.crushes.length > 0)
            });

            // Track who is crushing on whom
            const userCrushes = userData.crushes || [];
            userCrushes.forEach(crushName => {
                if (!crushersMap.has(crushName)) {
                    crushersMap.set(crushName, []);
                }
                crushersMap.get(crushName).push({
                    name: userName,
                    email: userData.email
                });
            });
        });

        // Find users who have received crushes but haven't submitted any
        const inactiveReceivers = [];

        allUsers.forEach((user, userName) => {
            if (user.crushCount > 0) {
                const hasVerifiedName = user.hasVerifiedName;
                const hasSubmittedCrushes = user.hasSubmittedCrushes;

                // Only include if they have no verified name OR no submitted crushes
                if (!hasVerifiedName || !hasSubmittedCrushes) {
                    const crushers = crushersMap.get(userName) || [];

                    let reason = '';
                    if (!hasVerifiedName && !hasSubmittedCrushes) {
                        reason = 'No verified name and no crushes submitted';
                    } else if (!hasVerifiedName) {
                        reason = 'No verified name';
                    } else if (!hasSubmittedCrushes) {
                        reason = 'No crushes submitted';
                    }

                    inactiveReceivers.push({
                        name: userName,
                        email: user.email,
                        crushCount: user.crushCount,
                        reason: reason,
                        crushers: crushers
                    });
                }
            }
        });

        // Sort by crush count (highest first)
        inactiveReceivers.sort((a, b) => b.crushCount - a.crushCount);

        console.log(`Found ${inactiveReceivers.length} users who have received crushes but are inactive:\n`);

        if (inactiveReceivers.length === 0) {
            console.log('ðŸŽ‰ All users who have received crushes are fully active!');
        } else {
            inactiveReceivers.forEach((user, index) => {
                const rank = (index + 1).toString().padStart(2);
                const crushText = user.crushCount === 1 ? 'crush' : 'crushes';

                console.log(`${rank}. ${user.name} - ${user.crushCount} ${crushText}`);
                console.log(`    Email: ${user.email}`);
                console.log(`    Status: ${user.reason}`);
                console.log(`    Being crushed on by:`);

                user.crushers.forEach(crusher => {
                    console.log(`      â€¢ ${crusher.name} (${crusher.email})`);
                });

                console.log('');
            });

            // Summary by reason
            const reasonCounts = {};
            inactiveReceivers.forEach(user => {
                reasonCounts[user.reason] = (reasonCounts[user.reason] || 0) + 1;
            });

            console.log('='.repeat(80));
            console.log('SUMMARY BY REASON:');
            Object.entries(reasonCounts).forEach(([reason, count]) => {
                console.log(`  ${reason}: ${count} users`);
            });

            const totalCrushes = inactiveReceivers.reduce((sum, user) => sum + user.crushCount, 0);
            console.log(`\nTotal crushes directed at these inactive users: ${totalCrushes}`);
        }

        console.log('\n' + '='.repeat(80));

    } catch (error) {
        console.error('Error analyzing inactive receivers:', error);
    } finally {
        process.exit(0);
    }
}

analyzeInactiveReceivers();

================
File: scripts/repomix.sh
================
#!/bin/bash

cd ..

repomix

================
File: src/components/dashboard/CrushCountSection.tsx
================
import React from 'react';

interface CrushCountSectionProps {
    crushCount: number;
}

export const CrushCountSection: React.FC<CrushCountSectionProps> = ({ crushCount }) => {
    if (crushCount === 0) return null;

    return (
        <div className="crush-count-section">
            <h2>{crushCount} {crushCount === 1 ? 'person is' : 'people are'} crushing on you!</h2>
        </div>
    );
};

================
File: src/components/dashboard/InstructionsSection.tsx
================
import React from 'react';

export const InstructionsSection: React.FC = () => (
    <div className="header-section">
        <div className="instructions">
            <ol>
                <li>Select any classmates you'd like to connect with. Your selections are completely private - only you can see who you've chosen.</li>
                <li>Click "Update Preferences" to save your changes. Matches appear automatically when someone you've selected also selects you. Matches are completely private.</li>
                <li>You can add or remove names anytime. There's no limit on how many people you can select, and you can change your preferences as often as you want.</li>
                <li>Once you match with someone, you cannot remove them from your list.</li>
            </ol>
        </div>
    </div>
);

================
File: src/components/dashboard/MatchesSection.tsx
================
import React from 'react';
import type { MatchInfo } from '../../types';
import { MatchItem } from '../shared/MatchItem';

interface MatchesSectionProps {
    matches: MatchInfo[];
}

export const MatchesSection: React.FC<MatchesSectionProps> = ({ matches }) => {
    if (!matches || matches.length === 0) return null;

    return (
        <div className="matches-section">
            <h2>ðŸŽ‰ You have {matches.length} match{matches.length > 1 ? 'es' : ''}!</h2>
            <div className="matches-list">
                {matches.map((match, index) => (
                    <MatchItem key={index} match={match} index={index} />
                ))}
            </div>
        </div>
    );
};

================
File: src/components/dashboard/SelectedNamesSection.tsx
================
import React from 'react';

interface SelectedNamesSectionProps {
    selectedNames: string[];
    lockedCrushes: string[];
    onRemove: (name: string) => void;
    updating: boolean;
}

export const SelectedNamesSection: React.FC<SelectedNamesSectionProps> = ({
    selectedNames,
    lockedCrushes,
    onRemove,
    updating
}) => {
    if (selectedNames.length === 0) return null;

    return (
        <div className="selected-names">
            <h3>Your Selections ({selectedNames.length})</h3>
            <div className="name-chips">
                {selectedNames.map(name => {
                    const isLocked = lockedCrushes.includes(name);
                    return (
                        <div key={name} className={`name-chip ${isLocked ? 'locked' : 'selected'}`}>
                            <span>{name}</span>
                            {isLocked ? (
                                <span className="lock-icon" title="Locked - you have matched with this person">ðŸ”’</span>
                            ) : (
                                <button
                                    onClick={() => onRemove(name)}
                                    className="remove-btn"
                                    aria-label={`Remove ${name}`}
                                    disabled={updating}
                                >
                                    Ã—
                                </button>
                            )}
                        </div>
                    );
                })}
            </div>
        </div>
    );
};

================
File: src/components/shared/LoadingSpinner.tsx
================
import React from 'react';

interface LoadingSpinnerProps {
    message?: string;
    className?: string;
}

export const LoadingSpinner: React.FC<LoadingSpinnerProps> = ({
    message = 'Loading...',
    className = 'loading'
}) => (
    <div className={className}>
        {message}
    </div>
);

================
File: src/components/shared/MatchItem.tsx
================
import React from 'react';
import type { MatchInfo } from '../../types';

interface MatchItemProps {
    match: MatchInfo;
    index: number;
}

export const MatchItem: React.FC<MatchItemProps> = ({ match, index }) => (
    <div key={index} className="match-item">
        <div className="match-name">{match.name}</div>
        <div className="match-email">{match.email}</div>
    </div>
);

================
File: src/components/shared/SearchInput.tsx
================
import React, { useRef } from 'react';

interface SearchInputProps {
    value: string;
    onChange: (value: string) => void;
    placeholder: string;
    className?: string;
    onClear?: () => void;
}

export const SearchInput: React.FC<SearchInputProps> = ({
    value,
    onChange,
    placeholder,
    className = 'search-input',
    onClear
}) => {
    const inputRef = useRef<HTMLInputElement>(null);

    const handleClear = () => {
        onChange('');
        if (onClear) onClear();
        if (inputRef.current) {
            inputRef.current.focus();
        }
    };

    return (
        <div className="search-input-container">
            <input
                ref={inputRef}
                type="text"
                placeholder={placeholder}
                value={value}
                onChange={(e) => onChange(e.target.value)}
                className={className}
            />
            {value && (
                <button
                    onClick={handleClear}
                    className="search-clear-btn"
                    type="button"
                    aria-label="Clear search"
                >
                    Ã—
                </button>
            )}
        </div>
    );
};

================
File: src/config/firebase.ts
================
import { initializeApp } from "firebase/app";
import { getAuth, GoogleAuthProvider } from "firebase/auth";
import { getFirestore } from "firebase/firestore";
import { getAnalytics } from "firebase/analytics";

const firebaseConfig = {
    apiKey: "AIzaSyDC_YL8wau3PKK1r2ZYYHc32TtnoXe5giQ",
    authDomain: "stanford-lastchances.firebaseapp.com",
    projectId: "stanford-lastchances",
    storageBucket: "stanford-lastchances.firebasestorage.app",
    messagingSenderId: "792276801448",
    appId: "1:792276801448:web:84a43cc96308673321ef9d",
    measurementId: "G-HLD1E4T34S"
};

// Initialize Firebase
const app = initializeApp(firebaseConfig);
export const auth = getAuth(app);
export const db = getFirestore(app);
export const analytics = getAnalytics(app);

// Configure Google provider to only allow stanford.edu emails
export const googleProvider = new GoogleAuthProvider();
googleProvider.setCustomParameters({
    hd: 'stanford.edu' // This restricts to stanford.edu domain
});

// Additional configuration for cross-domain compatibility
auth.useDeviceLanguage();

================
File: src/hooks/useAdminData.ts
================
import { useState, useCallback, useEffect } from 'react';
import { collection, getDocs } from 'firebase/firestore';
import { db } from '../config/firebase';
import { GSB_CLASS_NAMES } from '../data/names';
import { UNDERGRAD_CLASS_NAMES } from '../data/names-undergrad';
import { findUserByName } from '../utils/adminUtils';
import type { UserData, UserClass } from '../types/userTypes';

interface CrusherInfo {
    name: string;
    email: string;
}

interface InactiveUser extends UserData {
    isInactive: boolean;
}

interface GhostUser extends UserData {
    isGhost: boolean;
}

interface ClassAnalyticsData {
    totalUsers: number;
    totalClassSize: number;
    totalMatches: number;
    matchedPairs: string[];
    totalCrushes: number;
    peopleWithCrushes: number;
    avgCrushes: number;
    usersWithCrushes: number;
    usersWithMatches: number;
    participationRate: number;
    classParticipationRate: number;
    orphanedCrushes: string[];
    topCrushReceivers: Array<{ name: string; count: number; crushers: string[] }>;
    topCrushSenders: Array<{ name: string; count: number; crushNames: string[] }>;
    inactiveReceivers: Array<{ name: string; email: string; crushCount: number; reason: string; crushers: CrusherInfo[] }>;
    activeUsersLast24h: number; // Percentage of active users who were active in last 24h
}

export const useAdminData = (user: any, currentClassView: UserClass, refreshKey: number) => {
    const [allUsers, setAllUsers] = useState<(UserData | InactiveUser | GhostUser)[]>([]);
    const [loadingUsers, setLoadingUsers] = useState(false);
    const [currentAnalytics, setCurrentAnalytics] = useState<ClassAnalyticsData | null>(null);
    const [loadingAnalytics, setLoadingAnalytics] = useState(false);

    const normalizeName = useCallback((name: string): string => {
        if (!name || typeof name !== 'string') return '';

        return name
            .normalize('NFD')
            .replace(/[\u0300-\u036f]/g, '')
            .toLowerCase()
            .trim()
            .replace(/[^\w\s]/g, ' ')
            .replace(/\s+/g, ' ')
            .trim();
    }, []);

    const calculateRealTime24hActiveUsers = useCallback((activeUsers: UserData[]): number => {
        if (activeUsers.length === 0) return 0;

        const twentyFourHoursAgo = new Date(Date.now() - (24 * 60 * 60 * 1000));
        let recentlyActiveCount = 0;

        activeUsers.forEach(user => {
            if (user.lastLogin) {
                let lastLoginDate;

                if (user.lastLogin.toDate) {
                    lastLoginDate = user.lastLogin.toDate();
                } else if (user.lastLogin.seconds) {
                    lastLoginDate = new Date(user.lastLogin.seconds * 1000);
                } else {
                    lastLoginDate = new Date(user.lastLogin);
                }

                if (lastLoginDate > twentyFourHoursAgo) {
                    recentlyActiveCount++;
                }
            }
        });

        // Percentage of active users (signed-up students) who were active in last 24h
        return Number((recentlyActiveCount / activeUsers.length * 100).toFixed(2));
    }, []);

    const calculateClassAnalytics = useCallback((targetClass: UserClass): ClassAnalyticsData => {
        const realUsers = allUsers.filter(u =>
            !(u as InactiveUser).isInactive && !(u as GhostUser).isGhost
        ) as UserData[];

        // Filter users by class - these are the "active users" (signed up students)
        const classUsers = realUsers.filter(user => (user.userClass || 'gsb') === targetClass);

        // Get class size
        const totalClassSize = targetClass === 'gsb' ? GSB_CLASS_NAMES.length : UNDERGRAD_CLASS_NAMES.length;

        // Basic stats
        const totalUsers = classUsers.length;

        // Calculate matches within class
        const classPairs = new Set<string>();

        classUsers.forEach(user => {
            const matches = user.matches || [];
            if (Array.isArray(matches) && matches.length > 0) {
                matches.forEach(match => {
                    const matchName = match.name || match;
                    const pair = [user.name, matchName].sort().join(' â†” ');
                    classPairs.add(pair);
                });
            }
        });

        const totalMatches = classPairs.size;
        const matchedPairs = Array.from(classPairs).sort();

        // Calculate crush statistics for class
        let totalCrushes = 0;

        classUsers.forEach(user => {
            const userCrushes = user.crushes || [];
            totalCrushes += userCrushes.length;
        });

        const crushCounts = new Map<string, number>();
        const crushersMap = new Map<string, string[]>();

        classUsers.forEach(user => {
            const userCrushes = user.crushes || [];
            userCrushes.forEach(crushName => {
                const targetUser = findUserByName(crushName, allUsers, targetClass);

                if (targetUser) {
                    const actualName = targetUser.name;
                    if (actualName) {
                        crushCounts.set(actualName, (crushCounts.get(actualName) || 0) + 1);
                        if (!crushersMap.has(actualName)) {
                            crushersMap.set(actualName, []);
                        }
                        crushersMap.get(actualName)!.push(user.name);
                    }
                } else {
                    crushCounts.set(crushName, (crushCounts.get(crushName) || 0) + 1);
                    if (!crushersMap.has(crushName)) {
                        crushersMap.set(crushName, []);
                    }
                    crushersMap.get(crushName)!.push(user.name);
                }
            });
        });

        const peopleWithCrushes = Array.from(crushCounts.keys()).filter(name => crushCounts.get(name)! > 0).length;
        const avgCrushes = totalUsers > 0 ? totalCrushes / totalUsers : 0;

        // User activity stats
        const usersWithCrushes = classUsers.filter(user => user.crushes.length > 0).length;
        const usersWithMatches = classUsers.filter(user => user.matches.length > 0).length;

        // Participation rates
        const participationRate = totalUsers > 0 ? (usersWithCrushes / totalUsers * 100) : 0;
        const classParticipationRate = totalClassSize > 0 ? (usersWithCrushes / totalClassSize * 100) : 0;

        // Find orphaned crushes
        const orphanedCrushes: string[] = [];
        const allCrushNames = new Set<string>();

        classUsers.forEach(user => {
            const userCrushes = user.crushes || [];
            userCrushes.forEach(crushName => {
                allCrushNames.add(crushName);
            });
        });

        allCrushNames.forEach(crushName => {
            const match = findUserByName(crushName, allUsers, targetClass);
            if (!match) {
                orphanedCrushes.push(crushName);
            }
        });

        // Top crush receivers (limit for performance)
        const topCrushReceivers = Array.from(crushCounts.entries())
            .map(([name, count]) => ({
                name,
                count,
                crushers: crushersMap.get(name) || []
            }))
            .sort((a, b) => b.count - a.count)
            .slice(0, 25);

        // Top crush senders (limit for performance)
        const topCrushSenders = classUsers
            .map(user => ({
                name: user.name,
                count: user.crushes.length,
                crushNames: user.crushes
            }))
            .sort((a, b) => b.count - a.count)
            .slice(0, 25);

        // Inactive receivers
        const inactiveReceivers: Array<{ name: string; email: string; crushCount: number; reason: string; crushers: CrusherInfo[] }> = [];

        classUsers.forEach(user => {
            if (user.crushCount > 0) {
                const hasSubmittedCrushes = !!(user.crushes && user.crushes.length > 0);

                if (!hasSubmittedCrushes) {
                    const crushers: CrusherInfo[] = [];
                    const targetName = user.name;
                    const targetClass = user.userClass || 'gsb';

                    if (targetName) {
                        allUsers.forEach(u => {
                            if (u.uid === user.uid || (u as InactiveUser).isInactive || (u as GhostUser).isGhost) return;

                            const userClass = u.userClass || 'gsb';
                            if (userClass !== targetClass) return;

                            const userCrushes = u.crushes || [];
                            if (userCrushes.includes(targetName)) {
                                crushers.push({
                                    name: u.name,
                                    email: u.email
                                });
                            }
                        });
                    }

                    inactiveReceivers.push({
                        name: user.name || 'Unknown',
                        email: user.email,
                        crushCount: user.crushCount,
                        reason: 'No crushes submitted',
                        crushers
                    });
                }
            }
        });

        inactiveReceivers.sort((a, b) => b.crushCount - a.crushCount);

        return {
            totalUsers,
            totalClassSize,
            totalMatches,
            matchedPairs,
            totalCrushes,
            peopleWithCrushes,
            avgCrushes: Number(avgCrushes.toFixed(2)),
            usersWithCrushes,
            usersWithMatches,
            participationRate: Number(participationRate.toFixed(2)),
            classParticipationRate: Number(classParticipationRate.toFixed(2)),
            orphanedCrushes,
            topCrushReceivers,
            topCrushSenders,
            inactiveReceivers,
            activeUsersLast24h: calculateRealTime24hActiveUsers(classUsers)
        };
    }, [allUsers, calculateRealTime24hActiveUsers]);

    const loadAllUsers = useCallback(async () => {
        if (user?.email !== 'jpark22@stanford.edu') {
            return;
        }

        setLoadingUsers(true);
        try {
            const usersSnapshot = await getDocs(collection(db, 'users'));
            const realUsers: UserData[] = [];

            usersSnapshot.forEach(doc => {
                const data = doc.data() as UserData;
                realUsers.push({
                    ...data,
                    uid: doc.id,
                    userClass: data.userClass || 'gsb'
                });
            });

            // Create inactive and ghost users only for the current class
            const realUserNames = new Set(realUsers.map(u => u.name).filter(Boolean));
            const inactiveUsers: InactiveUser[] = [];
            const ghostUsers: GhostUser[] = [];

            // Only process the current class roster
            const currentClassNames = currentClassView === 'gsb' ? GSB_CLASS_NAMES : UNDERGRAD_CLASS_NAMES;

            currentClassNames.forEach(className => {
                if (realUserNames.has(className)) {
                    return;
                }

                let crushCount = 0;
                realUsers.forEach(user => {
                    if ((user.userClass || 'gsb') === currentClassView) {
                        const userCrushes = user.crushes || [];
                        if (userCrushes.includes(className)) {
                            crushCount++;
                        }
                    }
                });

                const derivedEmail = `${className.toLowerCase().replace(/\s+/g, '.')}@stanford.edu`;

                if (crushCount > 0) {
                    const inactiveId = `inactive-${currentClassView}-${normalizeName(className).replace(/\s+/g, '-')}`;
                    inactiveUsers.push({
                        uid: inactiveId,
                        email: derivedEmail,
                        name: className,
                        photoURL: '/files/default-profile.png',
                        crushes: [],
                        lockedCrushes: [],
                        matches: [],
                        crushCount: crushCount,
                        userClass: currentClassView,
                        isInactive: true,
                        createdAt: null,
                        updatedAt: null,
                        lastLogin: null
                    });
                } else {
                    const ghostId = `ghost-${currentClassView}-${normalizeName(className).replace(/\s+/g, '-')}`;
                    ghostUsers.push({
                        uid: ghostId,
                        email: derivedEmail,
                        name: className,
                        photoURL: '/files/default-profile.png',
                        crushes: [],
                        lockedCrushes: [],
                        matches: [],
                        crushCount: 0,
                        userClass: currentClassView,
                        isGhost: true,
                        createdAt: null,
                        updatedAt: null,
                        lastLogin: null
                    });
                }
            });

            // Filter all users to only include the current class
            const currentClassRealUsers = realUsers.filter(user => (user.userClass || 'gsb') === currentClassView);
            const allUsersArray = [...currentClassRealUsers, ...inactiveUsers, ...ghostUsers];

            // Sort alphabetically within each type
            allUsersArray.sort((a, b) => {
                const aIsInactive = (a as InactiveUser).isInactive || false;
                const bIsInactive = (b as InactiveUser).isInactive || false;
                const aIsGhost = (a as GhostUser).isGhost || false;
                const bIsGhost = (b as GhostUser).isGhost || false;

                // Active users first, then inactive, then ghost
                if (!aIsInactive && !aIsGhost && (bIsInactive || bIsGhost)) return -1;
                if ((aIsInactive || aIsGhost) && !bIsInactive && !bIsGhost) return 1;

                if (aIsInactive && !bIsInactive && bIsGhost) return -1;
                if (!aIsInactive && aIsGhost && bIsInactive) return 1;

                // Then alphabetically
                const nameA = a.name || a.email || '';
                const nameB = b.name || b.email || '';
                return nameA.localeCompare(nameB);
            });

            setAllUsers(allUsersArray);

        } catch (error: any) {
            console.error('Error loading all users:', error);
        } finally {
            setLoadingUsers(false);
        }
    }, [normalizeName, user?.email, currentClassView]);

    useEffect(() => {
        if (user?.email === 'jpark22@stanford.edu') {
            loadAllUsers();
        }
    }, [user, loadAllUsers]);

    // Calculate analytics for current class only
    useEffect(() => {
        if (allUsers.length > 0 && user?.email === 'jpark22@stanford.edu') {
            setLoadingAnalytics(true);

            const timeoutId = setTimeout(() => {
                try {
                    const analyticsData = calculateClassAnalytics(currentClassView);
                    setCurrentAnalytics(analyticsData);
                } finally {
                    setLoadingAnalytics(false);
                }
            }, 300);

            return () => clearTimeout(timeoutId);
        }
    }, [allUsers, calculateClassAnalytics, refreshKey, user?.email, currentClassView]);

    return {
        allUsers,
        loadingUsers,
        currentAnalytics,
        loadingAnalytics,
        loadAllUsers
    };
};

================
File: src/hooks/useAdminUtils.ts
================
import { useCallback } from 'react';
import type { UserData } from '../types/userTypes';

interface CrusherInfo {
    name: string;
    email: string;
}

interface InactiveUser extends UserData {
    isInactive: boolean;
}

interface GhostUser extends UserData {
    isGhost: boolean;
}

export const useAdminUtils = (allUsers: (UserData | InactiveUser | GhostUser)[]) => {
    const findCrushersForUser = useCallback((targetUser: UserData | InactiveUser | GhostUser): CrusherInfo[] => {
        const crushers: CrusherInfo[] = [];
        const targetName = targetUser.name;
        const targetClass = targetUser.userClass || 'gsb';

        if (!targetName) return crushers;

        allUsers.forEach(u => {
            if (u.uid === targetUser.uid || (u as InactiveUser).isInactive || (u as GhostUser).isGhost) return;

            // Only consider crushes from users in the same class
            const userClass = u.userClass || 'gsb';
            if (userClass !== targetClass) return;

            const userCrushes = u.crushes || [];
            if (userCrushes.includes(targetName)) {
                crushers.push({
                    name: u.name,
                    email: u.email
                });
            }
        });

        return crushers;
    }, [allUsers]);

    return { findCrushersForUser };
};

================
File: src/hooks/useAuthHelpers.ts
================
import { useCallback } from 'react';
import type { User } from 'firebase/auth';
import type { MatchInfo, UserClass } from '../types/userTypes';

const DEFAULT_PROFILE_URL = '/files/default-profile.png';

export const useAuthHelpers = () => {
    const normalizeMatches = useCallback((matches: any[]): MatchInfo[] => {
        if (!matches || !Array.isArray(matches)) return [];

        return matches.map(match => {
            if (typeof match === 'string') {
                return {
                    name: match,
                    email: match.toLowerCase().replace(/\s+/g, '.') + '@stanford.edu'
                };
            } else if (match && typeof match === 'object' && match.name && match.email) {
                return {
                    name: match.name,
                    email: match.email
                };
            } else {
                return {
                    name: 'Unknown',
                    email: 'unknown@stanford.edu'
                };
            }
        });
    }, []);

    // Helper function to get the correct document ID for user class
    const getUserDocumentId = useCallback((user: User, userClass: UserClass): string => {
        if (user.email === 'jpark22@stanford.edu') {
            // For test user, always use class-specific UIDs to ensure complete separation
            return userClass === 'gsb' ? `${user.uid}_gsb` : `${user.uid}_undergrad`;
        }
        return user.uid;
    }, []);

    // Helper functions for localStorage to remember last used class
    const getLastUsedClass = useCallback((): UserClass | null => {
        try {
            return localStorage.getItem('lastUsedClass') as UserClass | null;
        } catch {
            return null;
        }
    }, []);

    const setLastUsedClass = useCallback((userClass: UserClass): void => {
        try {
            localStorage.setItem('lastUsedClass', userClass);
        } catch {
            // Ignore localStorage errors
        }
    }, []);

    return {
        normalizeMatches,
        getUserDocumentId,
        getLastUsedClass,
        setLastUsedClass,
        DEFAULT_PROFILE_URL
    };
};

================
File: src/hooks/useUserDocumentManager.ts
================
import { useCallback } from 'react';
import type { User } from 'firebase/auth';
import { signOut } from 'firebase/auth';
import { doc, getDoc, setDoc, serverTimestamp } from 'firebase/firestore';
import { auth, db } from '../config/firebase';
import { GSB_CLASS_NAMES } from '../data/names';
import { UNDERGRAD_CLASS_NAMES } from '../data/names-undergrad';
import { useAuthHelpers } from './useAuthHelpers';
import type { UserData, UserClass } from '../types/userTypes';

// Helper function to normalize names for comparison
function normalizeName(name: string): string {
    if (!name || typeof name !== 'string') return '';

    return name
        .normalize('NFD')
        .replace(/[\u0300-\u036f]/g, '')
        .toLowerCase()
        .trim()
        .replace(/[^\w\s]/g, ' ')
        .replace(/\s+/g, ' ')
        .trim();
}

// Helper function to find potential name matches
function findNameMatches(displayName: string, availableNames: string[]): { exactMatch?: string; potentialMatches: string[] } {
    const normalizedInput = normalizeName(displayName);

    // Try exact match first
    const exactMatch = availableNames.find(name =>
        normalizeName(name) === normalizedInput
    );

    if (exactMatch) {
        return { exactMatch, potentialMatches: [] };
    }

    // If no exact match, look for potential matches
    const inputParts = normalizedInput.split(' ').filter(Boolean);
    if (inputParts.length < 2) {
        return { potentialMatches: [] };
    }

    const inputFirst = inputParts[0];
    const inputLast = inputParts[inputParts.length - 1];

    const potentialMatches = availableNames.filter(name => {
        const normalizedName = normalizeName(name);
        const nameParts = normalizedName.split(' ').filter(Boolean);

        if (nameParts.length < 2) return false;

        const nameFirst = nameParts[0];
        const nameLast = nameParts[nameParts.length - 1];

        return nameFirst === inputFirst && nameLast === inputLast;
    });

    return { potentialMatches };
}

export const useUserDocumentManager = (
    setNameOptions: (options: string[] | null) => void,
    setPendingUserClass: (userClass: UserClass | null) => void,
    setLastUsedClass: (userClass: UserClass) => void
) => {
    const { getUserDocumentId, normalizeMatches, DEFAULT_PROFILE_URL } = useAuthHelpers();

    const createOrUpdateUserDocument = useCallback(async (user: User, userClass: UserClass) => {
        if (!user.uid) return null;

        // Remember which class was selected for login
        setLastUsedClass(userClass);

        try {
            // Special handling for test user (you) - always use class-specific UIDs
            if (user.email === 'jpark22@stanford.edu') {
                const actualUid = getUserDocumentId(user, userClass);
                const userRef = doc(db, 'users', actualUid);
                const userDoc = await getDoc(userRef);

                if (!userDoc.exists()) {
                    // Create completely new user document for this class
                    const classNames = userClass === 'gsb' ? GSB_CLASS_NAMES : UNDERGRAD_CLASS_NAMES;
                    const displayName = user.displayName || user.email?.split('@')[0] || '';

                    const { exactMatch, potentialMatches } = findNameMatches(displayName, classNames);

                    if (exactMatch) {
                        console.log(`Creating fresh ${userClass} account with name: ${exactMatch}`);
                        const newUserData: UserData = {
                            uid: actualUid,
                            email: user.email || '',
                            name: exactMatch,
                            photoURL: user.photoURL || DEFAULT_PROFILE_URL,
                            crushes: [], // Start fresh - no crushes
                            lockedCrushes: [], // Start fresh - no locked crushes
                            matches: [], // Start fresh - no matches
                            crushCount: 0, // Start fresh - no crush count
                            userClass: userClass,
                            createdAt: serverTimestamp(),
                            updatedAt: serverTimestamp(),
                            lastLogin: serverTimestamp()
                        };

                        await setDoc(userRef, newUserData);
                        // Real-time listener will handle the update
                        console.log(`Successfully created fresh ${userClass} account`);
                        return newUserData;
                    } else if (potentialMatches.length > 0) {
                        console.log(`Multiple matches found for ${userClass}, showing selection`);
                        setNameOptions(potentialMatches);
                        setPendingUserClass(userClass);

                        const incompleteUserData: UserData = {
                            uid: actualUid,
                            email: user.email || '',
                            name: '', // Will be set when user selects
                            photoURL: user.photoURL || DEFAULT_PROFILE_URL,
                            crushes: [], // Start fresh
                            lockedCrushes: [], // Start fresh
                            matches: [], // Start fresh
                            crushCount: 0, // Start fresh
                            userClass: userClass,
                            createdAt: serverTimestamp(),
                            updatedAt: serverTimestamp(),
                            lastLogin: serverTimestamp()
                        };

                        await setDoc(userRef, incompleteUserData);
                        // Real-time listener will handle the update
                        return incompleteUserData;
                    } else {
                        await signOut(auth);
                        const className = userClass === 'gsb' ? 'GSB Class of 2025' : 'Undergraduate Class of 2025';
                        alert(`Your name was not found in the ${className} roster. If this is a mistake, please contact jpark22@stanford.edu.`);
                        return null;
                    }
                } else {
                    // Document exists, just update login time (don't modify crushes/matches)
                    const existingData = userDoc.data();
                    console.log(`Using existing ${userClass} account for ${existingData.name}`);

                    const updatedData: UserData = {
                        uid: existingData.uid,
                        email: existingData.email,
                        name: existingData.name || existingData.verifiedName || existingData.displayName || '',
                        photoURL: user.photoURL || existingData.photoURL || DEFAULT_PROFILE_URL,
                        crushes: existingData.crushes || [],
                        lockedCrushes: existingData.lockedCrushes || [],
                        matches: normalizeMatches(existingData.matches || []),
                        crushCount: existingData.crushCount || 0,
                        userClass: existingData.userClass || userClass,
                        createdAt: existingData.createdAt,
                        updatedAt: serverTimestamp(),
                        lastLogin: serverTimestamp()
                    };

                    await setDoc(userRef, updatedData, { merge: true });
                    // Real-time listener will handle the update
                    return updatedData;
                }
            } else {
                // Regular user flow for everyone else
                const userRef = doc(db, 'users', user.uid);
                const userDoc = await getDoc(userRef);

                if (!userDoc.exists()) {
                    // New user
                    const classNames = userClass === 'gsb' ? GSB_CLASS_NAMES : UNDERGRAD_CLASS_NAMES;
                    const displayName = user.displayName || user.email?.split('@')[0] || '';
                    const { exactMatch, potentialMatches } = findNameMatches(displayName, classNames);

                    if (exactMatch) {
                        const newUserData: UserData = {
                            uid: user.uid,
                            email: user.email || '',
                            name: exactMatch,
                            photoURL: user.photoURL || DEFAULT_PROFILE_URL,
                            crushes: [],
                            lockedCrushes: [],
                            matches: [],
                            crushCount: 0,
                            userClass: userClass,
                            createdAt: serverTimestamp(),
                            updatedAt: serverTimestamp(),
                            lastLogin: serverTimestamp()
                        };

                        await setDoc(userRef, newUserData);
                        // Real-time listener will handle the update
                        return newUserData;
                    } else if (potentialMatches.length > 0) {
                        setNameOptions(potentialMatches);
                        setPendingUserClass(userClass);

                        const incompleteUserData: UserData = {
                            uid: user.uid,
                            email: user.email || '',
                            name: '',
                            photoURL: user.photoURL || DEFAULT_PROFILE_URL,
                            crushes: [],
                            lockedCrushes: [],
                            matches: [],
                            crushCount: 0,
                            userClass: userClass,
                            createdAt: serverTimestamp(),
                            updatedAt: serverTimestamp(),
                            lastLogin: serverTimestamp()
                        };

                        await setDoc(userRef, incompleteUserData);
                        // Real-time listener will handle the update
                        return incompleteUserData;
                    } else {
                        await signOut(auth);
                        const className = userClass === 'gsb' ? 'GSB Class of 2025' : 'Undergraduate Class of 2025';
                        alert(`Your name was not found in the ${className} roster. If this is a mistake, please contact jpark22@stanford.edu.`);
                        return null;
                    }
                } else {
                    // Existing user - check if they're trying wrong class
                    const existingData = userDoc.data();
                    if (existingData.userClass && existingData.userClass !== userClass) {
                        await signOut(auth);
                        const existingClassName = existingData.userClass === 'gsb' ? 'GSB' : 'Undergraduate';
                        alert(`You are already registered as a ${existingClassName} student. Please sign in with the ${existingClassName} option.`);
                        return null;
                    }

                    const updatedData: UserData = {
                        uid: existingData.uid,
                        email: existingData.email,
                        name: existingData.name || existingData.verifiedName || existingData.displayName || '',
                        photoURL: user.photoURL || existingData.photoURL || DEFAULT_PROFILE_URL,
                        crushes: existingData.crushes || [],
                        lockedCrushes: existingData.lockedCrushes || [],
                        matches: normalizeMatches(existingData.matches),
                        crushCount: existingData.crushCount || 0,
                        userClass: existingData.userClass || userClass,
                        createdAt: existingData.createdAt,
                        updatedAt: serverTimestamp(),
                        lastLogin: serverTimestamp()
                    };

                    await setDoc(userRef, updatedData, { merge: true });
                    // Real-time listener will handle the update
                    return updatedData;
                }
            }
        } catch (error) {
            console.error('Error creating/updating user document:', error);
            return null;
        }
    }, [getUserDocumentId, normalizeMatches, DEFAULT_PROFILE_URL, setNameOptions, setPendingUserClass, setLastUsedClass]);

    return { createOrUpdateUserDocument };
};

================
File: src/styles/admin/admin-base.css
================
/* Admin Base Styles */
.header-actions {
    display: flex;
    align-items: center;
    gap: 8px;
  }
  
  .admin-toggle-btn {
    background: rgba(255, 255, 255, 0.2);
    color: white;
    border: 1px solid rgba(255, 255, 255, 0.3);
    padding: 6px 12px;
    border-radius: 6px;
    cursor: pointer;
    font-size: 12px;
    transition: all 0.2s ease;
  }
  
  .admin-toggle-btn:hover {
    background: rgba(255, 255, 255, 0.3);
  }
  
  .admin-section {
    padding: 20px 0;
  }
  
  .admin-section h3 {
    color: #8C1515;
    margin-bottom: 20px;
    font-size: 18px;
  }
  
  /* Enhanced Admin Header */
  .admin-header-section {
    margin-bottom: 20px;
  }
  
  .admin-title-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
  }
  
  .admin-refresh-btn {
    background: #28a745;
    color: white;
    border: none;
    padding: 8px 16px;
    border-radius: 6px;
    cursor: pointer;
    font-size: 12px;
    font-weight: 500;
    transition: all 0.2s ease;
  }
  
  .admin-refresh-btn:hover:not(:disabled) {
    background: #218838;
    transform: translateY(-1px);
  }
  
  .admin-refresh-btn:disabled {
    background: #6c757d;
    cursor: not-allowed;
    transform: none;
  }
  
  /* Navigation */
  .admin-nav {
    display: flex;
    gap: 8px;
    margin-bottom: 20px;
    flex-wrap: wrap;
  }
  
  .admin-nav-btn {
    background: #f8f9fa;
    color: #8C1515;
    border: 2px solid #e1e5e9;
    padding: 8px 16px;
    border-radius: 6px;
    cursor: pointer;
    font-size: 13px;
    font-weight: 500;
    transition: all 0.2s ease;
    min-width: 140px;
    text-align: center;
  }
  
  .admin-nav-btn:hover:not(:disabled) {
    background: #e9ecef;
    border-color: #8C1515;
  }
  
  .admin-nav-btn:disabled {
    opacity: 0.6;
    cursor: not-allowed;
  }
  
  .admin-nav-btn.active {
    background: #8C1515;
    color: white;
    border-color: #8C1515;
  }
  
  /* Access Denied Styles */
  .admin-access-denied {
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 60vh;
    padding: 20px;
  }
  
  .access-denied-card {
    background: white;
    padding: 40px;
    border-radius: 12px;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
    text-align: center;
    max-width: 400px;
    width: 100%;
    border-left: 4px solid #dc3545;
  }
  
  .access-denied-card h2 {
    color: #dc3545;
    margin: 0 0 15px 0;
    font-size: 24px;
    font-weight: 600;
  }
  
  .access-denied-card p {
    color: #666;
    margin: 10px 0;
    font-size: 14px;
    line-height: 1.5;
  }
  
  .access-denied-card p:last-child {
    margin-bottom: 0;
    font-weight: 500;
  }
  
  /* Loading states */
  .admin-loading {
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 40px;
    color: #666;
    font-style: italic;
  }
  
  .admin-loading::after {
    content: '...';
    animation: loading-dots 1.5s infinite;
  }
  
  @keyframes loading-dots {
    0%, 20% { opacity: 0; }
    50% { opacity: 1; }
    100% { opacity: 0; }
  }
  
  /* Focus styles for keyboard navigation */
  .admin-nav-btn:focus,
  .admin-refresh-btn:focus {
    outline: 2px solid #8C1515;
    outline-offset: 2px;
  }
  
  /* Accessibility improvements */
  @media (prefers-reduced-motion: reduce) {
    .admin-refresh-btn:hover:not(:disabled) {
      transform: none;
    }
  }
  
  /* High contrast mode support */
  @media (prefers-contrast: high) {
    .admin-nav-btn, .admin-refresh-btn {
      border: 2px solid #000;
    }
    
    .admin-nav .admin-nav-btn.active {
      border: 3px solid #000;
    }
  }

================
File: src/styles/admin/admin-layout.css
================
/* Admin Layout and Component Styles */

/* Class Navigation Styles */
.admin-class-nav {
  display: flex;
  gap: 12px;
  margin-bottom: 20px;
  flex-wrap: wrap;
}

.admin-class-btn {
  background: linear-gradient(135deg, #8C1515 0%, #B83A4B 100%);
  color: white;
  border: 2px solid transparent;
  padding: 12px 20px;
  border-radius: 8px;
  cursor: pointer;
  font-size: 14px;
  font-weight: 600;
  transition: all 0.2s ease;
  min-width: 180px;
  text-align: center;
  box-shadow: 0 2px 4px rgba(140, 21, 21, 0.3);
}

.admin-class-btn:hover:not(:disabled) {
  transform: translateY(-2px);
  box-shadow: 0 4px 8px rgba(140, 21, 21, 0.4);
}

.admin-class-btn:disabled {
  opacity: 0.6;
  cursor: not-allowed;
  transform: none;
}

.admin-class-btn.active {
  background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
  box-shadow: 0 4px 8px rgba(40, 167, 69, 0.4);
}

/* Class Header Styles */
.admin-class-header {
  background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
  padding: 20px;
  border-radius: 8px;
  border-left: 4px solid #8C1515;
  margin-bottom: 20px;
}

.admin-class-header h4 {
  color: #8C1515;
  margin: 0 0 15px 0;
  font-size: 18px;
  font-weight: 600;
}

.admin-class-stats-summary {
  display: flex;
  gap: 20px;
  flex-wrap: wrap;
}

.class-stat {
  display: flex;
  flex-direction: column;
  align-items: center;
  text-align: center;
  font-size: 13px;
  color: #666;
}

.class-stat strong {
  color: #8C1515;
  font-size: 16px;
  font-weight: 700;
}

/* Class Users Header */
.admin-class-users-header {
  background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
  padding: 15px 20px;
  border-radius: 8px;
  border-left: 4px solid #8C1515;
  margin-bottom: 15px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex-wrap: wrap;
  gap: 10px;
}

.admin-class-users-header h4 {
  color: #8C1515;
  margin: 0;
  font-size: 16px;
  font-weight: 600;
}

.admin-class-users-summary {
  display: flex;
  gap: 15px;
  flex-wrap: wrap;
  font-size: 12px;
  color: #666;
}

.admin-class-users-summary span {
  background: white;
  padding: 4px 8px;
  border-radius: 4px;
  border: 1px solid #e1e5e9;
  font-weight: 500;
}

/* Definitions Section */
.admin-definitions {
  margin-bottom: 20px;
  padding: 15px;
  background: #f8f9fa;
  border-radius: 8px;
  border-left: 4px solid #8C1515;
}

.admin-definitions p {
  margin: 8px 0;
  font-size: 13px;
  color: #333;
  line-height: 1.4;
}

.admin-definitions strong {
  color: #8C1515;
  font-weight: 600;
}

/* Analytics Section */
.admin-overview {
  display: flex;
  flex-direction: column;
  gap: 20px;
}

.admin-quick-insights {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
  gap: 15px;
  margin-bottom: 20px;
}

.admin-insight-card {
  background: white;
  padding: 20px;
  border-radius: 8px;
  border-left: 4px solid #8C1515;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  transition: transform 0.2s ease;
}

.admin-insight-card:hover {
  transform: translateY(-2px);
}

.admin-insight-card h4 {
  color: #8C1515;
  margin: 0 0 12px 0;
  font-size: 14px;
  font-weight: 600;
}

.admin-insight-card p {
  margin: 6px 0;
  font-size: 13px;
  color: #666;
}

.admin-analytics {
  display: flex;
  flex-direction: column;
  gap: 20px;
}

.admin-analytics-section {
  background: white;
  padding: 20px;
  border-radius: 8px;
  border-left: 4px solid #8C1515;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.admin-analytics-section h4 {
  color: #8C1515;
  margin: 0 0 15px 0;
  font-size: 16px;
}

/* Matches section styling */
.admin-analytics-section:first-child {
  border-left-color: #28a745;
}

.admin-analytics-section:first-child h4 {
  color: #28a745;
}

.admin-matches-list {
  max-height: 300px;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
  scroll-behavior: smooth;
}

.admin-match-item {
  padding: 8px 12px;
  margin-bottom: 4px;
  background: #f8f9fa;
  border-radius: 4px;
  font-size: 13px;
  border-left: 3px solid #28a745;
}

/* Analytics lists */
.admin-list {
  max-height: 300px;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
}

.admin-list-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px 12px;
  margin-bottom: 4px;
  background: #f8f9fa;
  border-radius: 4px;
  font-size: 13px;
  border-left: 3px solid #8C1515;
}

.admin-inactive-item {
  padding: 12px;
  margin-bottom: 8px;
  background: #fff3cd;
  border-radius: 4px;
  border-left: 3px solid #ffc107;
}

.admin-inactive-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-weight: 600;
  margin-bottom: 8px;
}

.admin-inactive-details p {
  margin: 4px 0;
  font-size: 12px;
  color: #666;
}

/* Users Section */
.admin-search-section {
  margin-bottom: 15px;
}

.admin-search-input {
  width: 100%;
  padding: 12px 40px 12px 15px;
  border: 2px solid #e1e5e9;
  border-radius: 8px;
  font-size: 14px;
  transition: border-color 0.2s ease;
  box-sizing: border-box;
}

.admin-search-input:focus {
  outline: none;
  border-color: #8C1515;
}

.admin-search-input-container {
  position: relative;
  width: 100%;
  margin-bottom: 8px;
}

.admin-search-clear-btn {
  position: absolute;
  right: 10px;
  top: 50%;
  transform: translateY(-50%);
  background: none;
  border: none;
  font-size: 18px;
  color: #666;
  cursor: pointer;
  padding: 4px;
  border-radius: 50%;
  width: 24px;
  height: 24px;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s ease;
}

.admin-search-clear-btn:hover {
  background: #f0f0f0;
  color: #333;
}

.admin-search-hint {
  text-align: center;
  padding: 6px 12px;
  font-size: 10px;
  color: #666;
  background: #f8f9fa;
  border-radius: 4px;
  margin-bottom: 8px;
  border-left: 3px solid #8C1515;
}

.admin-pagination-info {
  margin-top: 8px;
  font-size: 12px;
  color: #666;
  text-align: center;
  font-style: italic;
}

/* FIXED: Users container with disabled smooth scrolling for better position control */
.admin-users-container {
  max-height: 70vh;
  overflow-y: auto;
  border: 1px solid #e1e5e9;
  border-radius: 8px;
  background: white;
  -webkit-overflow-scrolling: touch;
  /* FIXED: Disable smooth scrolling to allow precise position control */
  scroll-behavior: auto !important;
}

.virtual-spacer {
  background: linear-gradient(180deg, transparent 0%, rgba(0,0,0,0.02) 50%, transparent 100%);
  pointer-events: none;
}

/* FIXED: Stable user item layout */
.admin-user-item {
  border-bottom: 1px solid #f0f0f0;
  background: white;
  /* FIXED: Let items expand naturally without constraints */
}

.admin-user-item:last-child {
  border-bottom: none;
}

/* FIXED: Consistent header layout */
.admin-user-header {
  padding: 15px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  background: white;
  transition: background-color 0.2s ease;
  min-height: 80px;
  box-sizing: border-box;
}

.admin-user-header:hover {
  background: #f8f9fa;
}

.admin-user-info {
  flex: 1;
  min-width: 0;
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.admin-user-name {
  font-weight: 600;
  color: #8C1515;
  margin: 0;
  font-size: 14px;
  display: flex;
  align-items: center;
  gap: 8px;
  flex-wrap: wrap;
  line-height: 1.3;
}

.user-type-label {
  color: #6c757d;
  font-size: 11px;
  font-weight: normal;
}

.no-name-indicator {
  color: #dc3545;
  font-size: 11px;
  font-weight: normal;
}

.discrepancy-indicator {
  color: #dc3545;
  font-size: 11px;
}

.admin-user-email {
  font-size: 12px;
  color: #666;
  margin: 0;
  word-break: break-word;
  line-height: 1.3;
}

.admin-user-stats {
  font-size: 11px;
  color: #888;
  display: flex;
  align-items: center;
  gap: 4px;
  flex-wrap: wrap;
  margin: 0;
  line-height: 1.3;
}

.admin-view-btn {
  background: #8C1515;
  color: white;
  border: none;
  padding: 8px 16px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 12px;
  transition: all 0.2s ease;
  min-width: 80px;
  flex-shrink: 0;
  height: 36px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.admin-view-btn:hover:not(:disabled) {
  background: #a01a1a;
  transform: translateY(-1px);
}

.admin-view-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
  background: #6c757d;
  transform: none;
}

/* FIXED: Improved expanded view with proper layout containment */
.admin-user-expanded {
  padding: 20px;
  background: #f8f9fa;
  border-top: 1px solid #e1e5e9;
  /* FIXED: Let content expand naturally */
  overflow: visible;
}

.admin-view-header {
  margin-bottom: 20px;
  padding-bottom: 10px;
  border-bottom: 2px solid #8C1515;
}

.admin-view-header h4 {
  color: #8C1515;
  margin: 0;
  font-size: 16px;
}

/* FIXED: Responsive grid that works with dynamic content */
.admin-data-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 15px;
  width: 100%;
  box-sizing: border-box;
  /* FIXED: Allow grid to expand with content */
  min-height: auto;
}

.admin-data-card {
  background: white;
  padding: 20px;
  border-radius: 8px;
  border-left: 4px solid #8C1515;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  transition: transform 0.2s ease;
  display: flex;
  flex-direction: column;
  box-sizing: border-box;
  /* FIXED: Remove height constraints to allow natural expansion */
}

.admin-data-card:hover {
  transform: translateY(-2px);
}

.admin-data-number {
  font-size: 32px;
  font-weight: bold;
  color: #8C1515;
  margin-bottom: 5px;
  line-height: 1;
}

.admin-data-label {
  font-size: 14px;
  color: #666;
  font-weight: 600;
  margin-bottom: 15px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  line-height: 1.2;
}

.admin-data-names {
  max-height: 150px;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
  flex: 1;
}

.admin-name-item {
  padding: 6px 10px;
  margin-bottom: 4px;
  background: #f8f9fa;
  border-radius: 4px;
  font-size: 12px;
  border-left: 3px solid #e1e5e9;
  transition: background-color 0.2s ease;
  line-height: 1.3;
}

.admin-name-item:hover {
  background: #e9ecef;
}

.admin-name-item.locked {
  background: #fff3cd;
  border-left-color: #ffc107;
  font-weight: 600;
}

/* FIXED: Match timestamp styles with proper layout */
.admin-match-with-timestamp {
  display: flex;
  flex-direction: column;
  gap: 2px;
  padding: 8px 10px;
  box-sizing: border-box;
}

.admin-match-name {
  font-size: 12px;
  font-weight: 600;
  color: #333;
  line-height: 1.3;
}

.admin-match-timestamp {
  font-size: 10px;
  color: #28a745;
  font-style: italic;
  font-weight: 500;
  line-height: 1.2;
}

.admin-discrepancy {
  margin-top: 10px;
  padding: 8px;
  background: #f8d7da;
  color: #721c24;
  border-radius: 4px;
  font-size: 11px;
  font-weight: 600;
}

.admin-no-activity {
  text-align: center;
  padding: 40px 20px;
  color: #666;
  background: white;
  border-radius: 8px;
  font-style: italic;
}

.admin-controls {
  margin-bottom: 20px;
}

.admin-filter-section {
  margin-top: 10px;
}

.admin-filter-dropdown {
  width: 100%;
  padding: 10px 12px;
  border: 2px solid #e1e5e9;
  border-radius: 8px;
  font-size: 14px;
  background: white;
  color: #333;
  cursor: pointer;
  transition: border-color 0.2s ease;
}

.admin-filter-dropdown:focus {
  outline: none;
  border-color: #8C1515;
}

.admin-filter-dropdown:hover {
  border-color: #999;
}

/* Ghost User Styles */
.admin-user-ghost {
  background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
  border-left: 4px solid #6c757d;
  opacity: 0.9;
}

.admin-user-ghost .admin-user-header {
  background: linear-gradient(135deg, #f1f3f4 0%, #e8eaed 100%);
}

.admin-user-ghost .admin-user-name {
  font-style: italic;
}

.admin-user-ghost .admin-view-btn {
  background: #6c757d;
  cursor: not-allowed;
}

.admin-user-ghost .admin-view-btn:hover {
  background: #6c757d;
  transform: none;
}

/* Inactive User Styles */
.admin-user-inactive {
  background: linear-gradient(135deg, #fff3cd 0%, #ffeaa7 100%);
  border-left: 4px solid #ffc107;
  opacity: 0.9;
}

.admin-user-inactive .admin-user-header {
  background: linear-gradient(135deg, #fff8e1 0%, #ffecb3 100%);
}

.admin-user-inactive .admin-user-name {
  font-style: italic;
  color: #856404;
}

.no-results {
  padding: 15px;
  text-align: center;
  color: #666;
  font-style: italic;
  font-size: 13px;
}

.admin-clear-search-link {
  background: none;
  border: none;
  color: #8C1515;
  text-decoration: underline;
  cursor: pointer;
  font-size: 12px;
  margin-left: 8px;
  padding: 0;
  margin-top: 8px;
  display: inline-block;
}

.admin-clear-search-link:hover {
  color: #a01a1a;
}

/* Search highlighting */
.admin-search-highlight {
  background: #fff3cd;
  color: #856404;
  font-weight: 600;
  padding: 1px 2px;
  border-radius: 2px;
}

/* Analytics match items with timestamps */
.admin-match-item-with-timestamp {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 10px 12px;
  margin-bottom: 6px;
  background: #f8f9fa;
  border-radius: 4px;
  font-size: 13px;
  border-left: 3px solid #28a745;
  transition: background-color 0.2s ease;
}

.admin-match-item-with-timestamp:hover {
  background: #e9ecef;
}

.admin-match-pair {
  font-weight: 600;
  color: #333;
  flex: 1;
}

.admin-match-time {
  font-size: 11px;
  color: #28a745;
  font-style: italic;
  font-weight: 500;
  margin-left: 10px;
  white-space: nowrap;
}

/* FIXED: Mobile responsive improvements */
@media (max-width: 768px) {
  .admin-data-grid {
    grid-template-columns: 1fr;
    gap: 12px;
  }
  
  .admin-user-header {
    flex-direction: column;
    align-items: flex-start;
    gap: 10px;
    padding: 12px;
    min-height: 90px;
  }
  
  .admin-user-info {
    width: 100%;
  }
  
  .admin-view-btn {
    align-self: flex-end;
    width: auto;
  }
  
  .admin-data-card {
    padding: 15px;
  }
  
  .admin-data-number {
    font-size: 28px;
  }
  
  .admin-data-label {
    font-size: 12px;
  }
  
  .admin-user-expanded {
    padding: 15px;
  }
  
  .admin-match-item-with-timestamp {
    flex-direction: column;
    align-items: flex-start;
    gap: 4px;
  }
  
  .admin-match-time {
    margin-left: 0;
    font-size: 10px;
  }
}

@media (max-width: 480px) {
  .admin-user-header {
    padding: 12px;
    min-height: 100px;
  }
  
  .admin-user-name {
    font-size: 12px;
  }
  
  .admin-user-email {
    font-size: 11px;
    word-break: break-all;
  }
  
  .admin-user-stats {
    font-size: 10px;
    flex-direction: column;
    align-items: flex-start;
    gap: 2px;
  }
  
  .admin-view-btn {
    font-size: 11px;
    padding: 6px 12px;
    min-width: 70px;
    height: 32px;
  }
  
  .admin-data-card {
    padding: 12px;
  }
  
  .admin-data-number {
    font-size: 24px;
  }
  
  .admin-data-label {
    font-size: 11px;
    margin-bottom: 10px;
  }
  
  .admin-name-item {
    font-size: 11px;
    padding: 4px 8px;
  }
  
  .admin-match-item-with-timestamp {
    padding: 8px 10px;
  }
  
  .admin-match-pair {
    font-size: 12px;
  }
  
  .admin-match-time {
    font-size: 9px;
  }
}

================
File: src/styles/admin/admin-responsive.css
================
/* Admin Mobile Responsiveness */

/* Mobile responsiveness for access denied */
@media (max-width: 768px) {
    .admin-access-denied {
      min-height: 50vh;
      padding: 15px;
    }
    
    .access-denied-card {
      padding: 30px 20px;
    }
    
    .access-denied-card h2 {
      font-size: 20px;
    }
    
    .access-denied-card p {
      font-size: 13px;
    }
  
    .header-actions {
      flex-direction: row;
      gap: 6px;
    }
    
    .admin-toggle-btn, .admin-refresh-btn {
      font-size: 11px;
      padding: 5px 8px;
    }
    
    .admin-title-row {
      flex-direction: column;
      align-items: flex-start;
      gap: 10px;
    }
  
    /* Class Navigation Mobile */
    .admin-class-nav {
      flex-direction: column;
      gap: 8px;
    }
  
    .admin-class-btn {
      width: 100%;
      min-width: auto;
      padding: 10px 16px;
      font-size: 13px;
    }
  
    /* Class Headers Mobile */
    .admin-class-header {
      padding: 15px;
    }
  
    .admin-class-header h4 {
      font-size: 16px;
    }
  
    .admin-class-stats-summary {
      gap: 15px;
      justify-content: space-around;
    }
  
    .class-stat {
      font-size: 12px;
    }
  
    .class-stat strong {
      font-size: 14px;
    }
  
    .admin-class-users-header {
      flex-direction: column;
      align-items: flex-start;
      gap: 8px;
      padding: 12px 15px;
    }
  
    .admin-class-users-header h4 {
      font-size: 14px;
    }
  
    .admin-class-users-summary {
      gap: 10px;
      font-size: 11px;
    }
    
    .admin-definitions {
      padding: 12px;
    }
    
    .admin-definitions p {
      font-size: 12px;
      margin: 6px 0;
    }
    
    .admin-nav {
      gap: 6px;
      flex-direction: column;
    }
    
    .admin-nav-btn {
      font-size: 12px;
      padding: 8px 12px;
      width: 100%;
      text-align: center;
      min-width: auto;
    }
    
    .admin-quick-insights {
      grid-template-columns: 1fr;
      gap: 12px;
    }
    
    .admin-insight-card {
      padding: 15px;
    }
    
    .admin-data-grid {
      grid-template-columns: 1fr;
      gap: 12px;
    }
    
    .admin-data-card {
      padding: 15px;
    }
    
    .admin-data-number {
      font-size: 28px;
    }
    
    .admin-data-label {
      font-size: 12px;
    }
    
    .admin-user-expanded {
      padding: 15px;
    }
    
    .admin-user-header {
      flex-direction: column;
      align-items: flex-start;
      gap: 10px;
      padding: 12px;
    }
    
    .admin-user-info {
      width: 100%;
    }
    
    .admin-user-name {
      font-size: 13px;
      flex-wrap: wrap;
      gap: 4px;
    }
    
    .admin-view-btn {
      align-self: flex-end;
      width: auto;
    }
  
    .admin-filter-dropdown {
      padding: 8px 10px;
      font-size: 13px;
    }
  
    .admin-users-container {
      max-height: 60vh;
    }
  
    .user-type-label, .no-name-indicator, .discrepancy-indicator {
      font-size: 10px;
    }
  
    .admin-pagination-info {
      font-size: 11px;
    }
  
    .admin-search-clear-btn {
      right: 12px;
      width: 28px;
      height: 28px;
      font-size: 20px;
    }
    
    .admin-search-hint {
      font-size: 9px;
      padding: 5px 8px;
    }
    
    .admin-search-input {
      padding: 10px 35px 10px 12px;
      font-size: 13px;
    }
    
    .admin-users .no-results {
      padding: 15px;
      font-size: 13px;
    }
    
    .admin-users .no-results small {
      font-size: 11px;
    }
  }
  
  @media (max-width: 480px) {
    .header-actions {
      width: 100%;
      justify-content: space-between;
    }
    
    .admin-toggle-btn, .admin-refresh-btn {
      font-size: 10px;
      padding: 4px 6px;
    }
    
    .admin-title-row h3 {
      font-size: 16px;
    }
  
    .admin-class-btn {
      padding: 8px 12px;
      font-size: 12px;
    }
  
    .admin-class-header {
      padding: 12px;
    }
  
    .admin-class-header h4 {
      font-size: 15px;
    }
  
    .admin-class-stats-summary {
      gap: 10px;
    }
  
    .class-stat {
      font-size: 11px;
    }
  
    .class-stat strong {
      font-size: 13px;
    }
  
    .admin-class-users-header {
      padding: 10px 12px;
    }
  
    .admin-class-users-header h4 {
      font-size: 13px;
    }
  
    .admin-class-users-summary {
      gap: 8px;
      font-size: 10px;
    }
    
    .admin-definitions {
      padding: 10px;
    }
    
    .admin-definitions p {
      font-size: 11px;
      margin: 5px 0;
    }
    
    .admin-nav {
      flex-direction: column;
      gap: 4px;
    }
    
    .admin-nav-btn {
      width: 100%;
      text-align: center;
      padding: 10px 12px;
      font-size: 13px;
    }
    
    .admin-search-input {
      padding: 8px 38px 8px 10px;
      font-size: 12px;
    }
    
    .admin-user-header {
      padding: 12px;
    }
    
    .admin-user-name {
      font-size: 12px;
    }
    
    .admin-user-email {
      font-size: 11px;
      word-break: break-all;
    }
    
    .admin-user-stats {
      font-size: 10px;
      flex-direction: column;
      align-items: flex-start;
      gap: 2px;
    }
    
    .admin-view-btn {
      font-size: 11px;
      padding: 6px 12px;
      min-width: 70px;
    }
    
    .admin-data-card {
      padding: 12px;
    }
    
    .admin-data-number {
      font-size: 24px;
    }
    
    .admin-data-label {
      font-size: 11px;
      margin-bottom: 10px;
    }
    
    .admin-name-item {
      font-size: 11px;
      padding: 4px 8px;
    }
  
    .admin-filter-dropdown {
      padding: 6px 8px;
      font-size: 12px;
    }
    
    .admin-list-item {
      flex-direction: column;
      align-items: flex-start;
      gap: 4px;
    }
    
    .admin-inactive-header {
      flex-direction: column;
      align-items: flex-start;
      gap: 4px;
    }
  
    .admin-users-container {
      max-height: 55vh;
    }
  
    .user-type-label, .no-name-indicator, .discrepancy-indicator {
      font-size: 9px;
    }
  
    .admin-pagination-info {
      font-size: 10px;
    }
  
    /* Optimize touch targets for mobile */
    .admin-user-item {
      min-height: 90px;
    }
  
    .admin-view-btn {
      min-height: 36px;
      min-width: 80px;
    }
  
    .admin-class-btn {
      min-height: 44px;
    }
  
    .admin-search-clear-btn {
      width: 32px;
      height: 32px;
      font-size: 22px;
    }
    
    .admin-search-hint {
      font-size: 8px;
      padding: 4px 6px;
    }
  }
  
  /* Performance optimizations for large datasets */
  @media (hover: none) and (pointer: coarse) {
    .admin-users-container {
      -webkit-overflow-scrolling: touch;
      scroll-behavior: smooth;
    }
    
    .admin-user-header:active {
      background: #e9ecef;
    }
    
    .admin-view-btn:active {
      transform: scale(0.98);
    }
    
    .admin-data-card:active {
      transform: scale(0.98);
    }
  
    .admin-class-btn:active {
      transform: scale(0.98);
    }
  
    .admin-search-clear-btn:active {
      transform: translateY(-50%) scale(0.9);
    }
  }
  
  /* Accessibility improvements */
  @media (prefers-reduced-motion: reduce) {
    .admin-user-expanded {
      animation: none;
    }
    
    .admin-data-card:hover, .admin-insight-card:hover {
      transform: none;
    }
    
    .admin-view-btn:hover:not(:disabled), .admin-refresh-btn:hover:not(:disabled), .admin-class-btn:hover:not(:disabled) {
      transform: none;
    }
  }
  
  /* High contrast mode support */
  @media (prefers-contrast: high) {
    .admin-user-item {
      border: 2px solid #000;
    }
    
    .admin-view-btn, .admin-class-btn, .admin-refresh-btn {
      border: 2px solid #000;
    }
    
    .admin-class-nav .admin-class-btn.active {
      border: 3px solid #000;
    }
  }
  
  /* Focus styles for keyboard navigation */
  .admin-class-btn:focus,
  .admin-view-btn:focus {
    outline: 2px solid #8C1515;
    outline-offset: 2px;
  }
  
  .admin-search-input:focus,
  .admin-filter-dropdown:focus {
    box-shadow: 0 0 0 3px rgba(140, 21, 21, 0.2);
  }

================
File: src/styles/dashboard/dashboard-components.css
================
/* Dashboard Component Styles */

/* Crush count section */
.crush-count-section {
    padding: 15px;
    background: linear-gradient(135deg, #fff3cd 0%, #ffeaa7 100%);
    border-radius: 8px;
    border-left: 4px solid #f39c12;
    text-align: left;
    flex-shrink: 0;
    margin-bottom: 20px;
  }
  
  .crush-count-section h2 {
    color: #d68910;
    margin: 0;
    font-size: 18px;
    font-weight: normal;
    font-style: italic;
  }
  
  /* Matches section */
  .matches-section {
    padding: 15px;
    background: linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%);
    border-radius: 8px;
    border-left: 4px solid #28a745;
    text-align: left;
    flex-shrink: 0;
  }
  
  .matches-section h2 {
    color: #155724;
    margin-bottom: 15px;
    font-size: 18px;
    font-weight: normal;
    font-style: italic;
  }
  
  .matches-list {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 12px;
    margin-top: 15px;
  }
  
  .match-item {
    background: white;
    padding: 15px;
    border-radius: 8px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    border-left: 4px solid #28a745;
  }
  
  .match-name {
    font-size: 16px;
    font-weight: 600;
    color: #155724;
    margin-bottom: 6px;
  }
  
  .match-email {
    font-size: 12px;
    color: #6c757d;
    font-family: 'Courier New', monospace;
    word-break: break-all;
  }
  
  .no-matches {
    margin-top: 8px;
    padding: 8px;
    background: #fff3cd;
    color: #856404;
    border-radius: 6px;
    font-weight: 500;
    font-size: 13px;
  }
  
  /* Selection counter */
  .selection-counter {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    background: #8C1515;
    color: white;
    padding: 6px 12px;
    border-radius: 20px;
    font-weight: 600;
    font-size: 13px;
    flex-shrink: 0;
  }
  
  .submitted-badge {
    background: rgba(255, 255, 255, 0.3);
    padding: 2px 6px;
    border-radius: 12px;
    font-size: 10px;
    font-weight: 700;
  }
  
  .updating-badge {
    background: rgba(255, 255, 255, 0.3);
    padding: 2px 6px;
    border-radius: 12px;
    font-size: 10px;
    font-weight: 700;
    animation: pulse 1.5s ease-in-out infinite alternate;
  }
  
  .unsaved-badge {
    background: #dc3545;
    padding: 2px 6px;
    border-radius: 12px;
    font-size: 10px;
    font-weight: 700;
    color: white;
    animation: pulse 1.5s ease-in-out infinite alternate;
  }
  
  /* Locked crush styles */
  .locked-badge {
    background: #dc3545;
    padding: 2px 6px;
    border-radius: 12px;
    font-size: 10px;
    font-weight: 700;
    color: white;
  }
  
  /* Selected names section */
  .selected-names {
    padding: 15px;
    background: #f8f9fa;
    border-radius: 8px;
    border-left: 4px solid #8C1515;
    flex-shrink: 0;
  }
  
  .selected-names h3 {
    color: #8C1515;
    margin-bottom: 12px;
    font-size: 14px;
    font-weight: 600;
  }
  
  .name-chips {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
    gap: 8px;
  }
  
  .name-chip {
    display: flex;
    align-items: center;
    justify-content: space-between;
    background: #8C1515;
    color: white;
    padding: 8px 12px;
    border-radius: 6px;
    font-size: 12px;
    font-weight: 500;
    min-height: 32px;
    width: 100%;
    border: 2px solid transparent;
    transition: all 0.2s ease;
  }
  
  .name-chip.readonly {
    background: #6c757d;
    opacity: 0.8;
  }
  
  .name-chip.locked {
    background: #8C1515;
    opacity: 1;
    border: 2px solid transparent;
  }
  
  .name-chip span {
    flex: 1;
    text-align: left;
    margin-right: 6px;
  }
  
  .remove-btn {
    background: rgba(255, 255, 255, 0.3);
    color: white;
    border: none;
    width: 20px;
    height: 20px;
    border-radius: 3px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    font-size: 14px;
    font-weight: bold;
    flex-shrink: 0;
  }
  
  .remove-btn:hover {
    background: rgba(255, 255, 255, 0.5);
  }
  
  .remove-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
  
  .lock-icon {
    font-size: 12px;
    opacity: 0.8;
    width: 20px;
    height: 20px;
    display: flex;
    align-items: right;
    justify-content: right;
    flex-shrink: 0;
  }
  
  /* Search section */
  .search-section {
    flex-shrink: 0;
  }
  
  .search-input {
    width: 100%;
    padding: 12px 40px 12px 15px;
    border: 2px solid #e1e5e9;
    border-radius: 8px;
    font-size: 14px;
    transition: border-color 0.2s ease;
    box-sizing: border-box;
  }
  
  .search-input:focus {
    outline: none;
    border-color: #8C1515;
  }
  
  .search-input-container {
    position: relative;
    width: 100%;
  }
  
  .search-clear-btn {
    position: absolute;
    right: 10px;
    top: 50%;
    transform: translateY(-50%);
    background: none;
    border: none;
    font-size: 18px;
    color: #666;
    cursor: pointer;
    padding: 4px;
    border-radius: 50%;
    width: 24px;
    height: 24px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
  }
  
  .search-clear-btn:hover {
    background: #f0f0f0;
    color: #333;
  }
  
  .search-hint {
    text-align: center;
    padding: 6px 12px;
    font-size: 11px;
    color: #666;
    background: #f8f9fa;
    border-radius: 4px;
    margin-top: 8px;
    border-left: 3px solid #8C1515;
  }
  
  /* Available names section - Enhanced for large lists */
  .available-names {
    flex: 1;
    display: flex;
    flex-direction: column;
    min-height: 0;
  }
  
  .available-names h3 {
    color: #8C1515;
    margin-bottom: 15px;
    font-size: 16px;
    font-weight: 600;
    flex-shrink: 0;
  }
  
  /* Names list - Optimized for large datasets */
  .names-simple-list {
    flex: 1;
    overflow-y: auto;
    border: 1px solid #e1e5e9;
    border-radius: 8px;
    background: white;
    /* Fixed height for virtual scrolling */
    min-height: 400px;
    max-height: 60vh;
    /* Optimize for smooth scrolling */
    -webkit-overflow-scrolling: touch;
    scroll-behavior: smooth;
    /* Enable hardware acceleration */
    transform: translateZ(0);
    will-change: scroll-position;
    contain: layout style paint;
  }
  
  .name-list-item {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 12px 15px;
    border-bottom: 1px solid #f0f0f0;
    cursor: pointer;
    transition: all 0.2s ease;
    font-size: 14px;
    /* Fixed height for virtual scrolling */
    height: 48px;
    min-height: 48px;
    box-sizing: border-box;
    /* Optimize for large lists */
    contain: layout style paint;
  }
  
  .name-list-item:last-child {
    border-bottom: none;
  }
  
  .name-list-item:hover:not(.disabled) {
    background: #f8f9fa;
  }
  
  .name-list-item.disabled {
    opacity: 0.6;
    cursor: not-allowed;
    background: #f9f9f9;
  }
  
  .name-text {
    flex: 1;
    text-align: left;
    font-weight: 500;
  }
  
  .add-btn {
    font-weight: bold;
    font-size: 18px;
    color: #8C1515;
    width: 24px;
    height: 24px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    background: rgba(140, 21, 21, 0.1);
    transition: all 0.2s ease;
  }
  
  .add-btn:hover {
    background: rgba(140, 21, 21, 0.2);
    transform: scale(1.1);
  }
  
  .no-results {
    padding: 20px;
    text-align: center;
    color: #666;
    font-style: italic;
    font-size: 14px;
    line-height: 1.4;
  }
  
  .no-results small {
    display: block;
    margin: 8px 0;
    color: #888;
    font-size: 12px;
  }
  
  .clear-search-link {
    background: none;
    border: none;
    color: #8C1515;
    text-decoration: underline;
    cursor: pointer;
    font-size: 13px;
    margin-left: 8px;
    padding: 0;
    margin-top: 8px;
    display: inline-block;
  }
  
  .clear-search-link:hover {
    color: #a01a1a;
  }
  
  /* Action section */
  .action-section {
    text-align: center;
    padding-top: 15px;
    border-top: 1px solid #e1e5e9;
    flex-shrink: 0;
  }
  
  .action-buttons {
    display: flex;
    gap: 12px;
    justify-content: center;
    flex-wrap: wrap;
  }
  
  .save-draft-btn, .submit-btn, .update-btn {
    padding: 12px 20px;
    border-radius: 8px;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
    border: none;
    min-width: 120px;
  }
  
  .save-draft-btn {
    background: #6c757d;
    color: white;
  }
  
  .save-draft-btn:hover:not(:disabled) {
    background: #5a6268;
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(108, 117, 125, 0.3);
  }
  
  .submit-btn, .update-btn {
    background: #8C1515;
    color: white;
    min-width: 160px;
  }
  
  .submit-btn:hover:not(:disabled), .update-btn:hover:not(:disabled) {
    background: #a01a1a;
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(140, 21, 21, 0.3);
  }
  
  .save-draft-btn:disabled, .submit-btn:disabled, .update-btn:disabled {
    opacity: 0.6;
    cursor: not-allowed;
    transform: none;
    background: #6c757d;
  }
  
  .submitted-message {
    text-align: center;
    padding: 20px 15px;
  }
  
  .submitted-message h3 {
    color: #28a745;
    margin-bottom: 8px;
    font-size: 16px;
  }
  
  .submitted-message p {
    color: #666;
    font-size: 14px;
    line-height: 1.4;
  }
  
  /* Search highlighting */
  .search-highlight {
    background: #fff3cd;
    color: #856404;
    font-weight: 600;
    padding: 1px 2px;
    border-radius: 2px;
  }
  
  .search-loading {
    text-align: center;
    padding: 8px;
    font-size: 12px;
    color: #666;
    font-style: italic;
  }

================
File: src/styles/dashboard/dashboard-layout.css
================
/* Dashboard Layout Styles */
.dashboard-container {
    min-height: 100vh;
    padding: 10px;
    background-color: #f8f9fa;
  }
  
  .dashboard-card {
    max-width: 900px;
    margin: 0 auto;
    background: white;
    border-radius: 12px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    overflow: hidden;
    min-height: calc(100vh - 20px);
    display: flex;
    flex-direction: column;
  }
  
  .dashboard-header {
    background: #8C1515;
    color: white;
    padding: 15px 20px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-wrap: wrap;
    gap: 10px;
    flex-shrink: 0;
  }
  
  .dashboard-header h1 {
    font-size: 20px;
    font-weight: 700;
  }
  
  .user-info {
    display: flex;
    align-items: center;
    gap: 12px;
    flex-wrap: wrap;
  }
  
  .user-info span {
    font-size: 12px;
    opacity: 0.9;
  }
  
  .logout-btn {
    background: rgba(255, 255, 255, 0.2);
    color: white;
    border: 1px solid rgba(255, 255, 255, 0.3);
    padding: 6px 12px;
    border-radius: 6px;
    cursor: pointer;
    font-size: 12px;
    transition: all 0.2s ease;
  }
  
  .logout-btn:hover {
    background: rgba(255, 255, 255, 0.3);
  }
  
  .dashboard-content {
    padding: 20px;
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 20px;
  }
  
  .header-section {
    flex-shrink: 0;
  }
  
  .dashboard-content h2 {
    color: #8C1515;
    margin-bottom: 8px;
    font-size: 18px;
  }
  
  .dashboard-content > p {
    color: #666;
    margin-bottom: 15px;
    line-height: 1.5;
    font-size: 14px;
  }
  
  .submitted-notice {
    background: #d4edda;
    color: #155724;
    padding: 10px 12px;
    border-radius: 8px;
    border-left: 4px solid #28a745;
    font-weight: 500;
    margin-top: 8px;
    font-size: 14px;
  }
  
  /* User info styles */
  .user-details {
    display: flex;
    align-items: center;
    gap: 10px;
  }
  
  .profile-pic {
    width: 32px;
    height: 32px;
    border-radius: 50%;
    border: 2px solid rgba(255, 255, 255, 0.3);
  }
  
  .user-name {
    font-weight: 600;
    font-size: 12px;
  }
  
  .user-email {
    font-size: 10px;
    opacity: 0.8;
  }
  
  /* Instructions list styling */
  .instructions {
    margin-bottom: 15px;
  }
  
  .instructions ol {
    padding-left: 20px;
    margin: 0;
  }
  
  .instructions li {
    margin-bottom: 8px;
    line-height: 1.5;
    font-size: 14px;
    color: #666;
  }
  
  .instructions em {
    font-style: italic;
    color: #8C1515;
    font-weight: 600;
  }
  
  /* Class indicator improvements */
  .class-indicator {
    margin-bottom: 15px;
    text-align: center;
  }
  
  .class-badge {
    display: inline-block;
    background: linear-gradient(135deg, #8C1515 0%, #B83A4B 100%);
    color: white;
    padding: 8px 16px;
    border-radius: 20px;
    font-size: 13px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    box-shadow: 0 2px 4px rgba(140, 21, 21, 0.3);
  }

================
File: src/styles/dashboard/dashboard-responsive.css
================
/* Dashboard Mobile Responsiveness */

@media (max-width: 768px) {
    .dashboard-container {
      padding: 5px;
    }
    
    .dashboard-header {
      padding: 12px 15px;
      flex-direction: column;
      align-items: flex-start;
      gap: 8px;
    }
    
    .user-info {
      width: 100%;
      justify-content: space-between;
      gap: 8px;
    }
    
    .dashboard-content {
      padding: 15px;
      gap: 15px;
    }
    
    /* Increase height for mobile to show more names */
    .names-simple-list {
      max-height: 60vh;
    }
    
    .name-list-item {
      padding: 14px 12px;
      font-size: 13px;
      min-height: 48px;
    }
    
    .name-text {
      font-weight: 500;
    }
    
    .add-btn {
      width: 28px;
      height: 28px;
      font-size: 20px;
    }
    
    .user-details {
      flex-direction: row;
      align-items: center;
      gap: 8px;
    }
  
    .name-chips {
      grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
      gap: 6px;
    }
  
    .name-chip {
      font-size: 11px;
      padding: 6px 10px;
      min-height: 28px;
    }
  
    .dashboard-content h2 {
      font-size: 16px;
    }
  
    .action-buttons {
      flex-direction: column;
      align-items: center;
      gap: 8px;
    }
  
    .save-draft-btn, .submit-btn, .update-btn {
      width: 100%;
      max-width: 250px;
      padding: 12px 16px;
    }
  
    .submitted-message {
      padding: 15px 10px;
    }
  
    .matches-section {
      padding: 12px;
    }
  
    .matches-section h2 {
      font-size: 16px;
    }
  
    .matches-list {
      grid-template-columns: 1fr;
      gap: 10px;
    }
  
    .match-item {
      padding: 12px;
    }
  
    .match-name {
      font-size: 14px;
    }
  
    .selected-names {
      padding: 12px;
    }
  
    .crush-count-section {
      padding: 12px;
      margin-bottom: 15px;
    }
    
    .crush-count-section h2 {
      font-size: 16px;
    }
  
    .instructions ol {
      padding-left: 16px;
    }
    
    .instructions li {
      font-size: 13px;
      margin-bottom: 6px;
    }
  
    .locked-badge {
      font-size: 9px;
      padding: 1px 4px;
    }
    
    .lock-icon {
      font-size: 10px;
    }
  
    .search-input-container {
      margin-bottom: 10px;
    }
    
    .search-clear-btn {
      right: 12px;
      width: 28px;
      height: 28px;
      font-size: 20px;
    }
    
    .search-hint {
      font-size: 10px;
      padding: 5px 8px;
    }
    
    .names-simple-list {
      max-height: 50vh;
      min-height: 300px;
    }
    
    .name-list-item {
      height: 52px;
      min-height: 52px;
      padding: 14px 12px;
      font-size: 13px;
    }
    
    .no-results {
      padding: 15px;
      font-size: 13px;
    }
    
    .no-results small {
      font-size: 11px;
    }
  }
  
  @media (max-width: 480px) {
    .dashboard-card {
      border-radius: 8px;
      min-height: calc(100vh - 10px);
    }
    
    .dashboard-container {
      padding: 5px;
    }
  
    .dashboard-header h1 {
      font-size: 18px;
    }
  
    .dashboard-content h2 {
      font-size: 15px;
    }
  
    .profile-pic {
      width: 28px;
      height: 28px;
    }
  
    .user-name {
      font-size: 11px;
    }
  
    .user-email {
      font-size: 9px;
    }
  
    .selected-names {
      padding: 10px;
    }
  
    .search-input {
      padding: 12px 15px;
      font-size: 14px;
    }
  
    /* Optimize for small screens with large lists */
    .names-simple-list {
      max-height: 65vh;
    }
  
    .name-list-item {
      padding: 16px 12px;
      font-size: 14px;
      min-height: 52px;
    }
  
    .name-text {
      font-weight: 500;
    }
  
    .add-btn {
      width: 32px;
      height: 32px;
      font-size: 22px;
    }
  
    .name-chips {
      grid-template-columns: 1fr;
      gap: 6px;
    }
  
    .name-chip {
      min-height: 26px;
      font-size: 10px;
    }
  
    .action-buttons {
      gap: 6px;
    }
  
    .save-draft-btn, .submit-btn, .update-btn {
      padding: 12px 16px;
      font-size: 14px;
    }
  
    .submitted-message h3 {
      font-size: 15px;
    }
  
    .submitted-message p {
      font-size: 13px;
    }
  
    .matches-section h2 {
      font-size: 15px;
    }
  
    .crush-count-section h2 {
      font-size: 15px;
    }
  
    .locked-badge {
      font-size: 8px;
    }
  
    .lock-icon {
      font-size: 9px;
    }
  
    .names-simple-list {
      max-height: 45vh;
      min-height: 280px;
    }
    
    .name-list-item {
      height: 56px;
      min-height: 56px;
      padding: 16px 12px;
      font-size: 14px;
    }
    
    .search-clear-btn {
      width: 32px;
      height: 32px;
      font-size: 22px;
    }
    
    .search-hint {
      font-size: 9px;
      padding: 4px 6px;
    }
  }
  
  /* Smooth scrolling optimization for touch devices */
  @media (hover: none) and (pointer: coarse) {
    .names-simple-list {
      -webkit-overflow-scrolling: touch;
      scroll-behavior: smooth;
    }
  
    .name-list-item {
      /* Larger touch targets for mobile */
      min-height: 48px;
      padding: 16px 15px;
    }
  
    .name-list-item:active {
      background: #e9ecef;
      transform: scale(0.98);
    }
  
    .add-btn:active {
      transform: scale(0.9);
    }
  
    .search-clear-btn:active {
      transform: translateY(-50%) scale(0.9);
    }
  }
  
  /* Performance optimizations for large lists */
  .names-simple-list {
    /* Enable hardware acceleration for smooth scrolling */
    transform: translateZ(0);
    will-change: scroll-position;
  }
  
  .name-list-item {
    /* Optimize repaints */
    contain: layout style paint;
  }

================
File: src/styles/base.css
================
/* Reset and base styles */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }
  
  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
      'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
      sans-serif;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    background-color: #f8f9fa;
    color: #333;
  }
  
  .App {
    min-height: 100vh;
  }
  
  /* Loading spinner */
  .loading {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    font-size: 18px;
    color: #666;
  }
  
  button {
    border-radius: 8px;
    border: 1px solid transparent;
    padding: 0.6em 1.2em;
    font-size: 1em;
    font-weight: 500;
    font-family: inherit;
    cursor: pointer;
    transition: border-color 0.25s;
  }
  
  @keyframes pulse {
    from {
      opacity: 0.6;
    }
    to {
      opacity: 1;
    }
  }

================
File: src/types/index.ts
================
export type UserClass = 'gsb' | 'undergrad';

export interface MatchInfo {
    name: string;
    email: string;
    matchedAt?: any; // Firebase Timestamp or Date
}

export interface UserData {
    uid: string;
    email: string;
    name: string;
    photoURL: string;
    crushes: string[];
    lockedCrushes: string[];
    matches: MatchInfo[];
    crushCount: number;
    userClass: UserClass;
    createdAt: any;
    updatedAt: any;
    lastLogin: any;
}

export interface UserWithId extends UserData {
    id: string;
}

export interface InactiveUser extends UserData {
    isInactive: boolean;
}

export interface GhostUser extends UserData {
    isGhost: boolean;
}

export interface CrusherInfo {
    name: string;
    email: string;
}

export interface ClassAnalyticsData {
    totalUsers: number;
    totalClassSize: number;
    totalMatches: number;
    matchedPairs: string[];
    totalCrushes: number;
    peopleWithCrushes: number;
    avgCrushes: number;
    usersWithCrushes: number;
    usersWithMatches: number;
    participationRate: number;
    classParticipationRate: number;
    orphanedCrushes: string[];
    topCrushReceivers: Array<{ name: string; count: number; crushers: string[] }>;
    topCrushSenders: Array<{ name: string; count: number; crushNames: string[] }>;
    inactiveReceivers: Array<{
        name: string;
        email: string;
        crushCount: number;
        reason: string;
        crushers: CrusherInfo[]
    }>;
    activeUsersLast24h: number;
}

export type ViewMode = 'analytics' | 'users';
export type UserFilter = 'all' | 'active' | 'inactive' | 'ghost';

================
File: src/utils/adminUtils.ts
================
import type { UserData, UserClass } from '../types/userTypes';

interface InactiveUser extends UserData {
    isInactive: boolean;
}

interface GhostUser extends UserData {
    isGhost: boolean;
}

// Helper function to normalize names for case-insensitive comparison
export function normalizeName(name: string): string {
    if (!name || typeof name !== 'string') return '';

    return name
        .normalize('NFD')
        .replace(/[\u0300-\u036f]/g, '')
        .toLowerCase()
        .trim()
        .replace(/[^\w\s]/g, ' ')
        .replace(/\s+/g, ' ')
        .trim();
}

// Enhanced function to find the best matching user for a crush name
export function findUserByName(
    crushName: string,
    allUsers: (UserData | InactiveUser | GhostUser)[],
    userClass?: UserClass
): UserData | InactiveUser | GhostUser | null {
    if (!crushName || !crushName.trim()) return null;

    const normalizedCrush = normalizeName(crushName);

    // Filter by class if specified
    const filteredUsers = userClass
        ? allUsers.filter(user => (user.userClass || 'gsb') === userClass)
        : allUsers;

    // Try exact match on name field
    let match = filteredUsers.find(user =>
        user.name &&
        normalizeName(user.name) === normalizedCrush
    );

    if (match) return match;

    // Try partial match (first and last name only)
    const crushParts = normalizedCrush.split(' ');
    if (crushParts.length >= 2) {
        const crushFirstLast = `${crushParts[0]} ${crushParts[crushParts.length - 1]}`;

        match = filteredUsers.find(user => {
            if (user.name) {
                const nameParts = normalizeName(user.name).split(' ');
                if (nameParts.length >= 2) {
                    const nameFirstLast = `${nameParts[0]} ${nameParts[nameParts.length - 1]}`;
                    return nameFirstLast === crushFirstLast;
                }
            }
            return false;
        });
    }

    return match || null;
}

// Helper function to get user's identity name
export function getUserIdentityName(user: UserData | InactiveUser | GhostUser): string {
    return user.name || '';
}

================
File: src/utils/index.ts
================
import type { UserData, UserClass, InactiveUser, GhostUser } from '../types';

// Helper function to normalize names for case-insensitive comparison
export function normalizeName(name: string): string {
    if (!name || typeof name !== 'string') return '';

    return name
        .normalize('NFD')
        .replace(/[\u0300-\u036f]/g, '')
        .toLowerCase()
        .trim()
        .replace(/[^\w\s]/g, ' ')
        .replace(/\s+/g, ' ')
        .trim();
}

// Enhanced function to find the best matching user for a crush name
export function findUserByName(
    crushName: string,
    allUsers: (UserData | InactiveUser | GhostUser)[],
    userClass?: UserClass
): UserData | InactiveUser | GhostUser | null {
    if (!crushName || !crushName.trim()) return null;

    const normalizedCrush = normalizeName(crushName);

    // Filter by class if specified
    const filteredUsers = userClass
        ? allUsers.filter(user => (user.userClass || 'gsb') === userClass)
        : allUsers;

    // Try exact match on name field
    let match = filteredUsers.find(user =>
        user.name &&
        normalizeName(user.name) === normalizedCrush
    );

    if (match) return match;

    // Try partial match (first and last name only)
    const crushParts = normalizedCrush.split(' ');
    if (crushParts.length >= 2) {
        const crushFirstLast = `${crushParts[0]} ${crushParts[crushParts.length - 1]}`;

        match = filteredUsers.find(user => {
            if (user.name) {
                const nameParts = normalizeName(user.name).split(' ');
                if (nameParts.length >= 2) {
                    const nameFirstLast = `${nameParts[0]} ${nameParts[nameParts.length - 1]}`;
                    return nameFirstLast === crushFirstLast;
                }
            }
            return false;
        });
    }

    return match || null;
}

// Helper function to get user's identity name
export function getUserIdentityName(user: UserData | InactiveUser | GhostUser): string {
    return user.name || '';
}

// Fast name matching function optimized for first/last name searches
export const matchesSearchTerm = (searchableText: string, searchTerm: string): { matches: boolean; score: number } => {
    if (!searchTerm.trim()) return { matches: true, score: 0 };

    const normalizeText = (text: string) => text.toLowerCase().trim();
    const normalizedText = normalizeText(searchableText);
    const normalizedSearch = normalizeText(searchTerm);

    // Exact substring match (highest priority)
    if (normalizedText.includes(normalizedSearch)) {
        return { matches: true, score: 100 };
    }

    const textParts = normalizedText.split(' ').filter(Boolean);
    const searchParts = normalizedSearch.split(' ').filter(Boolean);

    // First + Last name matching (most common use case)
    if (searchParts.length >= 2) {
        const searchFirst = searchParts[0];
        const searchLast = searchParts[searchParts.length - 1];

        if (textParts.length >= 2) {
            const textFirst = textParts[0];
            const textLast = textParts[textParts.length - 1];

            // Exact first + last match
            if (textFirst === searchFirst && textLast === searchLast) {
                return { matches: true, score: 95 };
            }

            // Partial first + exact last
            if (textFirst.startsWith(searchFirst) && textLast === searchLast) {
                return { matches: true, score: 90 };
            }

            // Exact first + partial last
            if (textFirst === searchFirst && textLast.startsWith(searchLast)) {
                return { matches: true, score: 85 };
            }
        }
    }

    // Single term matching
    if (searchParts.length === 1) {
        const searchTerm = searchParts[0];

        // Check if any text part starts with search term
        if (textParts.some(part => part.startsWith(searchTerm))) {
            return { matches: true, score: 80 };
        }
    }

    // Multi-word progressive matching
    let textIndex = 0;
    let matchedParts = 0;

    for (const searchPart of searchParts) {
        for (let i = textIndex; i < textParts.length; i++) {
            if (textParts[i].startsWith(searchPart)) {
                matchedParts++;
                textIndex = i + 1;
                break;
            }
        }
    }

    if (matchedParts === searchParts.length) {
        return { matches: true, score: 75 };
    }

    return { matches: false, score: 0 };
};

// Helper function to format timestamps
export const formatTimestamp = (timestamp: any, relative: boolean = true): string => {
    if (!timestamp) return 'Unknown';

    let date: Date;

    try {
        // Handle Firestore Timestamp with seconds property
        if (timestamp && typeof timestamp === 'object' && timestamp.seconds) {
            date = new Date(timestamp.seconds * 1000);
        }
        // Handle Firestore Timestamp with toDate method
        else if (timestamp && typeof timestamp.toDate === 'function') {
            date = timestamp.toDate();
        }
        // Handle regular Date object
        else if (timestamp instanceof Date) {
            date = timestamp;
        }
        // Handle string or number timestamps
        else if (typeof timestamp === 'string' || typeof timestamp === 'number') {
            date = new Date(timestamp);
        }
        // Handle the _seconds format from debug output
        else if (timestamp && timestamp._seconds) {
            date = new Date(timestamp._seconds * 1000);
        }
        else {
            return 'Unknown format';
        }

        // Validate the date
        if (isNaN(date.getTime())) {
            return 'Invalid Date';
        }

        if (!relative) {
            return date.toLocaleDateString('en-US', {
                month: 'short',
                day: 'numeric',
                year: date.getFullYear() !== new Date().getFullYear() ? 'numeric' : undefined
            });
        }

        const now = new Date();
        const diffInSeconds = Math.floor((now.getTime() - date.getTime()) / 1000);

        if (diffInSeconds < 60) {
            return 'Just now';
        } else if (diffInSeconds < 3600) {
            const minutes = Math.floor(diffInSeconds / 60);
            return `${minutes}m ago`;
        } else if (diffInSeconds < 86400) {
            const hours = Math.floor(diffInSeconds / 3600);
            return `${hours}h ago`;
        } else if (diffInSeconds < 604800) {
            const days = Math.floor(diffInSeconds / 86400);
            return `${days}d ago`;
        } else {
            return date.toLocaleDateString('en-US', {
                month: 'short',
                day: 'numeric',
                year: date.getFullYear() !== now.getFullYear() ? 'numeric' : undefined
            });
        }
    } catch (error) {
        console.error('Error formatting timestamp:', error);
        return 'Format Error';
    }
};

// Helper to get class display name
export const getClassDisplayName = (userClass: UserClass): string => {
    return userClass === 'gsb' ? 'GSB MBA' : 'Undergraduate';
};

// Helper to get class names array
export const getClassNames = async (userClass: UserClass): Promise<string[]> => {
    if (userClass === 'gsb') {
        const { GSB_CLASS_NAMES } = await import('../data/names');
        return GSB_CLASS_NAMES;
    } else {
        const { UNDERGRAD_CLASS_NAMES } = await import('../data/names-undergrad');
        return UNDERGRAD_CLASS_NAMES;
    }
};

================
File: .firebaserc
================
{
  "projects": {
    "default": "stanford-lastchances"
  }
}

================
File: firestore.indexes.json
================
{
    "indexes": [
        {
            "collectionGroup": "users",
            "queryScope": "COLLECTION",
            "fields": [
                {
                    "fieldPath": "submitted",
                    "order": "ASCENDING"
                },
                {
                    "fieldPath": "verifiedName",
                    "order": "ASCENDING"
                }
            ]
        }
    ],
    "fieldOverrides": []
}

================
File: firestore.rules
================
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    match /users/{userId} {
      // Users can only read their own document
      allow read: if request.auth != null && request.auth.uid == userId;
      
      // Special case for test user - allow reading documents with _gsb or _undergrad suffix
      allow read: if request.auth != null && request.auth.token.email == 'jpark22@stanford.edu' 
        && (userId == request.auth.uid + '_gsb' || userId == request.auth.uid + '_undergrad');
      
      // Admin can read ALL user documents (server-side admin protection)
      allow read: if request.auth != null && request.auth.token.email == 'jpark22@stanford.edu';
      
      // Users can only write to their own document
      allow write: if request.auth != null && request.auth.uid == userId;
      
      // Special case for test user - allow writing to documents with _gsb or _undergrad suffix
      allow write: if request.auth != null && request.auth.token.email == 'jpark22@stanford.edu' 
        && (userId == request.auth.uid + '_gsb' || userId == request.auth.uid + '_undergrad');
      
      // Additional validation for writes
      allow update: if request.auth != null 
        && (request.auth.uid == userId || 
            (request.auth.token.email == 'jpark22@stanford.edu' && 
             (userId == request.auth.uid + '_gsb' || userId == request.auth.uid + '_undergrad')))
        && request.auth.token.email.matches('.*@stanford\\.edu$')
        && validateUserUpdate(resource.data, request.resource.data);
      
      allow create: if request.auth != null 
        && (request.auth.uid == userId || 
            (request.auth.token.email == 'jpark22@stanford.edu' && 
             (userId == request.auth.uid + '_gsb' || userId == request.auth.uid + '_undergrad')))
        && request.auth.token.email.matches('.*@stanford\\.edu$')
        && validateUserCreation(request.resource.data);
    }
    
    // Analytics collection - ONLY admin can read, only backend functions can write
    match /analytics/{analyticsDoc} {
      allow read: if request.auth != null && request.auth.token.email == 'jpark22@stanford.edu';
      allow write: if false; // Only backend functions can write here
    }
    
    // Helper functions for validation
    function validateUserUpdate(existingData, newData) {
      // Prevent modification of critical fields after creation
      return existingData.uid == newData.uid
        && existingData.email == newData.email
        && existingData.createdAt == newData.createdAt
        // Validate crushes array (no limit now)
        && newData.crushes is list
        && validateCrushes(newData.crushes)
        // Validate locked crushes are preserved
        && validateLockedCrushes(existingData, newData);
    }
    
    function validateUserCreation(newData) {
      return newData.uid is string
        && newData.email is string
        && newData.email.matches('.*@stanford\\.edu$')
        && newData.crushes is list
        && newData.crushes.size() == 0
        && newData.matches is list
        && newData.matches.size() == 0
        && (!('lockedCrushes' in newData) || (newData.lockedCrushes is list && newData.lockedCrushes.size() == 0));
    }
    
    function validateCrushes(crushes) {
      return crushes.toSet().size() == crushes.size(); // No duplicates
    }
    
    function validateLockedCrushes(existingData, newData) {
      // If lockedCrushes exists in existing data, ensure all locked crushes are still in the new crushes array
      return !('lockedCrushes' in existingData) || 
             !('lockedCrushes' in newData) ||
             (existingData.lockedCrushes is list && 
              newData.lockedCrushes is list &&
              existingData.lockedCrushes.toSet().difference(newData.crushes.toSet()).size() == 0);
    }
  }
}

================
File: functions/src/scheduledAnalytics.ts
================
import * as functions from 'firebase-functions';
import * as admin from 'firebase-admin';

export const scheduledAnalytics = functions.pubsub
    .schedule('every 6 hours')
    // .schedule('every 1 minutes')
    .timeZone('America/Los_Angeles')
    .onRun(async (context) => {
        console.log('ðŸ” Running scheduled analytics...');

        try {
            const db = admin.firestore();

            // Get all data
            const usersSnapshot = await db.collection('users').get();
            const takenNamesSnapshot = await db.collection('takenNames').get();

            // Generate analytics data
            const analyticsData = await generateAnalyticsData(usersSnapshot, takenNamesSnapshot);

            // Store in analytics collection
            const analyticsRef = db.collection('analytics').doc();
            await analyticsRef.set({
                ...analyticsData,
                createdAt: admin.firestore.FieldValue.serverTimestamp()
            });

            console.log('âœ… Analytics data saved to Firestore');
            return { success: true, documentId: analyticsRef.id };

        } catch (error) {
            console.error('âŒ Error in scheduled analytics:', error);
            throw error;
        }
    });

async function generateAnalyticsData(usersSnapshot: any, takenNamesSnapshot: any) {
    // 1. Basic stats
    const totalUsers = usersSnapshot.size;
    const totalTakenNames = takenNamesSnapshot.size;

    // 2. Process users data
    const allUsers: any[] = [];
    const seenPairs = new Set<string>();
    let totalCrushesSent = 0;
    let activeUsersCount = 0;

    // Calculate 24 hours ago timestamp
    const twentyFourHoursAgo = new Date(Date.now() - (24 * 60 * 60 * 1000));

    usersSnapshot.forEach((doc: any) => {
        const userData = doc.data();
        const userName = userData.verifiedName || userData.displayName || userData.email || '(Unnamed User)';

        const userInfo = {
            name: userName,
            crushCount: userData.crushCount || 0,
            matches: userData.matches || [],
            crushes: userData.crushes || []
        };

        allUsers.push(userInfo);

        // Count crushes sent (actual crushes array length, not crushCount which is crushes received)
        const userCrushes = userData.crushes || [];
        totalCrushesSent += userCrushes.length;

        // Check if user was active in last 24 hours
        if (userData.lastLogin) {
            let lastLoginDate;

            // Handle both Firestore Timestamp and regular Date
            if (userData.lastLogin.toDate) {
                lastLoginDate = userData.lastLogin.toDate();
            } else if (userData.lastLogin.seconds) {
                lastLoginDate = new Date(userData.lastLogin.seconds * 1000);
            } else {
                lastLoginDate = new Date(userData.lastLogin);
            }

            if (lastLoginDate > twentyFourHoursAgo) {
                activeUsersCount++;
            }
        }

        // Count unique matches
        const matches = userData.matches || [];
        if (Array.isArray(matches) && matches.length > 0) {
            matches.forEach((match: any) => {
                const matchName = match.name || match;
                const pair = [userName, matchName].sort().join(' - ');
                seenPairs.add(pair);
            });
        }
    });

    // 3. Calculate statistics
    const totalMatches = seenPairs.size;
    const matchedPairs = Array.from(seenPairs).sort();

    const peopleWithCrushes = allUsers.filter(user => user.crushCount > 0).length;
    const avgCrushes = totalUsers > 0 ? totalCrushesSent / totalUsers : 0;

    // Calculate active user percentage
    const activeUsersLast24h = totalUsers > 0 ? Number((activeUsersCount / totalUsers * 100).toFixed(2)) : 0;

    return {
        // Basic stats
        totalUsers,
        totalTakenNames,

        // Match stats
        totalMatches,
        matchedPairs,

        // Crush stats
        totalCrushes: totalCrushesSent,
        peopleWithCrushes,
        avgCrushes: Number(avgCrushes.toFixed(2)),

        // Activity stats
        activeUsersLast24h // Now a percentage (0-100)
    };
}

// Manual trigger function for testing
export const runAnalyticsNow = functions.https.onRequest(async (req, res) => {
    try {
        const db = admin.firestore();

        const usersSnapshot = await db.collection('users').get();
        const takenNamesSnapshot = await db.collection('takenNames').get();

        const analyticsData = await generateAnalyticsData(usersSnapshot, takenNamesSnapshot);

        const analyticsRef = db.collection('analytics').doc();
        await analyticsRef.set({
            ...analyticsData,
            createdAt: admin.firestore.FieldValue.serverTimestamp(),
            manual: true
        });

        res.json({
            success: true,
            documentId: analyticsRef.id,
            data: analyticsData
        });
    } catch (error) {
        console.error('Error running manual analytics:', error);
        res.status(500).json({ error: 'Failed to generate analytics' });
    }
});

================
File: functions/package.json
================
{
  "name": "functions",
  "scripts": {
    "build": "tsc",
    "build:watch": "tsc --watch",
    "serve": "npm run build && firebase emulators:start --only functions",
    "shell": "npm run build && firebase functions:shell",
    "start": "npm run shell",
    "deploy": "firebase deploy --only functions",
    "logs": "firebase functions:log"
  },
  "engines": {
    "node": "18"
  },
  "main": "lib/index.js",
  "dependencies": {
    "firebase-admin": "^12.7.0",
    "firebase-functions": "^4.8.0"
  },
  "devDependencies": {
    "@typescript-eslint/eslint-plugin": "^5.12.0",
    "@typescript-eslint/parser": "^5.12.0",
    "eslint": "^8.9.0",
    "eslint-config-google": "^0.14.0",
    "eslint-plugin-import": "^2.25.4",
    "typescript": "^4.9.0"
  },
  "private": true
}

================
File: scripts/tools/matches.js
================
import admin from 'firebase-admin';
import { readFileSync } from 'fs';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';

// Get current directory for ES modules
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Load service account key
const serviceAccount = JSON.parse(
    readFileSync(join(__dirname, '../../functions/src/serviceAccountKey.json'), 'utf8')
);

admin.initializeApp({
    credential: admin.credential.cert(serviceAccount),
    projectId: 'stanford-lastchances',
});

const db = admin.firestore();

async function displayAllMatches() {
    try {
        console.log('='.repeat(80));
        console.log('Past Chances - ALL MATCHES');
        console.log('='.repeat(80));

        // Get all users
        const usersSnapshot = await db.collection('users').get();
        const allMatches = new Map(); // Use Map to avoid duplicates
        const userMap = new Map(); // Map to store user data by UID

        // Build user map for quick lookups
        usersSnapshot.forEach(doc => {
            const userData = doc.data();
            if (userData.verifiedName) {
                userMap.set(doc.id, {
                    uid: doc.id,
                    verifiedName: userData.verifiedName,
                    email: userData.email,
                    matches: userData.matches || []
                });
            }
        });

        // Collect all unique matches
        userMap.forEach((user) => {
            if (user.matches && user.matches.length > 0) {
                user.matches.forEach(match => {
                    // Create a unique pair key (alphabetical order to avoid duplicates)
                    const pairKey = [user.verifiedName, match.name].sort().join(' â†” ');

                    if (!allMatches.has(pairKey)) {
                        allMatches.set(pairKey, {
                            person1: user.verifiedName,
                            person2: match.name,
                            pairKey: pairKey
                        });
                    }
                });
            }
        });

        // Convert to array and sort alphabetically by the first person's name
        const matchesArray = Array.from(allMatches.values());
        matchesArray.sort((a, b) => {
            const firstPersonA = a.pairKey.split(' â†” ')[0];
            const firstPersonB = b.pairKey.split(' â†” ')[0];
            return firstPersonA.localeCompare(firstPersonB);
        });

        console.log(`\nTotal Matches Found: ${matchesArray.length}\n`);

        if (matchesArray.length === 0) {
            console.log('No matches found yet. Keep checking back! ðŸ’•');
        } else {
            console.log('MATCH PAIRS:');
            console.log('-'.repeat(80));

            matchesArray.forEach((match, index) => {
                const rank = (index + 1).toString().padStart(2);
                console.log(`${rank}. ${match.pairKey}`);
            });

            // Summary statistics
            console.log('\n' + '='.repeat(80));
            console.log('SUMMARY:');
            console.log(`Total unique matches: ${matchesArray.length}`);
            console.log(`Total people involved in matches: ${matchesArray.length * 2}`);

            // Count unique individuals
            const uniquePeople = new Set();
            matchesArray.forEach(match => {
                uniquePeople.add(match.person1);
                uniquePeople.add(match.person2);
            });
            console.log(`Unique individuals with matches: ${uniquePeople.size}`);

            console.log('='.repeat(80));
        }

    } catch (error) {
        console.error('Error displaying matches:', error);
    } finally {
        process.exit(0);
    }
}

displayAllMatches();

================
File: src/components/NameSelection.tsx
================
import React, { useState } from 'react';
import { useAuth } from '../contexts/AuthContext';

const NameSelection: React.FC = () => {
    const { user, nameOptions, selectName, logout } = useAuth();
    const [selecting, setSelecting] = useState(false);
    const [error, setError] = useState<string | null>(null);

    const handleNameSelect = async (selectedName: string) => {
        if (selecting) return;

        setSelecting(true);
        setError(null);

        try {
            await selectName(selectedName);
        } catch (error) {
            console.error('Error selecting name:', error);
            setError('Failed to save your selection. Please try again.');
        } finally {
            setSelecting(false);
        }
    };

    if (!nameOptions) {
        return <div className="loading">Loading...</div>;
    }

    return (
        <div className="verification-container">
            <div className="verification-card">
                <div className="verification-header">
                    <h1>Past Chances</h1>
                    <div className="user-info">
                        <span>{user?.email}</span>
                        <button className="logout-btn" onClick={logout}>Logout</button>
                    </div>
                </div>

                <div className="verification-content">
                    <h2>Multiple matches found for your name</h2>
                    <p>Please select which of these options matches your identity:</p>

                    <div className="names-list">
                        <h3>Potential Matches</h3>
                        <div className="names-verification-list">
                            {nameOptions.map((name) => (
                                <div
                                    key={name}
                                    onClick={() => !selecting && handleNameSelect(name)}
                                    className={`name-verification-item ${selecting ? 'disabled' : ''}`}
                                >
                                    <span className="name-text">{name}</span>
                                    <span className="select-btn">
                                        Select
                                    </span>
                                </div>
                            ))}
                        </div>
                    </div>

                    {selecting && (
                        <div className="saving-indicator">
                            Saving your selection...
                        </div>
                    )}

                    {error && (
                        <div className="error-message" style={{ color: 'red', textAlign: 'center', marginTop: '15px' }}>
                            {error}
                        </div>
                    )}
                </div>
            </div>
        </div>
    );
};

export default NameSelection;

================
File: src/styles/auth.css
================
/* Login page styles */
.login-container {
  min-height: 100vh;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 20px;
  background: linear-gradient(135deg, #8C1515 0%, #B83A4B 100%);
}

.login-card {
  background: white;
  border-radius: 12px;
  padding: 40px;
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
  text-align: center;
  max-width: 400px;
  width: 100%;
}

.login-card h1 {
  color: #8C1515;
  margin-bottom: 8px;
  font-size: 28px;
  font-weight: 700;
}

.login-card h2 {
  color: #666;
  margin-bottom: 12px;
  font-size: 18px;
  font-weight: 500;
}

.login-card > p {
  color: #777;
  margin-bottom: 30px;
  font-size: 16px;
  line-height: 1.5;
}

.login-content p {
  margin-bottom: 16px;
  color: #555;
  font-size: 14px;
  font-weight: 600;
}

.google-signin-btn {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 12px;
  width: 100%;
  padding: 14px 20px;
  border: 2px solid #dadce0;
  border-radius: 8px;
  background: white;
  color: #3c4043;
  font-size: 16px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease;
  margin-bottom: 12px;
}

.google-signin-btn:hover {
  background-color: #f8f9fa;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

.google-signin-btn:first-of-type {
  margin-bottom: 12px;
}

.google-signin-btn:last-of-type {
  margin-bottom: 0;
}

.google-icon {
  width: 20px;
  height: 20px;
}

.login-footer {
  margin-top: 30px;
  padding-top: 20px;
  border-top: 1px solid #eee;
}

.login-footer p {
  color: #666;
  font-size: 12px;
}

.class-indicator {
  margin-bottom: 15px;
  text-align: center;
}

.class-badge {
  display: inline-block;
  background: linear-gradient(135deg, #8C1515 0%, #B83A4B 100%);
  color: white;
  padding: 6px 12px;
  border-radius: 20px;
  font-size: 12px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

/* Name Verification styles */
.verification-container {
  min-height: 100vh;
  padding: 10px;
  background-color: #f8f9fa;
}

.verification-card {
  max-width: 900px;
  margin: 0 auto;
  background: white;
  border-radius: 12px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
  overflow: hidden;
  min-height: calc(100vh - 20px);
  display: flex;
  flex-direction: column;
}

.verification-header {
  background: #8C1515;
  color: white;
  padding: 15px 20px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex-wrap: wrap;
  gap: 10px;
  flex-shrink: 0;
}

.verification-header h1 {
  font-size: 20px;
  font-weight: 700;
}

.verification-content {
  padding: 20px;
  flex: 1;
  display: flex;
  flex-direction: column;
}

.verification-content h2 {
  color: #8C1515;
  margin-bottom: 8px;
  font-size: 18px;
  line-height: 1.3;
}

.verification-content > p {
  color: #666;
  margin-bottom: 20px;
  line-height: 1.5;
  font-size: 14px;
}

.names-list {
  flex: 1;
  display: flex;
  flex-direction: column;
}

.names-list h3 {
  color: #8C1515;
  margin-bottom: 15px;
  font-size: 16px;
  font-weight: 600;
}

.names-verification-list {
  flex: 1;
  overflow-y: auto;
  border: 1px solid #e1e5e9;
  border-radius: 8px;
  max-height: 50vh;
}

.name-verification-item {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 12px 15px;
  border-bottom: 1px solid #f0f0f0;
  cursor: pointer;
  transition: all 0.2s ease;
  font-size: 14px;
}

.name-verification-item:last-child {
  border-bottom: none;
}

.name-verification-item:hover:not(.disabled) {
  background: #f8f9fa;
}

.name-verification-item.disabled {
  opacity: 0.5;
  cursor: not-allowed;
  background: #f9f9f9;
}

.select-btn {
  font-weight: 600;
  font-size: 12px;
  color: white;
  background: #8C1515;
  padding: 4px 10px;
  border-radius: 6px;
  transition: all 0.2s ease;
}

.select-btn.taken {
  background: #6c757d;
  color: white;
}

.name-verification-item:hover:not(.disabled) .select-btn:not(.taken) {
  background: #a01a1a;
}

.saving-indicator {
  text-align: center;
  padding: 15px;
  color: #8C1515;
  font-weight: 600;
  border-top: 1px solid #e1e5e9;
  margin-top: 15px;
}

/* Mobile-specific login improvements */
@media (max-width: 768px) {
  .login-container {
    min-height: 100vh;
    padding: 20px 15px;
    align-items: flex-start;
    padding-top: 15vh;
  }
  
  .login-card {
    padding: 30px 25px;
    max-width: 380px;
    margin: 0 auto;
  }
  
  .login-card h1 {
    font-size: 24px;
    margin-bottom: 6px;
  }
  
  .login-card h2 {
    font-size: 16px;
    margin-bottom: 10px;
  }
  
  .login-card > p {
    font-size: 14px;
    margin-bottom: 25px;
    line-height: 1.4;
  }
  
  .google-signin-btn {
    padding: 12px 18px;
    font-size: 14px;
  }
  
  .google-icon {
    width: 18px;
    height: 18px;
  }
}

@media (max-width: 480px) {
  .login-container {
    padding: 15px 10px;
    padding-top: 12vh;
  }
  
  .login-card {
    padding: 25px 20px;
    border-radius: 8px;
  }
  
  .login-card h1 {
    font-size: 22px;
  }
  
  .login-card h2 {
    font-size: 15px;
  }
  
  .login-card > p {
    font-size: 13px;
    margin-bottom: 20px;
  }
  
  .google-signin-btn {
    padding: 11px 16px;
    font-size: 13px;
    gap: 10px;
  }
}

@media (max-height: 600px) {
  .login-container {
    padding-top: 8vh;
  }
}

@media (max-height: 500px) {
  .login-container {
    padding-top: 5vh;
  }
}

================
File: src/types/userTypes.ts
================
export type UserClass = 'gsb' | 'undergrad';

export interface MatchInfo {
    name: string;
    email: string;
    matchedAt?: any; // Firebase Timestamp or Date
}

export interface UserData {
    uid: string;
    email: string;
    name: string;
    photoURL: string;
    crushes: string[];
    lockedCrushes: string[];
    matches: MatchInfo[];
    crushCount: number;
    userClass: UserClass;
    createdAt: any;
    updatedAt: any;
    lastLogin: any;
}

export interface UserWithId extends UserData {
    id: string;
}

================
File: package.json
================
{
  "name": "pastchances",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview",
    "count-docs": "node scripts/countDocs.js",
    "count-matches": "node scripts/countMatches.js",
    "top-crushes": "node scripts/topCrushCounts.js",
    "find-user": "node scripts/findUserInCrushes.js"
  },
  "dependencies": {
    "@types/react-router-dom": "^5.3.3",
    "firebase": "^11.2.0",
    "firebase-admin": "^12.7.0",
    "react": "^19.1.0",
    "react-dom": "^19.1.0",
    "react-router-dom": "^7.6.2"
  },
  "devDependencies": {
    "@eslint/js": "^9.25.0",
    "@types/react": "^19.1.2",
    "@types/react-dom": "^19.1.2",
    "@vitejs/plugin-react": "^4.4.1",
    "eslint": "^9.25.0",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-react-refresh": "^0.4.19",
    "globals": "^16.0.0",
    "typescript": "~5.8.3",
    "typescript-eslint": "^8.30.1",
    "vite": "^6.3.5"
  }
}

================
File: functions/src/utils.ts
================
import { UserWithId } from './types';

// Helper function to normalize names for case-insensitive comparison
export function normalizeName(name: string): string {
    if (!name || typeof name !== 'string') return '';

    return name
        .normalize('NFD')  // Decompose accented characters
        .replace(/[\u0300-\u036f]/g, '')  // Remove accent marks
        .toLowerCase()
        .trim()
        .replace(/[^\w\s]/g, ' ')  // Replace non-alphanumeric with spaces
        .replace(/\s+/g, ' ')  // Normalize spaces
        .trim();
}

// Enhanced function to find the best matching user for a crush name
// Only matches users within the same class
export function findUserByName(crushName: string, allUsers: UserWithId[], userClass?: string): UserWithId | null {
    if (!crushName || !crushName.trim()) return null;

    const normalizedCrush = normalizeName(crushName);

    // Filter users by class if specified
    const filteredUsers = userClass
        ? allUsers.filter(user => (user.userClass || 'gsb') === userClass)
        : allUsers;

    // First try exact match on name field
    let match = filteredUsers.find(user =>
        user.name &&
        normalizeName(user.name) === normalizedCrush
    );

    if (match) return match;

    // Try exact match on legacy verifiedName field (for migration)
    match = filteredUsers.find(user =>
        user.verifiedName &&
        normalizeName(user.verifiedName) === normalizedCrush
    );

    if (match) return match;

    // Try exact match on legacy displayName field (for migration)
    match = filteredUsers.find(user =>
        user.displayName &&
        normalizeName(user.displayName) === normalizedCrush
    );

    if (match) return match;

    // Try partial match (first and last name only) for cases with middle names
    const crushParts = normalizedCrush.split(' ');
    if (crushParts.length >= 2) {
        const crushFirstLast = `${crushParts[0]} ${crushParts[crushParts.length - 1]}`;

        // Try partial match with name field
        match = filteredUsers.find(user => {
            const userIdentityName = user.name || user.verifiedName || user.displayName;
            if (userIdentityName) {
                const nameParts = normalizeName(userIdentityName).split(' ');
                if (nameParts.length >= 2) {
                    const nameFirstLast = `${nameParts[0]} ${nameParts[nameParts.length - 1]}`;
                    return nameFirstLast === crushFirstLast;
                }
            }
            return false;
        });
    }

    return match || null;
}

// Helper function to get user's identity name (with migration support)
export function getUserIdentityName(user: UserWithId): string {
    return user.name || user.verifiedName || user.displayName || '';
}

================
File: scripts/tools/stats.js
================
import admin from 'firebase-admin';
import { readFileSync } from 'fs';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';

// Get current directory for ES modules
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Load service account key
const serviceAccount = JSON.parse(
    readFileSync(join(__dirname, '../../functions/src/serviceAccountKey.json'), 'utf8')
);

admin.initializeApp({
    credential: admin.credential.cert(serviceAccount),
    projectId: 'stanford-lastchances',
});

const db = admin.firestore();

// Dynamic import to load the TypeScript file
let GSB_CLASS_NAMES;
try {
    const namesContent = readFileSync(join(__dirname, '../../src/data/names.ts'), 'utf8');
    const arrayMatch = namesContent.match(/export\s+const\s+GSB_CLASS_NAMES\s*=\s*(\[[\s\S]*?\]);/);
    if (arrayMatch) {
        GSB_CLASS_NAMES = eval(arrayMatch[1]);
    } else {
        throw new Error('Could not parse GSB_CLASS_NAMES from names.ts');
    }
} catch (error) {
    console.error('Failed to load names from names.ts:', error);
    process.exit(1);
}

async function runAnalytics() {
    try {
        console.log('='.repeat(80));
        console.log('Past Chances - ANALYTICS');
        console.log('='.repeat(80));

        // Get total class size from names.ts
        const TOTAL_CLASS_SIZE = GSB_CLASS_NAMES.length;
        console.log(`Class size: ${TOTAL_CLASS_SIZE}`);

        // Get all data
        const usersSnapshot = await db.collection('users').get();

        // 1. Platform stats
        const totalUsers = usersSnapshot.size;

        console.log('\nPLATFORM:');
        console.log(`Total users in database: ${totalUsers}`);

        // 2. Process users data
        const allUsers = [];
        const usersBeingCrushedOn = new Set();
        let totalCrushesSent = 0;
        let usersWithNames = 0;

        usersSnapshot.forEach(doc => {
            const userData = doc.data();

            // Use the new single name field (with fallback for migration)
            const userName = userData.name || userData.verifiedName || userData.displayName || userData.email || '(Unnamed User)';
            const hasName = !!(userData.name && userData.name.trim());

            const userInfo = {
                name: userName,
                hasName: hasName,
                crushes: userData.crushes || [],
                matches: userData.matches || [],
                crushCount: userData.crushCount || 0
            };

            allUsers.push(userInfo);

            // Count users with names set
            if (hasName) {
                usersWithNames++;
            }

            // Count crushes sent and track who's being crushed on
            const userCrushes = userData.crushes || [];
            totalCrushesSent += userCrushes.length;

            userCrushes.forEach(crushName => {
                usersBeingCrushedOn.add(crushName);
            });
        });

        // 3. Calculate crush statistics
        const avgCrushesSentPerUser = usersWithNames > 0 ? totalCrushesSent / usersWithNames : 0;
        const peopleBeingCrushedOn = usersBeingCrushedOn.size;

        console.log(`Users with names set: ${usersWithNames}`);
        console.log(`Users without names: ${totalUsers - usersWithNames}`);

        console.log('\nCRUSHES:');
        console.log(`Total crushes sent: ${totalCrushesSent}`);
        console.log(`Average crushes per user with name: ${avgCrushesSentPerUser.toFixed(2)}`);
        console.log(`People being crushed on: ${peopleBeingCrushedOn}`);

        // 4. Calculate matches
        const seenPairs = new Set();
        allUsers.forEach(user => {
            const matches = user.matches || [];
            if (Array.isArray(matches) && matches.length > 0) {
                matches.forEach(match => {
                    const matchName = match.name || match;
                    const pair = [user.name, matchName].sort().join(' - ');
                    seenPairs.add(pair);
                });
            }
        });

        const totalMatches = seenPairs.size;
        const usersWithMatches = allUsers.filter(user => user.matches.length > 0).length;

        console.log('\nMATCHES:');
        console.log(`Total unique matches: ${totalMatches}`);
        console.log(`Users with matches: ${usersWithMatches}`);

        // 5. Activity statistics
        const usersWithCrushCount = allUsers.filter(user => user.crushCount > 0).length;
        const usersWhoSentCrushes = allUsers.filter(user => user.crushes.length > 0).length;

        console.log('\nACTIVITY:');
        console.log(`Users with others crushing on them: ${usersWithCrushCount}`);
        console.log(`Users who have sent crushes: ${usersWhoSentCrushes}`);

        // 6. Participation rates
        const platformParticipationRate = usersWithNames > 0 ? (usersWhoSentCrushes / usersWithNames * 100) : 0;
        const classParticipationRate = (usersWhoSentCrushes / TOTAL_CLASS_SIZE * 100);

        console.log('\nPARTICIPATION:');
        console.log(`Platform participation rate: ${platformParticipationRate.toFixed(1)}% (${usersWhoSentCrushes}/${usersWithNames} users with names)`);
        console.log(`Class participation rate: ${classParticipationRate.toFixed(1)}% (${usersWhoSentCrushes}/${TOTAL_CLASS_SIZE} total class)`);

        console.log('\n' + '='.repeat(80));

        return {
            classSize: TOTAL_CLASS_SIZE,
            platform: {
                totalUsers,
                usersWithNames,
                usersWithoutNames: totalUsers - usersWithNames
            },
            crushes: {
                totalCrushesSent,
                avgCrushesSentPerUser: Number(avgCrushesSentPerUser.toFixed(2)),
                peopleBeingCrushedOn
            },
            matches: {
                totalMatches,
                usersWithMatches
            },
            activity: {
                usersWithCrushCount,
                usersWhoSentCrushes
            },
            participation: {
                platformParticipationRate: Number(platformParticipationRate.toFixed(1)),
                classParticipationRate: Number(classParticipationRate.toFixed(1))
            }
        };

    } catch (error) {
        console.error('Error running analytics:', error);
    } finally {
        process.exit(0);
    }
}

runAnalytics();

================
File: src/App.tsx
================
import React from 'react';
import type { ReactNode } from 'react';
import { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom';
import { AuthProvider, useAuth } from './contexts/AuthContext';
import Login from './components/Login';
import Home from './components/Home';
import NameSelection from './components/NameSelection';
import './App.css';

interface ProtectedRouteProps {
  children: ReactNode;
}

const ProtectedRoute: React.FC<ProtectedRouteProps> = ({ children }) => {
  const { user, userData, loading, nameOptions } = useAuth();

  if (loading) {
    return <div className="loading">Loading...</div>;
  }

  if (!user) {
    return <Navigate to="/login" />;
  }

  if (!userData) {
    return <div className="loading">Setting up your account...</div>;
  }

  // Show name selection if user has multiple name options
  if (nameOptions && nameOptions.length > 0) {
    return <NameSelection />;
  }

  // Show name selection if user doesn't have a name set yet
  if (!userData.name || userData.name.trim() === '') {
    return <NameSelection />;
  }

  return <>{children}</>;
};

interface PublicRouteProps {
  children: ReactNode;
}

const PublicRoute: React.FC<PublicRouteProps> = ({ children }) => {
  const { user, loading } = useAuth();

  if (loading) {
    return <div className="loading">Loading...</div>;
  }

  return !user ? <>{children}</> : <Navigate to="/" />;
};

function App() {
  return (
    <AuthProvider>
      <Router>
        <div className="App">
          <Routes>
            <Route
              path="/login"
              element={
                <PublicRoute>
                  <Login />
                </PublicRoute>
              }
            />
            <Route
              path="/"
              element={
                <ProtectedRoute>
                  <Home />
                </ProtectedRoute>
              }
            />
          </Routes>
        </div>
      </Router>
    </AuthProvider>
  );
}

export default App;

================
File: vite.config.ts
================
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

export default defineConfig({
  plugins: [react()],
  publicDir: 'public',
  build: {
    outDir: 'dist',
    assetsDir: 'assets',
    copyPublicDir: true,
    emptyOutDir: true,
    chunkSizeWarningLimit: 1000,
    rollupOptions: {
      input: './index.html',
      output: {
        manualChunks: {
          vendor: ['react', 'react-dom'],
          firebase: ['firebase/app', 'firebase/auth', 'firebase/firestore']
        }
      }
    }
  },
  server: {
    port: 3000
  }
})

================
File: functions/src/types.ts
================
export type UserClass = 'gsb' | 'undergrad';

export interface UserData {
    uid: string;
    email: string;
    name: string;  // Single name field instead of displayName/verifiedName
    photoURL: string;
    crushes: string[];
    lockedCrushes?: string[];
    matches?: MatchInfo[];
    crushCount?: number;
    userClass: UserClass;
    createdAt: any;
    updatedAt: any;
    lastLogin: any;

    // Legacy fields for migration support
    displayName?: string;
    verifiedName?: string;
}

export interface UserWithId extends UserData {
    id: string;
}

export interface MatchInfo {
    name: string;
    email: string;
    matchedAt?: any; // Firebase Timestamp or Date - now optional
}

================
File: src/components/admin/AdminAnalytics.tsx
================
import React from 'react';

interface CrusherInfo {
    name: string;
    email: string;
}

interface AnalyticsData {
    totalUsers: number;
    totalClassSize: number;
    totalMatches: number;
    matchedPairs: string[];
    totalCrushes: number;
    peopleWithCrushes: number;
    avgCrushes: number;
    usersWithCrushes: number;
    usersWithMatches: number;
    participationRate: number;
    classParticipationRate: number;
    orphanedCrushes: string[];
    topCrushReceivers: Array<{ name: string; count: number; crushers: string[] }>;
    topCrushSenders: Array<{ name: string; count: number; crushNames: string[] }>;
    inactiveReceivers: Array<{ name: string; email: string; crushCount: number; reason: string; crushers: CrusherInfo[] }>;
    activeUsersLast24h: number;
}

interface AdminAnalyticsProps {
    analytics: AnalyticsData | null;
    classView: 'gsb' | 'undergrad';
    classDisplayName: string;
    allUsers: any[];
}

// Helper function to check if a match should have a timestamp (consistent with backend logic)
const shouldMatchHaveTimestamp = (user1Name: string, user2Name: string): boolean => {
    const isUser1JamesPark = user1Name === 'James Park';
    const isUser2JamesPark = user2Name === 'James Park';

    return !(isUser1JamesPark || isUser2JamesPark);
};

// Enhanced helper function to format match timestamp for analytics
const formatAnalyticsMatchTimestamp = (matchedAt: any, user1Name: string, user2Name: string): string => {
    // Check if this match should have a timestamp
    if (!shouldMatchHaveTimestamp(user1Name, user2Name)) {
        return 'James Park match';
    }

    if (!matchedAt) {
        return 'No timestamp';
    }

    let date: Date;

    try {
        // Handle Firestore Timestamp with seconds property
        if (matchedAt && typeof matchedAt === 'object' && matchedAt.seconds) {
            date = new Date(matchedAt.seconds * 1000);
        }
        // Handle Firestore Timestamp with toDate method
        else if (matchedAt && typeof matchedAt.toDate === 'function') {
            date = matchedAt.toDate();
        }
        // Handle regular Date object
        else if (matchedAt instanceof Date) {
            date = matchedAt;
        }
        // Handle string or number timestamps
        else if (typeof matchedAt === 'string' || typeof matchedAt === 'number') {
            date = new Date(matchedAt);
        }
        // Handle the _seconds format from debug output
        else if (matchedAt && matchedAt._seconds) {
            date = new Date(matchedAt._seconds * 1000);
        }
        else {
            console.log('Unknown timestamp format:', matchedAt);
            return 'Unknown format';
        }

        // Validate the date
        if (isNaN(date.getTime())) {
            console.log('Invalid date created from:', matchedAt);
            return 'Invalid Date';
        }

        const now = new Date();
        const diffInSeconds = Math.floor((now.getTime() - date.getTime()) / 1000);

        if (diffInSeconds < 60) {
            return 'Just now';
        } else if (diffInSeconds < 3600) {
            const minutes = Math.floor(diffInSeconds / 60);
            return `${minutes}m ago`;
        } else if (diffInSeconds < 86400) {
            const hours = Math.floor(diffInSeconds / 3600);
            return `${hours}h ago`;
        } else if (diffInSeconds < 604800) {
            const days = Math.floor(diffInSeconds / 86400);
            return `${days}d ago`;
        } else {
            return date.toLocaleDateString('en-US', {
                month: 'short',
                day: 'numeric',
                year: date.getFullYear() !== now.getFullYear() ? 'numeric' : undefined
            });
        }
    } catch (error) {
        console.error('Error formatting timestamp:', error, 'Original value:', matchedAt);
        return 'Format Error';
    }
};

const AdminAnalytics: React.FC<AdminAnalyticsProps> = ({ analytics, classDisplayName, allUsers }) => {
    if (!analytics) {
        return (
            <div className="admin-loading">
                Loading {classDisplayName} analytics...
            </div>
        );
    }

    // Get all matches with timestamps from users in this class
    const getAllMatchesWithTimestamps = () => {
        const matches: Array<{ pair: string; timestamp: any; users: string[] }> = [];
        const seenPairs = new Set<string>();

        allUsers.forEach(user => {
            if (user.matches && user.matches.length > 0) {
                user.matches.forEach((match: any) => {
                    const pair = [user.name, match.name].sort().join(' â†” ');
                    if (!seenPairs.has(pair)) {
                        seenPairs.add(pair);
                        matches.push({
                            pair,
                            timestamp: match.matchedAt,
                            users: [user.name, match.name]
                        });
                    }
                });
            }
        });

        // Sort matches: those with timestamps first (by most recent), then those without
        return matches.sort((a, b) => {
            const aHasTimestamp = shouldMatchHaveTimestamp(a.users[0], a.users[1]) && !!a.timestamp;
            const bHasTimestamp = shouldMatchHaveTimestamp(b.users[0], b.users[1]) && !!b.timestamp;

            // James Park matches always go to the end
            const aIsJamesPark = !shouldMatchHaveTimestamp(a.users[0], a.users[1]);
            const bIsJamesPark = !shouldMatchHaveTimestamp(b.users[0], b.users[1]);

            if (aIsJamesPark && !bIsJamesPark) return 1;
            if (!aIsJamesPark && bIsJamesPark) return -1;

            // If both are James Park matches, sort alphabetically
            if (aIsJamesPark && bIsJamesPark) {
                return a.pair.localeCompare(b.pair);
            }

            // If one has timestamp and other doesn't, prioritize the one with timestamp
            if (aHasTimestamp && !bHasTimestamp) return -1;
            if (!aHasTimestamp && bHasTimestamp) return 1;

            // If both have timestamps, sort by most recent first
            if (aHasTimestamp && bHasTimestamp) {
                try {
                    let dateA: Date, dateB: Date;

                    // Handle different timestamp formats for sorting
                    if (a.timestamp && a.timestamp.seconds) {
                        dateA = new Date(a.timestamp.seconds * 1000);
                    } else if (a.timestamp && a.timestamp._seconds) {
                        dateA = new Date(a.timestamp._seconds * 1000);
                    } else if (a.timestamp && typeof a.timestamp.toDate === 'function') {
                        dateA = a.timestamp.toDate();
                    } else {
                        dateA = new Date(a.timestamp);
                    }

                    if (b.timestamp && b.timestamp.seconds) {
                        dateB = new Date(b.timestamp.seconds * 1000);
                    } else if (b.timestamp && b.timestamp._seconds) {
                        dateB = new Date(b.timestamp._seconds * 1000);
                    } else if (b.timestamp && typeof b.timestamp.toDate === 'function') {
                        dateB = b.timestamp.toDate();
                    } else {
                        dateB = new Date(b.timestamp);
                    }

                    return dateB.getTime() - dateA.getTime();
                } catch (error) {
                    console.error('Error sorting timestamps:', error);
                    return 0;
                }
            }

            // If neither has timestamp, sort alphabetically
            return a.pair.localeCompare(b.pair);
        });
    };

    const matchesWithTimestamps = getAllMatchesWithTimestamps();

    return (
        <div className="admin-overview">
            <div className="admin-class-header">
                <h4>{classDisplayName} Class of 2025 - Analytics Dashboard</h4>
                <div className="admin-class-stats-summary">
                    <span className="class-stat">
                        <strong>{analytics.totalUsers}</strong> active users
                    </span>
                    <span className="class-stat">
                        <strong>{analytics.totalClassSize}</strong> total class size
                    </span>
                </div>
            </div>

            <div className="admin-quick-insights">
                <div className="admin-insight-card">
                    <h4>Platform Activity</h4>
                    <p>{analytics.usersWithCrushes} users have sent crushes</p>
                    <p>{analytics.usersWithMatches} users have matches</p>
                    <p>{analytics.avgCrushes} average crushes sent per user</p>
                    <p>{analytics.activeUsersLast24h}% of active users logged in (last 24h)</p>
                </div>

                <div className="admin-insight-card">
                    <h4>Participation Metrics</h4>
                    <p>{analytics.participationRate}% of signed-up users active</p>
                    <p>{analytics.inactiveReceivers.length} inactive receivers</p>
                </div>

                <div className="admin-insight-card">
                    <h4>Matching Success</h4>
                    <p>{analytics.totalMatches} total matches</p>
                    <p>{analytics.totalCrushes} total crushes sent</p>
                    <p>{analytics.peopleWithCrushes} people receiving crushes</p>
                </div>
            </div>

            <div className="admin-analytics">
                <div className="admin-analytics-section">
                    <h4>All {classDisplayName} Matches ({analytics.totalMatches}) - With Timestamps</h4>
                    {matchesWithTimestamps.length ? (
                        <div className="admin-matches-list">
                            {matchesWithTimestamps.map((match, index) => (
                                <div key={index} className="admin-match-item-with-timestamp">
                                    <div className="admin-match-pair">
                                        {index + 1}. {match.pair}
                                    </div>
                                    <div className="admin-match-time">
                                        {formatAnalyticsMatchTimestamp(match.timestamp, match.users[0], match.users[1])}
                                    </div>
                                </div>
                            ))}
                        </div>
                    ) : (
                        <p>No matches found yet in {classDisplayName} class.</p>
                    )}
                </div>

                <div className="admin-analytics-section">
                    <h4>Top {classDisplayName} Crush Receivers</h4>
                    <div className="admin-list">
                        {analytics.topCrushReceivers.slice(0, 15).map((receiver, index) => (
                            <div key={receiver.name} className="admin-list-item">
                                <span>{index + 1}. {receiver.name}</span>
                                <span>{receiver.count} crushes</span>
                            </div>
                        ))}
                    </div>
                </div>

                <div className="admin-analytics-section">
                    <h4>Top {classDisplayName} Crush Senders</h4>
                    <div className="admin-list">
                        {analytics.topCrushSenders.slice(0, 15).map((sender, index) => (
                            <div key={sender.name} className="admin-list-item">
                                <span>{index + 1}. {sender.name}</span>
                                <span>{sender.count} crushes sent</span>
                            </div>
                        ))}
                    </div>
                </div>

                <div className="admin-analytics-section">
                    <h4>{classDisplayName} Inactive Receivers ({analytics.inactiveReceivers.length})</h4>
                    <div className="admin-list">
                        {analytics.inactiveReceivers.map((inactive, index) => (
                            <div key={inactive.email} className="admin-inactive-item">
                                <div className="admin-inactive-header">
                                    <span>{index + 1}. {inactive.name}</span>
                                    <span>{inactive.crushCount} crushes</span>
                                </div>
                                <div className="admin-inactive-details">
                                    <p>Email: {inactive.email}</p>
                                    <p>Reason: {inactive.reason}</p>
                                    <p>Crushers: {inactive.crushers.map(c => c.name).join(', ')}</p>
                                </div>
                            </div>
                        ))}
                    </div>
                </div>
            </div>
        </div>
    );
};

export default AdminAnalytics;

================
File: src/components/Login.tsx
================
import React from 'react';
import { useAuth } from '../contexts/AuthContext';
import type { UserClass } from '../types/userTypes';

const Login: React.FC = () => {
    const { signInWithGoogle } = useAuth();

    const handleSignIn = (userClass: UserClass) => {
        signInWithGoogle(userClass);
    };

    return (
        <div className="login-container">
            <div className="login-card">
                <h1>Past Chances</h1>
                <br></br>
                <p>
                    Share your crushes anonymously and see if there's a mutual connection ðŸ‘€
                    <br></br>
                    <br></br>
                    The site will remain active until our Stanford accounts expire in October 2025
                </p>
                <div className="login-content">
                    <p>Select your class:</p>

                    <button
                        className="google-signin-btn"
                        onClick={() => handleSignIn('gsb')}
                    >
                        <svg className="google-icon" viewBox="0 0 24 24">
                            <path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z" />
                            <path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z" />
                            <path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z" />
                            <path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z" />
                        </svg>
                        GSB MBA Class of 2025
                    </button>

                    <button
                        className="google-signin-btn"
                        onClick={() => handleSignIn('undergrad')}
                    >
                        <svg className="google-icon" viewBox="0 0 24 24">
                            <path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z" />
                            <path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z" />
                            <path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z" />
                            <path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z" />
                        </svg>
                        Undergraduate Class of 2025
                    </button>
                </div>
            </div>
        </div>
    );
};

export default Login;

================
File: src/styles/dashboard.css
================
/* Dashboard Main Styles */
@import './dashboard/dashboard-layout.css';
@import './dashboard/dashboard-components.css';
@import './dashboard/dashboard-responsive.css';

================
File: src/components/UserDashboard.tsx
================
import React from 'react';
import { GSB_CLASS_NAMES } from '../data/names';
import { UNDERGRAD_CLASS_NAMES } from '../data/names-undergrad';
import type { UserData } from '../types/userTypes';

interface UserDashboardProps {
    userData: UserData;
    searchTerm: string;
    setSearchTerm: (term: string) => void;
    selectedNames: string[];
    savedNames: string[];
    updating: boolean;
    error: string | null;
    handleNameToggle: (name: string) => void;
    handleRemoveSelected: (name: string) => void;
    handleUpdatePreferences: () => void;
}

// Fast name matching function optimized for first/last name searches
const matchesSearchTerm = (fullName: string, searchTerm: string): { matches: boolean; score: number } => {
    if (!searchTerm.trim()) return { matches: true, score: 0 };

    const normalizeText = (text: string) => text.toLowerCase().trim();
    const normalizedName = normalizeText(fullName);
    const normalizedSearch = normalizeText(searchTerm);

    // Exact substring match (highest priority)
    if (normalizedName.includes(normalizedSearch)) {
        return { matches: true, score: 100 };
    }

    const nameParts = normalizedName.split(' ').filter(Boolean);
    const searchParts = normalizedSearch.split(' ').filter(Boolean);

    // First + Last name matching (most common use case)
    if (searchParts.length >= 2) {
        const searchFirst = searchParts[0];
        const searchLast = searchParts[searchParts.length - 1];

        if (nameParts.length >= 2) {
            const nameFirst = nameParts[0];
            const nameLast = nameParts[nameParts.length - 1];

            // Exact first + last match
            if (nameFirst === searchFirst && nameLast === searchLast) {
                return { matches: true, score: 95 };
            }

            // Partial first + exact last
            if (nameFirst.startsWith(searchFirst) && nameLast === searchLast) {
                return { matches: true, score: 90 };
            }

            // Exact first + partial last
            if (nameFirst === searchFirst && nameLast.startsWith(searchLast)) {
                return { matches: true, score: 85 };
            }
        }
    }

    // Single term matching
    if (searchParts.length === 1) {
        const searchTerm = searchParts[0];

        // Check if any name part starts with search term
        if (nameParts.some(part => part.startsWith(searchTerm))) {
            return { matches: true, score: 80 };
        }
    }

    // Multi-word progressive matching
    let nameIndex = 0;
    let matchedParts = 0;

    for (const searchPart of searchParts) {
        for (let i = nameIndex; i < nameParts.length; i++) {
            if (nameParts[i].startsWith(searchPart)) {
                matchedParts++;
                nameIndex = i + 1;
                break;
            }
        }
    }

    if (matchedParts === searchParts.length) {
        return { matches: true, score: 75 };
    }

    return { matches: false, score: 0 };
};

const UserDashboard: React.FC<UserDashboardProps> = ({
    userData,
    searchTerm,
    setSearchTerm,
    selectedNames,
    savedNames,
    updating,
    error,
    handleNameToggle,
    handleRemoveSelected,
    handleUpdatePreferences
}) => {
    const [virtualStart, setVirtualStart] = React.useState(0);
    const searchInputRef = React.useRef<HTMLInputElement>(null);

    const hasMatches = userData?.matches && userData.matches.length > 0;
    const crushCount = userData?.crushCount || 0;
    const lockedCrushes = userData?.lockedCrushes || [];

    // Ensure arrays are defined before using sort
    const safeSelectedNames = selectedNames || [];
    const safeSavedNames = savedNames || [];
    const hasUnsavedChanges = JSON.stringify([...safeSelectedNames].sort()) !== JSON.stringify([...safeSavedNames].sort());

    // Get the appropriate class names based on user's class
    const classNames = userData?.userClass === 'gsb' ? GSB_CLASS_NAMES : UNDERGRAD_CLASS_NAMES;
    const classDisplayName = userData?.userClass === 'gsb' ? 'GSB MBA' : 'Undergraduate';

    // Handle search input change
    const handleSearchChange = React.useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
        setSearchTerm(e.target.value);
        setVirtualStart(0); // Reset scroll when search changes
    }, [setSearchTerm]);

    // Fast filtering with optimized name matching
    const filteredAvailableNames = React.useMemo(() => {
        const excludedNames = [...safeSelectedNames];

        if (userData?.name) {
            excludedNames.push(userData.name);
        }

        const availableNames = classNames.filter(name => !excludedNames.includes(name));

        if (!searchTerm.trim()) return availableNames;

        // Apply fast matching and sort by relevance score
        const matchedNames = availableNames
            .map(name => {
                const result = matchesSearchTerm(name, searchTerm);
                return { name, ...result };
            })
            .filter(item => item.matches)
            .sort((a, b) => b.score - a.score)
            .map(item => item.name);

        return matchedNames;
    }, [safeSelectedNames, searchTerm, userData?.name, classNames]);

    // Virtual scrolling constants
    const ITEM_HEIGHT = 48;
    const VISIBLE_ITEMS = Math.min(15, Math.max(8, Math.floor(window.innerHeight * 0.4 / ITEM_HEIGHT)));
    const BUFFER_SIZE = 5;

    // Calculate visible range for virtual scrolling
    const startIndex = Math.max(0, virtualStart - BUFFER_SIZE);
    const endIndex = Math.min(filteredAvailableNames.length, virtualStart + VISIBLE_ITEMS + BUFFER_SIZE);
    const visibleNames = filteredAvailableNames.slice(startIndex, endIndex);

    // Handle scroll for virtual scrolling
    const handleScroll = React.useCallback((e: React.UIEvent<HTMLDivElement>) => {
        const scrollTop = e.currentTarget.scrollTop;
        const newStart = Math.floor(scrollTop / ITEM_HEIGHT);

        if (Math.abs(newStart - virtualStart) > 2) {
            setVirtualStart(newStart);
        }
    }, [virtualStart]);

    // Clear search function
    const clearSearch = React.useCallback(() => {
        setSearchTerm('');
        setVirtualStart(0);
        if (searchInputRef.current) {
            searchInputRef.current.focus();
        }
    }, [setSearchTerm]);

    // Simple function that just returns the name without highlighting
    const highlightMatch = React.useCallback((name: string, _searchTerm: string) => {
        return name;
    }, []);

    return (
        <>
            {crushCount > 0 && (
                <div className="crush-count-section">
                    <h2>{crushCount} {crushCount === 1 ? 'person is' : 'people are'} crushing on you!</h2>
                </div>
            )}

            {hasMatches && (
                <div className="matches-section">
                    <h2>ðŸŽ‰ You have {userData.matches.length} match{userData.matches.length > 1 ? 'es' : ''}!</h2>
                    <div className="matches-list">
                        {userData.matches.map((match, index) => (
                            <div key={index} className="match-item">
                                <div className="match-name">{match.name}</div>
                                <div className="match-email">{match.email}</div>
                            </div>
                        ))}
                    </div>
                </div>
            )}

            <div className="header-section">
                <div className="instructions">
                    <ol>
                        <li>Select any classmates you'd like to connect with. Your selections are completely private - only you can see who you've chosen.</li>
                        <li>Click "Update Preferences" to save your changes. Matches appear automatically when someone you've selected also selects you. Matches are completely private.</li>
                        <li>You can add or remove names anytime. There's no limit on how many people you can select, and you can change your preferences as often as you want.</li>
                        <li>Once you match with someone, you cannot remove them from your list.</li>
                    </ol>
                </div>
            </div>

            <div className="selection-counter">
                {safeSelectedNames.length} selected
                {hasUnsavedChanges && <span className="unsaved-badge">UNSAVED CHANGES</span>}
            </div>

            {safeSelectedNames.length > 0 && (
                <div className="selected-names">
                    <h3>Your Selections ({safeSelectedNames.length})</h3>
                    <div className="name-chips">
                        {safeSelectedNames.map(name => {
                            const isLocked = lockedCrushes.includes(name);
                            return (
                                <div key={name} className={`name-chip ${isLocked ? 'locked' : 'selected'}`}>
                                    <span>{name}</span>
                                    {isLocked ? (
                                        <span className="lock-icon" title="Locked - you have matched with this person">ðŸ”’</span>
                                    ) : (
                                        <button
                                            onClick={() => handleRemoveSelected(name)}
                                            className="remove-btn"
                                            aria-label={`Remove ${name}`}
                                            disabled={updating}
                                        >
                                            Ã—
                                        </button>
                                    )}
                                </div>
                            );
                        })}
                    </div>
                </div>
            )}

            <div className="search-section">
                <div className="search-input-container">
                    <input
                        ref={searchInputRef}
                        type="text"
                        placeholder={`Search ${classDisplayName} classmates...`}
                        value={searchTerm}
                        onChange={handleSearchChange}
                        className="search-input"
                    />
                    {searchTerm && (
                        <button
                            onClick={clearSearch}
                            className="search-clear-btn"
                            type="button"
                            aria-label="Clear search"
                        >
                            Ã—
                        </button>
                    )}
                </div>
                {searchTerm && filteredAvailableNames.length > 0 && (
                    <div className="search-hint">
                        ðŸ’¡ {filteredAvailableNames.length} results found. Try "first last" for best results.
                    </div>
                )}
            </div>

            <div className="available-names">
                <h3>
                    Classmates
                    {searchTerm && ` (${filteredAvailableNames.length} found)`}
                    {!searchTerm && ` (${filteredAvailableNames.length} available)`}
                </h3>
                <div
                    className="names-simple-list"
                    onScroll={handleScroll}
                    style={{ height: `${VISIBLE_ITEMS * ITEM_HEIGHT}px` }}
                >
                    {/* Spacer for items before visible range */}
                    {startIndex > 0 && (
                        <div style={{ height: `${startIndex * ITEM_HEIGHT}px` }} />
                    )}

                    {visibleNames.map((name, index) => {
                        const actualIndex = startIndex + index;
                        return (
                            <div
                                key={`${name}-${actualIndex}`}
                                onClick={() => !updating && handleNameToggle(name)}
                                className={`name-list-item ${updating ? 'disabled' : ''}`}
                                style={{
                                    height: `${ITEM_HEIGHT}px`,
                                    minHeight: `${ITEM_HEIGHT}px`
                                }}
                            >
                                <span className="name-text">
                                    {highlightMatch(name, searchTerm)}
                                </span>
                                <span className="add-btn">+</span>
                            </div>
                        );
                    })}

                    {/* Spacer for items after visible range */}
                    {endIndex < filteredAvailableNames.length && (
                        <div style={{ height: `${(filteredAvailableNames.length - endIndex) * ITEM_HEIGHT}px` }} />
                    )}

                    {filteredAvailableNames.length === 0 && (
                        <div className="no-results">
                            {searchTerm ? (
                                <>
                                    No names found matching "{searchTerm}".
                                    <br />
                                    <small>Try searching with just first and last name (e.g., "john smith")</small>
                                    <button onClick={clearSearch} className="clear-search-link">
                                        Clear search
                                    </button>
                                </>
                            ) : (
                                'All classmates have been selected!'
                            )}
                        </div>
                    )}
                </div>
            </div>

            <div className="action-section">
                <div className="action-buttons">
                    <button
                        onClick={handleUpdatePreferences}
                        disabled={updating || !hasUnsavedChanges}
                        className="update-btn"
                    >
                        {updating ? 'Updating...' : 'Update Preferences'}
                    </button>
                </div>
            </div>

            {error && (
                <div className="error-message" style={{ color: 'red', textAlign: 'center', marginTop: '15px' }}>
                    {error}
                </div>
            )}
        </>
    );
};

export default UserDashboard;

================
File: src/components/admin/AdminUsers.tsx
================
import React, { useMemo, useCallback, useEffect, useRef } from 'react';
import type { UserData, MatchInfo, UserClass } from '../../types/userTypes';

interface CrusherInfo {
    name: string;
    email: string;
}

interface InactiveUser {
    uid: string;
    email: string;
    name: string;
    photoURL: string;
    crushes: string[];
    lockedCrushes: string[];
    matches: MatchInfo[];
    crushCount: number;
    userClass: UserClass;
    isInactive: boolean;
    createdAt: any;
    updatedAt: any;
    lastLogin: any;
}

interface GhostUser {
    uid: string;
    email: string;
    name: string;
    photoURL: string;
    crushes: string[];
    lockedCrushes: string[];
    matches: MatchInfo[];
    crushCount: number;
    userClass: UserClass;
    isGhost: boolean;
    createdAt: any;
    updatedAt: any;
    lastLogin: any;
}

type UserFilter = 'all' | 'active' | 'inactive' | 'ghost';

interface AdminUsersProps {
    allUsers: (UserData | InactiveUser | GhostUser)[];
    loadingUsers: boolean;
    adminSearchTerm: string;
    setAdminSearchTerm: (term: string) => void;
    userFilter: UserFilter;
    setUserFilter: (filter: UserFilter) => void;
    viewingUserId: string | null;
    handleViewUser: (userId: string) => void;
    findCrushersForUser: (user: UserData | InactiveUser | GhostUser) => CrusherInfo[];
    userStats: {
        activeUsers: number;
        inactiveUsers: number;
        ghostUsers: number;
        total: number;
    };
    classView: 'gsb' | 'undergrad';
    classDisplayName: string;
}

// Helper function to format match timestamp for admin view
const formatAdminMatchTimestamp = (matchedAt: any): string => {
    if (!matchedAt) return 'Unknown';

    let date: Date;

    // Handle Firestore Timestamp
    if (matchedAt && typeof matchedAt.toDate === 'function') {
        date = matchedAt.toDate();
    } else if (matchedAt && matchedAt.seconds) {
        date = new Date(matchedAt.seconds * 1000);
    } else if (matchedAt instanceof Date) {
        date = matchedAt;
    } else {
        date = new Date(matchedAt);
    }

    const now = new Date();
    const diffInSeconds = Math.floor((now.getTime() - date.getTime()) / 1000);

    if (diffInSeconds < 60) {
        return 'Just now';
    } else if (diffInSeconds < 3600) {
        const minutes = Math.floor(diffInSeconds / 60);
        return `${minutes}m ago`;
    } else if (diffInSeconds < 86400) {
        const hours = Math.floor(diffInSeconds / 3600);
        return `${hours}h ago`;
    } else if (diffInSeconds < 604800) {
        const days = Math.floor(diffInSeconds / 86400);
        return `${days}d ago`;
    } else {
        return date.toLocaleDateString('en-US', {
            month: 'short',
            day: 'numeric',
            year: date.getFullYear() !== now.getFullYear() ? 'numeric' : undefined
        });
    }
};

// Use the exact same search function as the normal user search
const matchesSearchTerm = (searchableText: string, searchTerm: string): { matches: boolean; score: number } => {
    if (!searchTerm.trim()) return { matches: true, score: 0 };

    const normalizeText = (text: string) => text.toLowerCase().trim();
    const normalizedText = normalizeText(searchableText);
    const normalizedSearch = normalizeText(searchTerm);

    // Exact substring match (highest priority)
    if (normalizedText.includes(normalizedSearch)) {
        return { matches: true, score: 100 };
    }

    const textParts = normalizedText.split(' ').filter(Boolean);
    const searchParts = normalizedSearch.split(' ').filter(Boolean);

    // First + Last name matching (most common use case)
    if (searchParts.length >= 2) {
        const searchFirst = searchParts[0];
        const searchLast = searchParts[searchParts.length - 1];

        if (textParts.length >= 2) {
            const textFirst = textParts[0];
            const textLast = textParts[textParts.length - 1];

            // Exact first + last match
            if (textFirst === searchFirst && textLast === searchLast) {
                return { matches: true, score: 95 };
            }

            // Partial first + exact last
            if (textFirst.startsWith(searchFirst) && textLast === searchLast) {
                return { matches: true, score: 90 };
            }

            // Exact first + partial last
            if (textFirst === searchFirst && textLast.startsWith(searchLast)) {
                return { matches: true, score: 85 };
            }
        }
    }

    // Single term matching
    if (searchParts.length === 1) {
        const searchTerm = searchParts[0];

        // Check if any text part starts with search term
        if (textParts.some(part => part.startsWith(searchTerm))) {
            return { matches: true, score: 80 };
        }
    }

    // Multi-word progressive matching
    let textIndex = 0;
    let matchedParts = 0;

    for (const searchPart of searchParts) {
        for (let i = textIndex; i < textParts.length; i++) {
            if (textParts[i].startsWith(searchPart)) {
                matchedParts++;
                textIndex = i + 1;
                break;
            }
        }
    }

    if (matchedParts === searchParts.length) {
        return { matches: true, score: 75 };
    }

    return { matches: false, score: 0 };
};

// Simple function that just returns the text without highlighting
const highlightMatch = (text: string, _searchTerm: string) => {
    return text;
};

const AdminUsers: React.FC<AdminUsersProps> = ({
    allUsers,
    loadingUsers,
    adminSearchTerm,
    setAdminSearchTerm,
    userFilter,
    setUserFilter,
    viewingUserId,
    handleViewUser,
    findCrushersForUser,
    userStats,
    classDisplayName
}) => {
    const searchInputRef = useRef<HTMLInputElement>(null);
    const containerRef = useRef<HTMLDivElement>(null);
    const scrollRestoreRef = useRef<{ scrollTop: number; timestamp: number } | null>(null);

    // Reset scroll when search term or filter changes
    useEffect(() => {
        if (containerRef.current) {
            containerRef.current.scrollTop = 0;
            scrollRestoreRef.current = null;
        }
    }, [adminSearchTerm, userFilter]);

    // Restore scroll position after viewingUserId changes
    useEffect(() => {
        if (scrollRestoreRef.current && containerRef.current) {
            const { scrollTop, timestamp } = scrollRestoreRef.current;

            // Only restore if this is a recent change (within 100ms)
            if (Date.now() - timestamp < 100) {
                // Use multiple methods to ensure scroll restoration
                const restoreScroll = () => {
                    if (containerRef.current) {
                        containerRef.current.scrollTop = scrollTop;
                    }
                };

                // Immediate restoration
                restoreScroll();

                // Delayed restoration to catch any layout shifts
                requestAnimationFrame(() => {
                    restoreScroll();
                    setTimeout(restoreScroll, 0);
                    setTimeout(restoreScroll, 10);
                });
            }

            // Clear the restore reference
            scrollRestoreRef.current = null;
        }
    }, [viewingUserId]);

    // Enhanced handleViewUser that captures scroll position
    const handleViewUserWithScrollPreservation = useCallback((userId: string) => {
        if (containerRef.current) {
            // Capture current scroll position with timestamp
            scrollRestoreRef.current = {
                scrollTop: containerRef.current.scrollTop,
                timestamp: Date.now()
            };
        }

        // Trigger the actual view change
        handleViewUser(userId);
    }, [handleViewUser]);

    const handleAdminSearchChange = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
        const newValue = e.target.value;
        setAdminSearchTerm(newValue);
    }, [setAdminSearchTerm]);

    // Clear search function
    const clearAdminSearch = useCallback(() => {
        setAdminSearchTerm('');
        if (searchInputRef.current) {
            searchInputRef.current.focus();
        }
    }, [setAdminSearchTerm]);

    // Use the exact same filtering logic as normal search with better debugging
    const filteredUsers = useMemo(() => {
        console.log('Admin filtering - Search term:', `"${adminSearchTerm}"`, 'Filter:', userFilter, 'All users count:', allUsers.length);

        let users = allUsers;

        // Apply user type filter first
        switch (userFilter) {
            case 'active':
                users = users.filter(u =>
                    !(u as InactiveUser).isInactive && !(u as GhostUser).isGhost
                );
                break;
            case 'inactive':
                users = users.filter(u => (u as InactiveUser).isInactive);
                break;
            case 'ghost':
                users = users.filter(u => (u as GhostUser).isGhost);
                break;
            case 'all':
            default:
                break;
        }

        console.log('After filter:', users.length, 'users');

        // Apply search filter - key fix: explicit empty string check
        const trimmedSearch = adminSearchTerm.trim();
        if (trimmedSearch === '') {
            console.log('Empty search, returning all filtered users');
            return users;
        }

        console.log('Applying search for:', `"${trimmedSearch}"`);

        const matchedUsers = users
            .map(user => {
                // Search in both name and email
                const searchableTexts = [
                    user.name || '',
                    user.email || ''
                ].filter(Boolean);

                let bestMatch = { matches: false, score: 0 };

                // Test each searchable text and take the best match
                for (const text of searchableTexts) {
                    const result = matchesSearchTerm(text, trimmedSearch);
                    if (result.matches && result.score > bestMatch.score) {
                        bestMatch = result;
                    }
                }

                return { user, ...bestMatch };
            })
            .filter(item => item.matches)
            .sort((a, b) => b.score - a.score)
            .map(item => item.user);

        console.log('Search results:', matchedUsers.length, 'users');
        return matchedUsers;
    }, [allUsers, adminSearchTerm, userFilter]);

    const UserItem = React.memo(({ u }: { u: UserData | InactiveUser | GhostUser }) => {
        const isViewing = viewingUserId === u.uid;
        const actualCrushCount = u.crushCount || 0;
        const crushers = findCrushersForUser(u);
        const isInactive = (u as InactiveUser).isInactive || false;
        const isGhost = (u as GhostUser).isGhost || false;

        const displayName = u.name || u.email;
        const hasName = !!(u.name && u.name.trim());

        let userTypeClass = '';
        let userTypeLabel = '';

        if (isGhost) {
            userTypeClass = 'admin-user-ghost';
            userTypeLabel = 'ðŸ‘» Ghost User';
        } else if (isInactive) {
            userTypeClass = 'admin-user-inactive';
            userTypeLabel = 'ðŸ’¤ Inactive User';
        }

        return (
            <div
                className={`admin-user-item ${userTypeClass}`}
                data-user-id={u.uid}
                key={u.uid}
            >
                <div className="admin-user-header">
                    <div className="admin-user-info">
                        <div className="admin-user-name">
                            {highlightMatch(displayName, adminSearchTerm)}
                            {userTypeLabel && (
                                <span className="user-type-label">
                                    {userTypeLabel}
                                </span>
                            )}
                            {!isInactive && !isGhost && !hasName && (
                                <span className="no-name-indicator">
                                    (No name set)
                                </span>
                            )}
                        </div>
                        <div className="admin-user-email">
                            {highlightMatch(u.email, adminSearchTerm)}
                        </div>
                        <div className="admin-user-stats">
                            {actualCrushCount} crushing â€¢ {u.matches?.length || 0} matches â€¢ {u.crushes?.length || 0} selected
                            {!isInactive && !isGhost && actualCrushCount !== crushers.length && (
                                <span className="discrepancy-indicator">
                                    (calc: {crushers.length})
                                </span>
                            )}
                        </div>
                    </div>
                    <button
                        onClick={() => handleViewUserWithScrollPreservation(u.uid)}
                        className="admin-view-btn"
                        disabled={isGhost}
                    >
                        {isGhost ? 'Ghost' : (isViewing ? 'Collapse' : 'View')}
                    </button>
                </div>

                {isViewing && !isGhost && (
                    <div className="admin-user-expanded">
                        <div className="admin-view-header">
                            <h4>Data for {displayName} ({classDisplayName}):</h4>
                            {isInactive && (
                                <div style={{
                                    background: '#fff3cd',
                                    color: '#856404',
                                    padding: '8px 12px',
                                    borderRadius: '4px',
                                    fontSize: '12px',
                                    fontWeight: '600',
                                    marginTop: '8px'
                                }}>
                                    ðŸ’¤ This is an inactive user - they haven't signed up yet but are receiving crushes
                                </div>
                            )}
                        </div>

                        <div className="admin-data-grid">
                            <div className="admin-data-card">
                                <div className="admin-data-number">{actualCrushCount}</div>
                                <div className="admin-data-label">People Crushing On Them</div>
                                {crushers.length > 0 && (
                                    <div className="admin-data-names">
                                        {crushers.map((crusher, idx) => (
                                            <div key={idx} className="admin-name-item">
                                                {crusher.name}
                                            </div>
                                        ))}
                                    </div>
                                )}
                                {actualCrushCount !== crushers.length && (
                                    <div className="admin-discrepancy">
                                        âš ï¸ DB shows {actualCrushCount}, calc shows {crushers.length}
                                    </div>
                                )}
                            </div>

                            <div className="admin-data-card">
                                <div className="admin-data-number">{u.matches?.length || 0}</div>
                                <div className="admin-data-label">Matches</div>
                                {u.matches && u.matches.length > 0 && (
                                    <div className="admin-data-names">
                                        {u.matches.map((match, idx) => (
                                            <div key={idx} className="admin-name-item admin-match-with-timestamp">
                                                <div className="admin-match-name">{match.name}</div>
                                                <div className="admin-match-timestamp">
                                                    {formatAdminMatchTimestamp(match.matchedAt)}
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                )}
                                {isInactive && (
                                    <div style={{
                                        fontSize: '11px',
                                        color: '#666',
                                        fontStyle: 'italic',
                                        marginTop: '8px'
                                    }}>
                                        Inactive users cannot have matches until they sign up
                                    </div>
                                )}
                            </div>

                            <div className="admin-data-card">
                                <div className="admin-data-number">{u.crushes?.length || 0}</div>
                                <div className="admin-data-label">Crushes Sent</div>
                                {u.crushes && u.crushes.length > 0 && (
                                    <div className="admin-data-names">
                                        {u.crushes.map((crush, idx) => {
                                            const isLocked = u.lockedCrushes?.includes(crush);
                                            return (
                                                <div key={idx} className={`admin-name-item ${isLocked ? 'locked' : ''}`}>
                                                    {crush} {isLocked && 'ðŸ”’'}
                                                </div>
                                            );
                                        })}
                                    </div>
                                )}
                                {isInactive && (
                                    <div style={{
                                        fontSize: '11px',
                                        color: '#666',
                                        fontStyle: 'italic',
                                        marginTop: '8px'
                                    }}>
                                        Inactive users cannot send crushes until they sign up
                                    </div>
                                )}
                            </div>
                        </div>

                        {actualCrushCount === 0 && (!u.matches || u.matches.length === 0) && (!u.crushes || u.crushes.length === 0) && (
                            <div className="admin-no-activity">
                                No activity
                            </div>
                        )}
                    </div>
                )}
            </div>
        );
    });

    UserItem.displayName = 'UserItem';

    return (
        <div className="admin-users">
            <div className="admin-class-users-header">
                <h4>{classDisplayName} Users Management</h4>
                <div className="admin-class-users-summary">
                    <span>Active: {userStats.activeUsers}</span>
                    <span>Inactive: {userStats.inactiveUsers}</span>
                    <span>Ghost: {userStats.ghostUsers}</span>
                    <span>Total: {userStats.total}</span>
                </div>
            </div>

            <div className="admin-controls">
                <div className="admin-search-section">
                    <div className="admin-search-input-container">
                        <input
                            ref={searchInputRef}
                            type="text"
                            placeholder={`Search ${classDisplayName} users by name or email...`}
                            value={adminSearchTerm}
                            onChange={handleAdminSearchChange}
                            className="admin-search-input"
                        />
                        {adminSearchTerm && (
                            <button
                                onClick={clearAdminSearch}
                                className="admin-search-clear-btn"
                                type="button"
                                aria-label="Clear search"
                            >
                                Ã—
                            </button>
                        )}
                    </div>
                    {adminSearchTerm && filteredUsers.length > 0 && (
                        <div className="admin-search-hint">
                            ðŸ’¡ {filteredUsers.length} results found. Try "first last" for best results.
                        </div>
                    )}
                    {filteredUsers.length > 50 && (
                        <div className="admin-pagination-info">
                            Showing all {filteredUsers.length} {classDisplayName} users
                        </div>
                    )}
                </div>
                <div className="admin-filter-section">
                    <select
                        value={userFilter}
                        onChange={(e) => setUserFilter(e.target.value as UserFilter)}
                        className="admin-filter-dropdown"
                    >
                        <option value="all">All {classDisplayName} Users ({userStats.total})</option>
                        <option value="active">Active Users ({userStats.activeUsers})</option>
                        <option value="inactive">Inactive Users ({userStats.inactiveUsers})</option>
                        <option value="ghost">Ghost Users ({userStats.ghostUsers})</option>
                    </select>
                </div>
            </div>

            {loadingUsers ? (
                <div className="loading">Loading {classDisplayName} users...</div>
            ) : (
                <div
                    ref={containerRef}
                    className="admin-users-container"
                    style={{ scrollBehavior: 'auto' }}
                >
                    {filteredUsers.map((u) => (
                        <UserItem key={u.uid} u={u} />
                    ))}

                    {filteredUsers.length === 0 && (
                        <div className="no-results">
                            {adminSearchTerm ? (
                                <>
                                    No {classDisplayName} users found matching "{adminSearchTerm}".
                                    <br />
                                    <small>Try searching with first and last name (e.g., "john smith")</small>
                                    <button onClick={clearAdminSearch} className="admin-clear-search-link">
                                        Clear search
                                    </button>
                                </>
                            ) : (
                                `No ${classDisplayName} users available.`
                            )}
                        </div>
                    )}
                </div>
            )}
        </div>
    );
};

export default AdminUsers;

================
File: .gitignore
================
.gitignore
node_modules
public
src/data
repomix.config.json
repomix-output.txt
firebase.json
firestore.indexes.json
firestore.rules
functions/src/serviceAccountKey.json
.vercel

================
File: vercel.json
================
{
    "version": 2,
    "public": true,
    "buildCommand": "npm run build",
    "outputDirectory": "dist",
    "installCommand": "npm install",
    "framework": "vite",
    "redirects": [
        {
            "source": "/login",
            "destination": "https://pastchances.com",
            "permanent": true
        }
    ],
    "headers": [
        {
            "source": "/stanford.png",
            "headers": [
                {
                    "key": "Content-Type",
                    "value": "image/png"
                },
                {
                    "key": "Cache-Control",
                    "value": "public, max-age=86400, must-revalidate"
                },
                {
                    "key": "Access-Control-Allow-Origin",
                    "value": "*"
                }
            ]
        },
        {
            "source": "/stanford.svg",
            "headers": [
                {
                    "key": "Content-Type",
                    "value": "image/svg+xml"
                },
                {
                    "key": "Cache-Control",
                    "value": "public, max-age=86400, must-revalidate"
                },
                {
                    "key": "Access-Control-Allow-Origin",
                    "value": "*"
                }
            ]
        },
        {
            "source": "/share.png",
            "headers": [
                {
                    "key": "Content-Type",
                    "value": "image/png"
                },
                {
                    "key": "Cache-Control",
                    "value": "public, max-age=86400, must-revalidate"
                },
                {
                    "key": "Access-Control-Allow-Origin",
                    "value": "*"
                }
            ]
        },
        {
            "source": "/robots.txt",
            "headers": [
                {
                    "key": "Content-Type",
                    "value": "text/plain"
                },
                {
                    "key": "Cache-Control",
                    "value": "public, max-age=3600, must-revalidate"
                }
            ]
        },
        {
            "source": "/sitemap.xml",
            "headers": [
                {
                    "key": "Content-Type",
                    "value": "application/xml"
                },
                {
                    "key": "Cache-Control",
                    "value": "public, max-age=3600, must-revalidate"
                }
            ]
        },
        {
            "source": "/(.*)",
            "headers": [
                {
                    "key": "X-Frame-Options",
                    "value": "DENY"
                },
                {
                    "key": "X-Content-Type-Options",
                    "value": "nosniff"
                }
            ]
        }
    ],
    "rewrites": [
        {
            "source": "/((?!.*\\.).*)",
            "destination": "/index.html"
        }
    ]
}

================
File: scripts/deploy.sh
================
#!/bin/bash

# Exit on any error
set -e

echo "ðŸš€ Starting comprehensive deployment..."

cd .. 

# Clean everything
echo "ðŸ§¹ Cleaning..."
rm -rf dist
rm -rf .vercel

# Verify source files
echo "ðŸ“‹ Verifying source files..."
for file in stanford.png stanford.svg share.png robots.txt sitemap.xml; do
    if [ ! -f "public/$file" ]; then
        echo "âŒ Missing: public/$file"
        exit 1
    fi
    echo "âœ… Found: public/$file ($(ls -lh "public/$file" | awk '{print $5}'))"
done

# Build
echo "ðŸ”¨ Building..."
npm run build

# Verify dist was created
if [ ! -d "dist" ]; then
    echo "âŒ dist directory not created!"
    exit 1
fi

# Force copy files manually with bash
echo "ðŸ“ Force copying files..."
for file in stanford.png stanford.svg share.png robots.txt sitemap.xml; do
    if [ -f "public/$file" ]; then
        cp "public/$file" "dist/$file"
        if [ -f "dist/$file" ]; then
            echo "âœ… Copied $file ($(ls -lh "dist/$file" | awk '{print $5}'))"
        else
            echo "âŒ Failed to copy $file"
            exit 1
        fi
    fi
done

# Verify all critical files are in dist
echo "ðŸ” Final verification..."
ls -la dist/

echo "ðŸ“ Critical files in dist:"
for file in stanford.png stanford.svg share.png; do
    if [ -f "dist/$file" ]; then
        ls -lh "dist/$file"
    else
        echo "âŒ CRITICAL: dist/$file missing!"
        exit 1
    fi
done

# Git commit and push BEFORE deployment
echo "ðŸ“ Committing changes..."
git add .
if ! git diff --staged --quiet; then
    git commit -m "Deploy with verified static files - $(date '+%Y-%m-%d %H:%M:%S')"
    git push
    echo "ðŸ“¤ Changes pushed to git"
else
    echo "ðŸ“ No changes to commit"
fi

# Deploy to Firebase
echo "ðŸ”¥ Firebase deploy..."
firebase deploy --only functions,firestore

# Deploy to Vercel
echo "â˜ï¸ Vercel deploy..."
npx vercel --prod --public --yes

# Get the latest deployment URL
echo "ðŸ” Getting latest deployment URL..."
sleep 3
LATEST_URL=$(npx vercel ls | grep "https://" | head -1 | awk '{print $2}')
echo "Latest deployment: $LATEST_URL"

# Test files on both URLs
echo "ðŸ§ª Testing files..."
sleep 5

echo "Testing on latest deployment URL:"
for file in stanford.png stanford.svg share.png; do
    echo -n "  $file: "
    curl -s -o /dev/null -w "HTTP %{http_code} (%{size_download} bytes)" "$LATEST_URL/$file"
    echo ""
done

echo "Testing on custom domain:"
for file in stanford.png stanford.svg share.png; do
    echo -n "  $file: "
    curl -s -o /dev/null -w "HTTP %{size_download} bytes)" "https://pastchances.com/$file"
    echo ""
done

echo ""
echo "ðŸŽ‰ Deployment complete!"
echo ""
echo "ðŸ”§ Next steps:"
echo "1. Wait 30 seconds for full propagation"
echo "2. Run: cd scripts/tools && node test-images.js"
echo "3. Clear browser cache and test favicon"
echo "4. Test social media previews"

================
File: src/styles/admin.css
================
/* Admin View Main Styles */
@import './admin/admin-base.css';
@import './admin/admin-layout.css';
@import './admin/admin-responsive.css';

================
File: index.html
================
<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8" />

  <!-- Multiple favicon sizes for better display -->
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png" />
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png" />
  <link rel="icon" type="image/png" sizes="48x48" href="/favicon-48x48.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
  <link rel="icon" type="image/png" sizes="192x192" href="/android-chrome-192x192.png" />
  <link rel="icon" type="image/png" sizes="512x512" href="/android-chrome-512x512.png" />

  <!-- Fallback favicon -->
  <link rel="shortcut icon" href="/favicon.ico" />

  <!-- SVG favicon for modern browsers (maintains vector quality) -->
  <link rel="icon" type="image/svg+xml" href="/stanford.svg" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Past Chances</title>

  <!-- Open Graph Meta Tags for Social Sharing -->
  <meta property="og:title" content="Past Chances" />
  <meta property="og:description"
    content="Share your crushes anonymously and see if there's a mutual connection. The site will remain active until our Stanford accounts expire in October 2025." />
  <meta property="og:image" content="https://pastchances.com/share.png" />
  <meta property="og:image:width" content="1200" />
  <meta property="og:image:height" content="630" />
  <meta property="og:image:type" content="image/png" />
  <meta property="og:url" content="https://pastchances.com" />
  <meta property="og:type" content="website" />
  <meta property="og:site_name" content="Past Chances" />

  <!-- Twitter Card Meta Tags -->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="Past Chances" />
  <meta name="twitter:description" content="Share your crushes anonymously and see if there's a mutual connection." />
  <meta name="twitter:image" content="https://pastchances.com/share.png" />
  <meta name="twitter:image:width" content="1200" />
  <meta name="twitter:image:height" content="630" />

  <!-- Standard Meta Tags -->
  <meta name="description"
    content="Share your crushes anonymously and see if there's a mutual connection." />
  <meta name="author" content="Past Chances" />

  <!-- Preload critical images -->
  <link rel="preload" as="image" href="/share.png" />
</head>

<body>
  <div id="root"></div>
  <script type="module" src="/src/main.tsx"></script>
</body>

</html>

================
File: functions/src/matchingEngine.ts
================
import * as admin from 'firebase-admin';
import { UserWithId, MatchInfo } from './types';
import { findUserByName, getUserIdentityName } from './utils';

// Initialize Firebase Admin if not already initialized
if (!admin.apps.length) {
    admin.initializeApp();
}

const db = admin.firestore();

// Helper function to determine if a match should have a timestamp
function shouldMatchHaveTimestamp(user1Id: string, user2Id: string, user1Name: string, user2Name: string): boolean {
    // Check if either user is James Park (by document ID containing jpark22@stanford.edu OR by name)
    const isUser1JamesPark = user1Id.includes('jpark22@stanford.edu') ||
        user1Name === 'James Park' ||
        user1Id.includes('_gsb') && user1Id.includes('jpark22@stanford.edu') ||
        user1Id.includes('_undergrad') && user1Id.includes('jpark22@stanford.edu');

    const isUser2JamesPark = user2Id.includes('jpark22@stanford.edu') ||
        user2Name === 'James Park' ||
        user2Id.includes('_gsb') && user2Id.includes('jpark22@stanford.edu') ||
        user2Id.includes('_undergrad') && user2Id.includes('jpark22@stanford.edu');

    // Skip timestamp for ANY James Park matches (GSB or undergrad)
    if (isUser1JamesPark || isUser2JamesPark) {
        console.log(`ðŸš« Skipping timestamp for James Park match: ${user1Name} â†” ${user2Name}`);
        return false;
    }

    // All other matches should have timestamps
    return true;
}

// Enhanced function to recalculate all matches and crush counts with better name matching
// Now respects class boundaries - GSB students can only match with GSB, undergrads with undergrads
export async function processUpdatedCrushes(): Promise<void> {
    console.log('ðŸ”„ Starting enhanced recalculation of all matches and crush counts with class separation...');

    try {
        await db.runTransaction(async (transaction) => {
            // Get all users
            const allUsersSnapshot = await transaction.get(db.collection('users'));

            const allUsers: UserWithId[] = allUsersSnapshot.docs.map(doc => ({
                id: doc.id,
                ...doc.data() as any
            }));

            console.log(`ðŸ“Š Processing ${allUsers.length} users`);

            // Separate users by class
            const gsbUsers = allUsers.filter(user => user.userClass === 'gsb' || !user.userClass); // Default to GSB for backwards compatibility
            const undergradUsers = allUsers.filter(user => user.userClass === 'undergrad');

            console.log(`ðŸ“Š GSB users: ${gsbUsers.length}, Undergrad users: ${undergradUsers.length}`);

            // Enhanced crush count calculation with better name matching and class separation
            const crushCounts = new Map<string, number>();
            const crushersMap = new Map<string, string[]>(); // Track who is crushing on whom

            // Process GSB users
            for (const user of gsbUsers) {
                const userCrushes = user.crushes || [];
                for (const crushName of userCrushes) {
                    // Find the actual user that matches this crush name within GSB class
                    const targetUser = findUserByName(crushName, gsbUsers, 'gsb');

                    if (targetUser) {
                        // Use the user's identity name
                        const actualName = getUserIdentityName(targetUser);
                        if (actualName) {
                            const key = `gsb:${actualName}`;
                            crushCounts.set(key, (crushCounts.get(key) || 0) + 1);

                            // Track the crusher
                            if (!crushersMap.has(key)) {
                                crushersMap.set(key, []);
                            }
                            crushersMap.get(key)!.push(getUserIdentityName(user) || user.email);
                        }
                    } else {
                        // If no user found, still count it but use the crush name directly
                        console.log(`âš ï¸ No GSB user found for crush name: "${crushName}" - counting anyway`);
                        const key = `gsb:${crushName}`;
                        crushCounts.set(key, (crushCounts.get(key) || 0) + 1);

                        // Track the crusher for orphaned crushes too
                        if (!crushersMap.has(key)) {
                            crushersMap.set(key, []);
                        }
                        crushersMap.get(key)!.push(getUserIdentityName(user) || user.email);
                    }
                }
            }

            // Process Undergrad users
            for (const user of undergradUsers) {
                const userCrushes = user.crushes || [];
                for (const crushName of userCrushes) {
                    // Find the actual user that matches this crush name within undergrad class
                    const targetUser = findUserByName(crushName, undergradUsers, 'undergrad');

                    if (targetUser) {
                        // Use the user's identity name
                        const actualName = getUserIdentityName(targetUser);
                        if (actualName) {
                            const key = `undergrad:${actualName}`;
                            crushCounts.set(key, (crushCounts.get(key) || 0) + 1);

                            // Track the crusher
                            if (!crushersMap.has(key)) {
                                crushersMap.set(key, []);
                            }
                            crushersMap.get(key)!.push(getUserIdentityName(user) || user.email);
                        }
                    } else {
                        // If no user found, still count it but use the crush name directly
                        console.log(`âš ï¸ No undergrad user found for crush name: "${crushName}" - counting anyway`);
                        const key = `undergrad:${crushName}`;
                        crushCounts.set(key, (crushCounts.get(key) || 0) + 1);

                        // Track the crusher for orphaned crushes too
                        if (!crushersMap.has(key)) {
                            crushersMap.set(key, []);
                        }
                        crushersMap.get(key)!.push(getUserIdentityName(user) || user.email);
                    }
                }
            }

            console.log('ðŸ’• Enhanced crush counts calculated:', Object.fromEntries(crushCounts));

            // Calculate matches and locked crushes with enhanced matching and class separation
            const allMatches = new Map<string, MatchInfo[]>();
            const allLockedCrushes = new Map<string, string[]>();

            // Process both classes together but only allow matches within same class
            for (const user of allUsers) {
                const userMatches: MatchInfo[] = [];
                const userLockedCrushes: string[] = [];
                const userCrushes = user.crushes || [];
                const userIdentityName = getUserIdentityName(user);
                const userClass = user.userClass || 'gsb'; // Default to GSB for backwards compatibility

                if (!userIdentityName || !userIdentityName.trim()) {
                    console.log(`â­ï¸ Skipping user ${user.id} - no identity name`);
                    allMatches.set(user.id, userMatches);
                    allLockedCrushes.set(user.id, userLockedCrushes);
                    continue;
                }

                // Get users from the same class only
                const sameClassUsers = allUsers.filter(u => (u.userClass || 'gsb') === userClass);

                // Get existing matches to preserve timestamps (CRITICAL: preserve exact timestamp objects)
                const existingMatches = user.matches || [];
                const existingMatchMap = new Map<string, any>();
                existingMatches.forEach(match => {
                    if (match.name) {
                        existingMatchMap.set(match.name, match);
                    }
                });

                // Find mutual matches with enhanced name matching within same class
                for (const crushName of userCrushes) {
                    const crushedUser = findUserByName(crushName, sameClassUsers, userClass);

                    if (!crushedUser) {
                        console.log(`âš ï¸ No ${userClass} user found for crush name: "${crushName}"`);
                        continue;
                    }

                    const crushedUserCrushes = crushedUser.crushes || [];

                    // Check if it's a mutual match using enhanced matching within same class
                    const hasMutualCrush = crushedUserCrushes.some(crush => {
                        const matchedUser = findUserByName(crush, sameClassUsers, userClass);
                        return matchedUser && matchedUser.id === user.id;
                    });

                    if (hasMutualCrush) {
                        const crushedUserIdentityName = getUserIdentityName(crushedUser);

                        // Check if this is an existing match to preserve timestamp
                        const existingMatch = existingMatchMap.get(crushedUserIdentityName);

                        // Determine if this match should have a timestamp
                        const shouldHaveTimestamp = shouldMatchHaveTimestamp(user.id, crushedUser.id, userIdentityName, crushedUserIdentityName);

                        let matchInfo: MatchInfo;

                        if (shouldHaveTimestamp) {
                            if (existingMatch && existingMatch.matchedAt) {
                                // PRESERVE the exact existing timestamp object - don't convert it
                                matchInfo = {
                                    name: crushedUserIdentityName,
                                    email: crushedUser.email,
                                    matchedAt: existingMatch.matchedAt
                                };
                                console.log(`ðŸ”’ Preserving existing timestamp for ${userIdentityName} â†” ${crushedUserIdentityName}`);
                            } else {
                                // NEW MATCH - Create timestamp at the exact moment this match is discovered
                                matchInfo = {
                                    name: crushedUserIdentityName,
                                    email: crushedUser.email,
                                    matchedAt: admin.firestore.Timestamp.now() // Real-time timestamp for new matches
                                };
                                console.log(`ðŸ†• Creating new timestamp for ${userIdentityName} â†” ${crushedUserIdentityName}`);
                            }
                        } else {
                            // No timestamp for James Park matches
                            matchInfo = {
                                name: crushedUserIdentityName,
                                email: crushedUser.email
                                // No matchedAt field
                            };
                            console.log(`ðŸš« No timestamp for James Park match: ${userIdentityName} â†” ${crushedUserIdentityName}`);
                        }

                        userMatches.push(matchInfo);

                        // Lock this crush ONLY if there's a mutual match
                        if (!userLockedCrushes.includes(crushName)) {
                            userLockedCrushes.push(crushName);
                        }

                        const isNewMatch = !existingMatchMap.has(crushedUserIdentityName);
                        const timestampStatus = shouldHaveTimestamp ? (isNewMatch ? 'NEW_TIMESTAMP' : 'PRESERVED_EXISTING') : 'NO_TIMESTAMP';
                        console.log(`ðŸ’• ${userClass.toUpperCase()} Match ${isNewMatch ? 'NEW' : 'EXISTING'} (${timestampStatus}): ${userIdentityName} â†” ${crushedUserIdentityName}`);
                    }
                }

                allMatches.set(user.id, userMatches);
                allLockedCrushes.set(user.id, userLockedCrushes);
            }

            // Update all users with their matches, crush counts, and locked crushes
            for (const user of allUsers) {
                const userRef = db.collection('users').doc(user.id);
                const userIdentityName = getUserIdentityName(user);
                const userClass = user.userClass || 'gsb'; // Default to GSB for backwards compatibility

                // For crush count, we need to check the user's identity name with class prefix
                let userCrushCount = 0;
                if (userIdentityName) {
                    const key = `${userClass}:${userIdentityName}`;
                    userCrushCount = crushCounts.get(key) || 0;

                    // Log discrepancies for debugging
                    const currentCrushCount = user.crushCount || 0;
                    if (currentCrushCount !== userCrushCount) {
                        const crushers = crushersMap.get(key) || [];
                        console.log(`ðŸ”§ Fixing crush count for ${userIdentityName}: ${currentCrushCount} -> ${userCrushCount} (crushers: ${crushers.join(', ')})`);
                    }
                }

                const updateData = {
                    matches: allMatches.get(user.id) || [],
                    lockedCrushes: allLockedCrushes.get(user.id) || [],
                    crushCount: userCrushCount,
                    userClass: userClass, // Ensure userClass is set for legacy users
                    updatedAt: admin.firestore.FieldValue.serverTimestamp()
                };

                transaction.update(userRef, updateData);
            }

            console.log(`âœ… Updated all ${allUsers.length} users with enhanced matches and crush counts (class-separated)`);
        });

    } catch (error) {
        console.error('âŒ Error in enhanced processUpdatedCrushes:', error);
        throw error;
    }
}

// One-time function to set current timestamp for all existing matches (except James Park)
export async function fixAllMatchTimestampsToNow(): Promise<void> {
    console.log('ðŸ”§ Setting all existing match timestamps to now (except James Park matches)...');

    try {
        await db.runTransaction(async (transaction) => {
            // Get all users
            const allUsersSnapshot = await transaction.get(db.collection('users'));
            const currentTimestamp = admin.firestore.Timestamp.now();

            let updatedUsers = 0;
            let fixedMatches = 0;

            allUsersSnapshot.forEach(doc => {
                const userData = doc.data();
                const matches = userData.matches || [];
                const userId = doc.id;
                const userName = userData.name || userData.verifiedName || userData.displayName || userData.email;

                if (matches.length > 0) {
                    let needsUpdate = false;
                    const updatedMatches = matches.map((match: any) => {
                        // Check both the document owner AND the match partner for James Park
                        const shouldHaveTimestamp = shouldMatchHaveTimestamp(userId, '', userName, match.name || '');

                        if (shouldHaveTimestamp) {
                            // Set timestamp to now for all non-James Park matches
                            needsUpdate = true;
                            fixedMatches++;
                            console.log(`ðŸ”§ Setting timestamp to now for match: ${match.name} â†” ${userName}`);
                            return {
                                name: match.name || 'Unknown',
                                email: match.email || 'unknown@stanford.edu',
                                matchedAt: currentTimestamp
                            };
                        } else {
                            // Remove timestamp for James Park matches
                            if (match.matchedAt) {
                                needsUpdate = true;
                                console.log(`ðŸ”§ Removing timestamp for James Park match: ${match.name} â†” ${userName}`);
                            }
                            return {
                                name: match.name || 'Unknown',
                                email: match.email || 'unknown@stanford.edu'
                                // No matchedAt field
                            };
                        }
                    });

                    if (needsUpdate) {
                        const userRef = db.collection('users').doc(userId);
                        transaction.update(userRef, {
                            matches: updatedMatches,
                            updatedAt: admin.firestore.FieldValue.serverTimestamp()
                        });
                        updatedUsers++;
                    }
                }
            });

            console.log(`âœ… Fixed timestamps for ${fixedMatches} matches across ${updatedUsers} users`);
        });
    } catch (error) {
        console.error('âŒ Error fixing all match timestamps:', error);
        throw error;
    }
}

// New function to manually fix all crush count discrepancies
export async function fixAllCrushCounts(): Promise<void> {
    console.log('ðŸ”§ Starting manual fix of all crush count discrepancies...');

    try {
        await processUpdatedCrushes();
        console.log('âœ… All crush counts have been synchronized');
    } catch (error) {
        console.error('âŒ Error fixing crush counts:', error);
        throw error;
    }
}

// Legacy function - keeping for backward compatibility
export async function fixAllMatchTimestampsOnce(): Promise<void> {
    await fixAllMatchTimestampsToNow();
}

// Legacy function - keeping for backward compatibility
export async function fixMissingMatchTimestamps(): Promise<void> {
    await fixAllMatchTimestampsToNow();
}

================
File: src/contexts/AuthContext.tsx
================
import React, { createContext, useContext, useState, useEffect } from 'react';
import type { ReactNode } from 'react';
import type { User } from 'firebase/auth';
import { signInWithPopup, signOut, onAuthStateChanged } from 'firebase/auth';
import { doc, getDoc, setDoc, serverTimestamp, onSnapshot } from 'firebase/firestore';
import { auth, googleProvider, db } from '../config/firebase';
import { useAuthHelpers } from '../hooks/useAuthHelpers';
import { useUserDocumentManager } from '../hooks/useUserDocumentManager';
import type { UserData, UserClass } from '../types/userTypes';

interface AuthContextType {
    user: User | null;
    userData: UserData | null;
    loading: boolean;
    nameOptions: string[] | null;
    signInWithGoogle: (userClass: UserClass) => Promise<void>;
    selectName: (selectedName: string) => Promise<void>;
    logout: () => Promise<void>;
    refreshUserData: () => Promise<void>;
}

const AuthContext = createContext<AuthContextType | null>(null);

export const useAuth = () => {
    const context = useContext(AuthContext);
    if (!context) {
        throw new Error('useAuth must be used within an AuthProvider');
    }
    return context;
};

interface AuthProviderProps {
    children: ReactNode;
}

export const AuthProvider: React.FC<AuthProviderProps> = ({ children }) => {
    const [user, setUser] = useState<User | null>(null);
    const [userData, setUserData] = useState<UserData | null>(null);
    const [loading, setLoading] = useState(true);
    const [nameOptions, setNameOptions] = useState<string[] | null>(null);
    const [pendingUserClass, setPendingUserClass] = useState<UserClass | null>(null);

    const {
        normalizeMatches,
        getUserDocumentId,
        getLastUsedClass,
        setLastUsedClass
    } = useAuthHelpers();

    const { createOrUpdateUserDocument } = useUserDocumentManager(
        setNameOptions,
        setPendingUserClass,
        setLastUsedClass
    );

    const selectName = async (selectedName: string) => {
        if (!user?.uid || !nameOptions || !pendingUserClass) return;

        try {
            const actualUid = getUserDocumentId(user, pendingUserClass);
            const userRef = doc(db, 'users', actualUid);

            await setDoc(userRef, {
                name: selectedName,
                userClass: pendingUserClass,
                updatedAt: serverTimestamp()
            }, { merge: true });

            // Remember which class was selected
            setLastUsedClass(pendingUserClass);

            setNameOptions(null);
            setPendingUserClass(null);
            // Real-time listener will handle the update
        } catch (error) {
            console.error('Error selecting name:', error);
            throw error;
        }
    };

    // Set up real-time listener for user data
    useEffect(() => {
        if (!user?.uid) return;

        let unsubscribe: (() => void) | null = null;

        const setupListener = async () => {
            try {
                // For test user, check both documents and prefer based on last used class
                if (user.email === 'jpark22@stanford.edu') {
                    const gsbDocId = `${user.uid}_gsb`;
                    const undergradDocId = `${user.uid}_undergrad`;

                    const gsbRef = doc(db, 'users', gsbDocId);
                    const undergradRef = doc(db, 'users', undergradDocId);

                    const [gsbDoc, undergradDoc] = await Promise.all([
                        getDoc(gsbRef),
                        getDoc(undergradRef)
                    ]);

                    let targetDocId = gsbDocId;
                    let detectedClass: UserClass = 'gsb';

                    // Get the last used class from localStorage
                    const lastUsedClass = getLastUsedClass();

                    // Prefer the last used class if both documents exist and have names
                    if (lastUsedClass === 'undergrad' && undergradDoc.exists() && undergradDoc.data().name) {
                        targetDocId = undergradDocId;
                        detectedClass = 'undergrad';
                    } else if (lastUsedClass === 'gsb' && gsbDoc.exists() && gsbDoc.data().name) {
                        targetDocId = gsbDocId;
                        detectedClass = 'gsb';
                    } else if (gsbDoc.exists() && gsbDoc.data().name) {
                        // Fallback to GSB if no preference or preference doesn't exist
                        targetDocId = gsbDocId;
                        detectedClass = 'gsb';
                    } else if (undergradDoc.exists() && undergradDoc.data().name) {
                        targetDocId = undergradDocId;
                        detectedClass = 'undergrad';
                    } else if (gsbDoc.exists()) {
                        // Fall back to GSB if neither has a name
                        targetDocId = gsbDocId;
                        detectedClass = 'gsb';
                    } else if (undergradDoc.exists()) {
                        targetDocId = undergradDocId;
                        detectedClass = 'undergrad';
                    }

                    // Set up real-time listener for the target document
                    const targetRef = doc(db, 'users', targetDocId);
                    unsubscribe = onSnapshot(targetRef, (doc) => {
                        if (doc.exists()) {
                            const data = doc.data();
                            const userData: UserData = {
                                uid: data.uid,
                                email: data.email,
                                name: data.name || data.verifiedName || data.displayName || '',
                                photoURL: data.photoURL,
                                crushes: data.crushes || [],
                                lockedCrushes: data.lockedCrushes || [],
                                matches: normalizeMatches(data.matches),
                                crushCount: data.crushCount || 0,
                                userClass: data.userClass || detectedClass,
                                createdAt: data.createdAt,
                                updatedAt: data.updatedAt,
                                lastLogin: data.lastLogin
                            };
                            setUserData(userData);

                            // Update localStorage with the class we're actually using
                            setLastUsedClass(detectedClass);
                        } else {
                            setUserData(null);
                        }
                    }, (error) => {
                        console.error('Error in real-time user data listener:', error);
                        setUserData(null);
                    });

                } else {
                    // Regular user logic - set up real-time listener
                    const userRef = doc(db, 'users', user.uid);
                    unsubscribe = onSnapshot(userRef, (doc) => {
                        if (doc.exists()) {
                            const data = doc.data();
                            const userData: UserData = {
                                uid: data.uid,
                                email: data.email,
                                name: data.name || data.verifiedName || data.displayName || '',
                                photoURL: data.photoURL,
                                crushes: data.crushes || [],
                                lockedCrushes: data.lockedCrushes || [],
                                matches: normalizeMatches(data.matches),
                                crushCount: data.crushCount || 0,
                                userClass: data.userClass || 'gsb',
                                createdAt: data.createdAt,
                                updatedAt: data.updatedAt,
                                lastLogin: data.lastLogin
                            };
                            setUserData(userData);
                        } else {
                            setUserData(null);
                        }
                    }, (error) => {
                        console.error('Error in real-time user data listener:', error);
                        setUserData(null);
                    });
                }
            } catch (error) {
                console.error('Error setting up real-time listener:', error);
                setUserData(null);
            }
        };

        setupListener();

        // Cleanup function
        return () => {
            if (unsubscribe) {
                unsubscribe();
            }
        };
    }, [user?.uid, user?.email, normalizeMatches, getLastUsedClass, setLastUsedClass]);

    const refreshUserData = async () => {
        // With real-time listeners, manual refresh is not needed
        // The listener will automatically update when data changes
        console.log('Real-time listener active - manual refresh not needed');
    };

    useEffect(() => {
        const unsubscribe = onAuthStateChanged(auth, async (user) => {
            if (user) {
                if (!user.email?.endsWith('@stanford.edu')) {
                    await signOut(auth);
                    setUser(null);
                    setUserData(null);
                    setLoading(false);
                    alert('Only @stanford.edu email addresses are allowed. Please sign in with your Stanford account.');
                } else {
                    setUser(user);
                    setLoading(false);
                    // Real-time listener will be set up in the useEffect above
                }
            } else {
                setUser(null);
                setUserData(null);
                setNameOptions(null);
                setPendingUserClass(null);
                setLoading(false);
            }
        });

        return unsubscribe;
    }, []);

    const signInWithGoogle = async (userClass: UserClass) => {
        try {
            const result = await signInWithPopup(auth, googleProvider);

            if (!result.user.email?.endsWith('@stanford.edu')) {
                await signOut(auth);
                throw new Error('Only @stanford.edu email addresses are allowed');
            }

            // Create or update user document with the selected class
            await createOrUpdateUserDocument(result.user, userClass);
        } catch (error: any) {
            console.error('Login error:', error);

            if (error.code === 'auth/popup-closed-by-user') {
                console.log('Sign-in popup was closed by user');
            } else if (error.code === 'auth/cancelled-popup-request') {
                console.log('Another sign-in popup is already open');
            } else {
                alert('Login failed. Please make sure you\'re using a @stanford.edu email address.');
            }
        }
    };

    const logout = async () => {
        try {
            await signOut(auth);
            setUserData(null);
            setNameOptions(null);
            setPendingUserClass(null);
            // Clear the last used class on logout
            try {
                localStorage.removeItem('lastUsedClass');
            } catch {
                // Ignore localStorage errors
            }
        } catch (error) {
            console.error('Logout error:', error);
        }
    };

    const value = {
        user,
        userData,
        loading,
        nameOptions,
        signInWithGoogle,
        selectName,
        logout,
        refreshUserData
    };

    return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
};

================
File: src/App.css
================
@import './styles/base.css';
@import './styles/auth.css';
@import './styles/dashboard.css';
@import './styles/admin.css';

================
File: src/components/AdminView.tsx
================
import React, { useState, useCallback, useEffect, useMemo } from 'react';
import { collection, query, orderBy, limit, onSnapshot } from 'firebase/firestore';
import { db } from '../config/firebase';
import AdminAnalytics from './admin/AdminAnalytics';
import AdminUsers from './admin/AdminUsers';
import { useAdminData } from '../hooks/useAdminData';
import { useAdminUtils } from '../hooks/useAdminUtils';
import type { UserData, UserClass } from '../types/userTypes';

type ViewMode = 'analytics' | 'users';
type UserFilter = 'all' | 'active' | 'inactive' | 'ghost';

interface AdminViewProps {
    user: any;
    userData: UserData | null;
}

const AdminView: React.FC<AdminViewProps> = ({ user, userData }) => {
    // Server-side admin check with error handling
    const [adminAccessDenied, setAdminAccessDenied] = useState(false);
    const [adminSearchTerm, setAdminSearchTerm] = useState('');
    const [viewingUserId, setViewingUserId] = useState<string | null>(null);
    const [userFilter, setUserFilter] = useState<UserFilter>('all');
    const [viewMode, setViewMode] = useState<ViewMode>('analytics');
    const [refreshKey, setRefreshKey] = useState(0);

    // Automatically determine which class view to show based on current user's class
    const currentClassView: UserClass = userData?.userClass || 'gsb';
    const classDisplayName = currentClassView === 'gsb' ? 'GSB MBA' : 'Undergraduate';

    // Use custom hooks
    const {
        allUsers,
        loadingUsers,
        currentAnalytics,
        loadingAnalytics,
        loadAllUsers
    } = useAdminData(user, currentClassView, refreshKey);

    const { findCrushersForUser } = useAdminUtils(allUsers || []);

    // Strict admin access control
    useEffect(() => {
        if (user?.email !== 'jpark22@stanford.edu') {
            setAdminAccessDenied(true);
            return;
        }
        setAdminAccessDenied(false);
    }, [user?.email]);

    // Early return for non-admin users
    if (adminAccessDenied) {
        return (
            <div className="admin-access-denied">
                <div className="access-denied-card">
                    <h2>Access Denied</h2>
                    <p>You do not have permission to view this page.</p>
                    <p>Admin access is restricted to authorized personnel only.</p>
                </div>
            </div>
        );
    }

    // Only proceed with admin functionality if user is confirmed admin
    if (user?.email !== 'jpark22@stanford.edu') {
        return (
            <div className="admin-loading">
                Verifying admin access...
            </div>
        );
    }

    // Set up real-time listener for analytics with error handling and admin check
    useEffect(() => {
        if (user?.email !== 'jpark22@stanford.edu') return;

        const analyticsQuery = query(
            collection(db, 'analytics'),
            orderBy('createdAt', 'desc'),
            limit(1)
        );

        const unsubscribe = onSnapshot(analyticsQuery, (snapshot) => {
            if (!snapshot.empty) {
                console.log('Live analytics updated');
                // Trigger recalculation when new analytics arrive
                setRefreshKey(prev => prev + 1);
            }
        }, (error) => {
            console.error('Error listening to analytics:', error);
            // If we get a permission error, user is not admin
            if (error.code === 'permission-denied') {
                setAdminAccessDenied(true);
            }
        });

        return () => unsubscribe();
    }, [user?.email]);

    // Get current class stats with proper null checks
    const currentClassStats = useMemo(() => {
        // Add null/undefined checks for allUsers
        if (!allUsers || !Array.isArray(allUsers)) {
            return {
                activeUsers: 0,
                inactiveUsers: 0,
                ghostUsers: 0,
                total: 0
            };
        }

        const realUsers = allUsers.filter(u => !(u as any).isInactive && !(u as any).isGhost);
        const inactiveUsers = allUsers.filter(u => (u as any).isInactive);
        const ghostUsers = allUsers.filter(u => (u as any).isGhost);

        return {
            activeUsers: realUsers.length,
            inactiveUsers: inactiveUsers.length,
            ghostUsers: ghostUsers.length,
            total: allUsers.length
        };
    }, [allUsers]);

    const handleViewUser = useCallback((userId: string) => {
        setViewingUserId(viewingUserId === userId ? null : userId);
    }, [viewingUserId]);

    const handleRefresh = useCallback(async () => {
        setRefreshKey(prev => prev + 1);
        await loadAllUsers();
    }, [loadAllUsers]);

    // Show loading state if allUsers is not yet loaded
    if (!allUsers && loadingUsers) {
        return (
            <div className="admin-loading">
                Loading {classDisplayName} admin data...
            </div>
        );
    }

    return (
        <div className="admin-section">
            <div className="admin-header-section">
                <div className="admin-title-row">
                    <h3>{classDisplayName} Admin Dashboard</h3>
                    <button onClick={handleRefresh} className="admin-refresh-btn" disabled={loadingUsers || loadingAnalytics}>
                        {loadingUsers || loadingAnalytics ? 'â†» Loading...' : 'â†» Refresh'}
                    </button>
                </div>

                <div className="admin-definitions">
                    <p><strong>Current View:</strong> You are viewing data for the {classDisplayName} class only. Switch to a different class account to view other class data.</p>
                    <p><strong>Active Users:</strong> {classDisplayName} students who have signed up and can match within their class.</p>
                    <p><strong>Inactive Users:</strong> {classDisplayName} students from the class roster who haven't signed up yet but are receiving crushes.</p>
                    <p><strong>Ghost Users:</strong> {classDisplayName} students from the class roster with zero engagement.</p>
                </div>
            </div>

            {/* View Mode Navigation */}
            <div className="admin-nav">
                <button
                    onClick={() => setViewMode('analytics')}
                    className={`admin-nav-btn ${viewMode === 'analytics' ? 'active' : ''}`}
                    disabled={loadingAnalytics}
                >
                    {classDisplayName} Analytics {loadingAnalytics && '(Loading...)'}
                </button>
                <button
                    onClick={() => setViewMode('users')}
                    className={`admin-nav-btn ${viewMode === 'users' ? 'active' : ''}`}
                    disabled={loadingUsers}
                >
                    {classDisplayName} Users ({currentClassStats.total}) {loadingUsers && '(Loading...)'}
                </button>
            </div>

            <div className="admin-content">
                {viewMode === 'analytics' && (
                    <AdminAnalytics
                        analytics={currentAnalytics}
                        classView={currentClassView}
                        classDisplayName={classDisplayName}
                        allUsers={allUsers || []}
                    />
                )}
                {viewMode === 'users' && (
                    <AdminUsers
                        allUsers={allUsers || []}
                        loadingUsers={loadingUsers}
                        adminSearchTerm={adminSearchTerm}
                        setAdminSearchTerm={setAdminSearchTerm}
                        userFilter={userFilter}
                        setUserFilter={setUserFilter}
                        viewingUserId={viewingUserId}
                        handleViewUser={handleViewUser}
                        findCrushersForUser={findCrushersForUser}
                        userStats={currentClassStats}
                        classView={currentClassView}
                        classDisplayName={classDisplayName}
                    />
                )}
            </div>
        </div>
    );
};

export default AdminView;

================
File: functions/src/index.ts
================
import * as functions from 'firebase-functions';
import * as admin from 'firebase-admin';
import { UserData, UserWithId } from './types';
import { findUserByName, getUserIdentityName } from './utils';
import { processUpdatedCrushes, fixAllCrushCounts, fixAllMatchTimestampsToNow } from './matchingEngine';

export { scheduledAnalytics, runAnalyticsNow } from './scheduledAnalytics';

// Initialize Firebase Admin if not already initialized
if (!admin.apps.length) {
    admin.initializeApp();
}

const db = admin.firestore();

// Enhanced function to find matches and update crush counts
export const findMatches = functions.firestore
    .document('users/{userId}')
    .onUpdate(async (change, context) => {
        const userId = context.params.userId;
        const beforeData = change.before.data() as UserData;
        const afterData = change.after.data() as UserData;

        // Check if crushes were updated OR if name was updated
        const beforeCrushes = beforeData?.crushes || [];
        const afterCrushes = afterData?.crushes || [];
        const beforeName = getUserIdentityName(beforeData as any);
        const afterName = getUserIdentityName(afterData as any);

        // Normalize arrays for comparison
        const normalizedBefore = beforeCrushes.map(crush => crush.trim().toLowerCase()).sort();
        const normalizedAfter = afterCrushes.map(crush => crush.trim().toLowerCase()).sort();

        const crushesChanged = JSON.stringify(normalizedBefore) !== JSON.stringify(normalizedAfter);
        const nameChanged = beforeName !== afterName;

        console.log(`Checking update for user ${userId} (${afterName})`);
        console.log(`Crushes changed: ${crushesChanged}, Name changed: ${nameChanged}`);

        // Process if crushes changed OR if name changed (which affects how others' crushes map to this user)
        if (crushesChanged || nameChanged) {
            console.log(`âœ… Processing update for user ${userId} (${afterName})`);

            // Validate that locked crushes are still present (only for crush changes)
            if (crushesChanged) {
                const lockedCrushes = beforeData?.lockedCrushes || [];
                const missingLockedCrushes = lockedCrushes.filter(locked => !afterCrushes.includes(locked));

                if (missingLockedCrushes.length > 0) {
                    console.log(`âŒ User ${userId} tried to remove locked crushes: ${missingLockedCrushes.join(', ')}`);
                    // Restore the locked crushes
                    const restoredCrushes = [...new Set([...afterCrushes, ...lockedCrushes])];

                    const userRef = db.collection('users').doc(userId);
                    await userRef.update({
                        crushes: restoredCrushes,
                        updatedAt: admin.firestore.FieldValue.serverTimestamp()
                    });

                    console.log(`âœ… Restored locked crushes for user ${userId}`);
                    return null;
                }
            }

            // Add a small delay to prevent race conditions
            await new Promise(resolve => setTimeout(resolve, 1000));

            await processUpdatedCrushes();
        } else {
            console.log(`âŒ No relevant changes detected for user ${userId} (${afterName}), skipping`);
        }

        return null;
    });

// Manual function to trigger complete recalculation
export const recalculateAllMatches = functions.https.onRequest(async (req, res) => {
    try {
        await processUpdatedCrushes();
        res.json({
            success: true,
            message: 'Successfully recalculated all matches and crush counts with enhanced name matching'
        });
    } catch (error) {
        console.error('Error in recalculateAllMatches:', error);
        res.status(500).json({ error: 'Failed to recalculate matches and crush counts' });
    }
});

// NEW: Manual function to fix crush count discrepancies
export const fixCrushCountDiscrepancies = functions.https.onRequest(async (req, res) => {
    try {
        console.log('ðŸ”§ Starting manual fix of crush count discrepancies...');
        await fixAllCrushCounts();
        res.json({
            success: true,
            message: 'Successfully fixed all crush count discrepancies'
        });
    } catch (error) {
        console.error('âŒ Error fixing crush count discrepancies:', error);
        res.status(500).json({ error: 'Failed to fix crush count discrepancies' });
    }
});

// NEW: Function to fix all match timestamps to now (one-time)
export const fixMatchTimestampsToNow = functions.https.onRequest(async (req, res) => {
    try {
        console.log('ðŸ”§ Setting all existing match timestamps to now...');
        await fixAllMatchTimestampsToNow();
        res.json({
            success: true,
            message: 'Successfully set all existing match timestamps to now (except James Park matches)'
        });
    } catch (error) {
        console.error('âŒ Error fixing match timestamps:', error);
        res.status(500).json({ error: 'Failed to fix match timestamps' });
    }
});

// Legacy timestamp function
export const fixMatchTimestamps = functions.https.onRequest(async (req, res) => {
    try {
        console.log('ðŸ”§ Starting one-time fix for missing match timestamps...');
        await fixAllMatchTimestampsToNow();
        res.json({
            success: true,
            message: 'Successfully fixed missing match timestamps'
        });
    } catch (error) {
        console.error('âŒ Error fixing match timestamps:', error);
        res.status(500).json({ error: 'Failed to fix match timestamps' });
    }
});

// New function to add timestamps to existing matches
export const addTimestampsToMatches = functions.https.onRequest(async (req, res) => {
    try {
        console.log('ðŸ”„ Adding timestamps to existing matches...');

        // Use current timestamp for all existing matches
        const currentTimestamp = admin.firestore.Timestamp.now();

        let updatedUsers = 0;
        let totalMatchesUpdated = 0;

        await db.runTransaction(async (transaction) => {
            // Get all users
            const usersSnapshot = await transaction.get(db.collection('users'));

            usersSnapshot.forEach(doc => {
                const userData = doc.data();
                const matches = userData.matches || [];

                if (matches.length > 0) {
                    // Check if any matches are missing timestamps
                    let needsUpdate = false;
                    const updatedMatches = matches.map((match: any) => {
                        if (!match.matchedAt) {
                            needsUpdate = true;
                            totalMatchesUpdated++;
                            return {
                                ...match,
                                matchedAt: currentTimestamp
                            };
                        }
                        return match;
                    });

                    if (needsUpdate) {
                        const userRef = db.collection('users').doc(doc.id);
                        transaction.update(userRef, {
                            matches: updatedMatches,
                            updatedAt: admin.firestore.FieldValue.serverTimestamp()
                        });
                        updatedUsers++;

                        console.log(`âœ… Updated ${updatedMatches.filter((m: any) => m.matchedAt === currentTimestamp).length} matches for user: ${userData.name || userData.email}`);
                    }
                }
            });

            console.log(`\nðŸŽ‰ Migration completed!`);
            console.log(`ðŸ“Š Updated ${updatedUsers} users`);
            console.log(`ðŸ’• Added timestamps to ${totalMatchesUpdated} existing matches`);
        });

        res.json({
            success: true,
            message: `Successfully added timestamps to ${totalMatchesUpdated} existing matches across ${updatedUsers} users`
        });

    } catch (error) {
        console.error('âŒ Error adding timestamps to matches:', error);
        res.status(500).json({ error: 'Failed to add timestamps to matches' });
    }
});

// Migration function to clean up and standardize the database
export const migrateToSingleNameField = functions.https.onRequest(async (req, res) => {
    try {
        console.log('ðŸ”„ Starting migration to single name field...');

        await db.runTransaction(async (transaction) => {
            // Get all users
            const allUsersSnapshot = await transaction.get(db.collection('users'));

            const allUsers: UserWithId[] = allUsersSnapshot.docs.map(doc => ({
                id: doc.id,
                ...doc.data() as any
            }));

            console.log(`ðŸ“Š Processing ${allUsers.length} users for migration`);

            let migratedUsers = 0;
            let errorUsers = 0;

            for (const user of allUsers) {
                const userRef = db.collection('users').doc(user.id);

                try {
                    // Determine the best name to use
                    let finalName = user.name;

                    if (!finalName || finalName.trim() === '') {
                        // Try verifiedName first, then displayName
                        finalName = user.verifiedName || user.displayName || '';
                    }

                    if (!finalName || finalName.trim() === '') {
                        console.log(`âš ï¸ User ${user.id} (${user.email}) has no name - skipping`);
                        errorUsers++;
                        continue;
                    }

                    // Prepare update data
                    const updateData: any = {
                        name: finalName,
                        updatedAt: admin.firestore.FieldValue.serverTimestamp()
                    };

                    // Remove legacy fields if they exist
                    if (user.displayName !== undefined) {
                        updateData.displayName = admin.firestore.FieldValue.delete();
                    }
                    if (user.verifiedName !== undefined) {
                        updateData.verifiedName = admin.firestore.FieldValue.delete();
                    }

                    transaction.update(userRef, updateData);
                    migratedUsers++;

                    console.log(`âœ… Migrated user ${user.email}: "${finalName}"`);

                } catch (error) {
                    console.error(`âŒ Error migrating user ${user.id}:`, error);
                    errorUsers++;
                }
            }

            console.log(`ðŸŽ‰ Migration completed! Migrated: ${migratedUsers}, Errors: ${errorUsers}`);

            // Now trigger a recalculation to fix any crush references
            setTimeout(async () => {
                await processUpdatedCrushes();
            }, 2000);
        });

        res.json({
            success: true,
            message: 'Successfully migrated users to single name field'
        });
    } catch (error) {
        console.error('âŒ Error in migration:', error);
        res.status(500).json({ error: 'Failed to migrate users' });
    }
});

// Clean up orphaned crushes function
export const cleanupOrphanedCrushes = functions.https.onRequest(async (req, res) => {
    try {
        console.log('ðŸ”§ Starting cleanup of orphaned crushes...');

        await db.runTransaction(async (transaction) => {
            // Get all users
            const allUsersSnapshot = await transaction.get(db.collection('users'));

            const allUsers: UserWithId[] = allUsersSnapshot.docs.map(doc => ({
                id: doc.id,
                ...doc.data() as any
            }));

            console.log(`ðŸ“Š Processing ${allUsers.length} users for cleanup`);

            // Find all unique crush names and map them to actual users
            const allCrushNames = new Set<string>();
            const crushToUserMap = new Map<string, UserWithId>();

            allUsers.forEach(user => {
                const userCrushes = user.crushes || [];
                userCrushes.forEach(crushName => {
                    allCrushNames.add(crushName);
                });

                // Map user's identity name to the user
                const identityName = getUserIdentityName(user);
                if (identityName) {
                    crushToUserMap.set(identityName, user);
                }
            });

            console.log(`ðŸ” Found ${allCrushNames.size} unique crush names`);

            // Update crushes to use consistent names
            let updatedUsers = 0;

            for (const user of allUsers) {
                const userCrushes = user.crushes || [];
                let needsUpdate = false;
                const updatedCrushes: string[] = [];
                const userClass = user.userClass || 'gsb';

                for (const crushName of userCrushes) {
                    const targetUser = findUserByName(crushName, allUsers, userClass);

                    if (targetUser) {
                        const correctName = getUserIdentityName(targetUser);
                        if (correctName && correctName !== crushName) {
                            console.log(`ðŸ”§ Updating crush "${crushName}" -> "${correctName}" for user ${user.email}`);
                            needsUpdate = true;
                        }
                        updatedCrushes.push(correctName || crushName);
                    } else {
                        // Keep orphaned crushes as-is (they might sign up later)
                        updatedCrushes.push(crushName);
                    }
                }

                if (needsUpdate) {
                    const userRef = db.collection('users').doc(user.id);
                    transaction.update(userRef, {
                        crushes: updatedCrushes,
                        updatedAt: admin.firestore.FieldValue.serverTimestamp()
                    });
                    updatedUsers++;
                }
            }

            console.log(`âœ… Updated ${updatedUsers} users with cleaned crush references`);

            // Trigger recalculation
            setTimeout(async () => {
                await processUpdatedCrushes();
            }, 2000);
        });

        res.json({
            success: true,
            message: 'Successfully cleaned up orphaned crushes'
        });
    } catch (error) {
        console.error('âŒ Error in cleanup:', error);
        res.status(500).json({ error: 'Failed to cleanup orphaned crushes' });
    }
});

// Clean up takenNames collection since we're not using it anymore
export const removeTakenNamesCollection = functions.https.onRequest(async (req, res) => {
    try {
        console.log('ðŸ—‘ï¸ Removing takenNames collection...');

        const takenNamesSnapshot = await db.collection('takenNames').get();

        if (takenNamesSnapshot.empty) {
            res.json({
                success: true,
                message: 'takenNames collection is already empty'
            });
            return;
        }

        const batch = db.batch();
        takenNamesSnapshot.docs.forEach(doc => {
            batch.delete(doc.ref);
        });

        await batch.commit();

        res.json({
            success: true,
            message: `Deleted ${takenNamesSnapshot.size} documents from takenNames collection`
        });
    } catch (error) {
        console.error('âŒ Error removing takenNames collection:', error);
        res.status(500).json({ error: 'Failed to remove takenNames collection' });
    }
});

================
File: src/components/Home.tsx
================
import React, { useState, useEffect, useCallback } from 'react';
import { doc, updateDoc, getDoc } from 'firebase/firestore';
import { db } from '../config/firebase';
import { useAuth } from '../contexts/AuthContext';
import AdminView from './AdminView';
import UserDashboard from './UserDashboard';

// Helper function to get the correct document ID for user class
function getUserDocumentId(user: any, userData: any): string {
    if (user?.email === 'jpark22@stanford.edu') {
        // For test user, use class-specific UIDs
        const userClass = userData?.userClass || 'gsb';
        return userClass === 'gsb' ? `${user.uid}_gsb` : `${user.uid}_undergrad`;
    }
    return user?.uid || '';
}

const Home: React.FC = () => {
    const { user, userData, logout, refreshUserData } = useAuth();
    const [failedImageUrls, setFailedImageUrls] = useState<Set<string>>(new Set());
    const [searchTerm, setSearchTerm] = useState('');
    const [selectedNames, setSelectedNames] = useState<string[]>([]);
    const [savedNames, setSavedNames] = useState<string[]>([]);
    const [loading, setLoading] = useState(true);
    const [updating, setUpdating] = useState(false);
    const [error, setError] = useState<string | null>(null);
    const [isAdminMode, setIsAdminMode] = useState(false);
    const [adminAccessError, setAdminAccessError] = useState(false);

    // Strict admin check - only jpark22@stanford.edu can access admin mode
    const isAdmin = user?.email === 'jpark22@stanford.edu';

    // Get the class display name based on user's class
    const getClassDisplayName = useCallback(() => {
        const userClass = userData?.userClass || 'gsb';
        return userClass === 'gsb' ? 'GSB MBA Class of 2025' : 'Undergrad Class of 2025';
    }, [userData?.userClass]);

    const loadUserSelections = useCallback(async () => {
        if (!user || !userData) return;

        try {
            const actualUid = getUserDocumentId(user, userData);
            const userRef = doc(db, 'users', actualUid);
            const userDoc = await getDoc(userRef);

            if (userDoc.exists()) {
                const data = userDoc.data();
                const crushes = data.crushes && Array.isArray(data.crushes) ? data.crushes : [];
                setSelectedNames(crushes);
                setSavedNames(crushes);
            } else {
                setSelectedNames([]);
                setSavedNames([]);
            }
        } catch (error) {
            console.error('Error loading user selections:', error);
            setError('Failed to load your previous selections.');
            setSelectedNames([]);
            setSavedNames([]);
        }
    }, [user, userData]);

    useEffect(() => {
        const loadData = async () => {
            try {
                setError(null);
                setAdminAccessError(false);
                if (user && userData) {
                    await loadUserSelections();
                }
            } catch (error) {
                console.error('Error loading data:', error);
                setError('Failed to load your data. Please refresh the page.');
            } finally {
                setLoading(false);
            }
        };

        loadData();
    }, [user, userData, loadUserSelections]);

    // Improved image error handling that prevents flickering
    const handleImageError = useCallback((imageUrl: string) => {
        console.log('Image failed to load:', imageUrl);
        setFailedImageUrls(prev => new Set(prev).add(imageUrl));
    }, []);

    // Get profile image URL with proper fallback logic
    const getProfileImageUrl = useCallback(() => {
        const googlePhotoUrl = userData?.photoURL;
        const fallbackUrl = '/files/default-profile.png';

        // If we don't have a Google photo URL, use fallback
        if (!googlePhotoUrl) {
            return fallbackUrl;
        }

        // If this specific Google photo URL has failed before, use fallback
        if (failedImageUrls.has(googlePhotoUrl)) {
            return fallbackUrl;
        }

        // Try the Google photo URL
        return googlePhotoUrl;
    }, [userData?.photoURL, failedImageUrls]);

    const handleNameToggle = useCallback((name: string) => {
        if (updating) return;

        setSelectedNames(prev => {
            const currentNames = prev || [];
            return currentNames.includes(name)
                ? currentNames.filter(n => n !== name)
                : [...currentNames, name];
        });
    }, [updating]);

    const handleRemoveSelected = useCallback((nameToRemove: string) => {
        if (updating) return;

        const lockedCrushes = userData?.lockedCrushes || [];
        if (lockedCrushes.includes(nameToRemove)) {
            return;
        }

        setSelectedNames(prev => (prev || []).filter(name => name !== nameToRemove));
    }, [updating, userData?.lockedCrushes]);

    const handleUpdatePreferences = useCallback(async () => {
        if (!user || !userData || updating) return;

        const lockedCrushes = userData?.lockedCrushes || [];
        const currentSelectedNames = selectedNames || [];
        const missingLockedCrushes = lockedCrushes.filter(locked => !currentSelectedNames.includes(locked));

        if (missingLockedCrushes.length > 0) {
            const restoredNames = [...new Set([...currentSelectedNames, ...lockedCrushes])];
            setSelectedNames(restoredNames);
        }

        setUpdating(true);
        setError(null);

        try {
            const actualUid = getUserDocumentId(user, userData);
            const userRef = doc(db, 'users', actualUid);
            const finalCrushes = [...new Set([...currentSelectedNames, ...lockedCrushes])];

            await updateDoc(userRef, {
                crushes: finalCrushes,
                updatedAt: new Date()
            });

            setSelectedNames(finalCrushes);
            setSavedNames(finalCrushes);
            await refreshUserData();

            const successDiv = document.createElement('div');
            successDiv.textContent = 'Preferences updated successfully!';
            successDiv.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #28a745;
                color: white;
                padding: 12px 20px;
                border-radius: 8px;
                z-index: 1000;
                font-weight: 500;
                box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            `;
            document.body.appendChild(successDiv);

            setTimeout(() => {
                if (document.body.contains(successDiv)) {
                    document.body.removeChild(successDiv);
                }
            }, 3000);

        } catch (error) {
            console.error('Error updating preferences:', error);
            setError('Failed to update preferences. Please try again.');
        } finally {
            setUpdating(false);
        }
    }, [user, userData, updating, selectedNames, refreshUserData]);

    // Enhanced admin mode toggle with proper error handling
    const handleAdminToggle = useCallback(() => {
        if (!isAdmin) {
            setAdminAccessError(true);
            setTimeout(() => setAdminAccessError(false), 3000);
            return;
        }
        setIsAdminMode(!isAdminMode);
    }, [isAdmin, isAdminMode]);

    if (loading) {
        return <div className="loading">Loading...</div>;
    }

    if (error) {
        return (
            <div className="loading">
                <p style={{ color: 'red' }}>{error}</p>
                <button onClick={() => window.location.reload()}>Refresh Page</button>
            </div>
        );
    }

    const currentImageUrl = getProfileImageUrl();

    return (
        <div className="dashboard-container">
            <div className="dashboard-card">
                <div className="dashboard-header">
                    <h1>Past Chances: {getClassDisplayName()}</h1>
                    <div className="user-info">
                        <div className="user-details">
                            <img
                                src={currentImageUrl}
                                alt="Profile"
                                className="profile-pic"
                                onError={() => handleImageError(currentImageUrl)}
                                loading="lazy"
                            />
                            <div>
                                <div className="user-name">{userData?.name || user?.displayName}</div>
                                <div className="user-email">{user?.email}</div>
                            </div>
                        </div>
                        <div className="header-actions">
                            {isAdmin && (
                                <button
                                    onClick={handleAdminToggle}
                                    className="admin-toggle-btn"
                                >
                                    {isAdminMode ? 'Exit Admin View' : 'Admin View'}
                                </button>
                            )}
                            <button className="logout-btn" onClick={logout}>Logout</button>
                        </div>
                    </div>
                </div>

                {adminAccessError && (
                    <div className="error-message" style={{
                        background: '#f8d7da',
                        color: '#721c24',
                        padding: '10px',
                        margin: '10px 20px',
                        borderRadius: '4px',
                        fontSize: '14px',
                        textAlign: 'center'
                    }}>
                        Access denied. Admin privileges are required.
                    </div>
                )}

                <div className="dashboard-content">
                    {isAdminMode && isAdmin ? (
                        <AdminView user={user} userData={userData} />
                    ) : (
                        <UserDashboard
                            userData={userData!}
                            searchTerm={searchTerm}
                            setSearchTerm={setSearchTerm}
                            selectedNames={selectedNames || []}
                            savedNames={savedNames || []}
                            updating={updating}
                            error={error}
                            handleNameToggle={handleNameToggle}
                            handleRemoveSelected={handleRemoveSelected}
                            handleUpdatePreferences={handleUpdatePreferences}
                        />
                    )}
                </div>
            </div>
        </div>
    );
};

export default Home;




================================================================
End of Codebase
================================================================
